// v0.3.80
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../../node_modules/@stripe/stripe-js/dist/pure.js
var require_pure = __commonJS({
  "../../../node_modules/@stripe/stripe-js/dist/pure.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var V3_URL = "https://js.stripe.com/v3";
    var V3_URL_REGEX = /^https:\/\/js\.stripe\.com\/v3\/?(\?.*)?$/;
    var EXISTING_SCRIPT_MESSAGE = "loadStripe.setLoadParameters was called but an existing Stripe.js script already exists in the document; existing script parameters will be used";
    var findScript = function findScript2() {
      var scripts = document.querySelectorAll('script[src^="'.concat(V3_URL, '"]'));
      for (var i = 0; i < scripts.length; i++) {
        var script = scripts[i];
        if (!V3_URL_REGEX.test(script.src)) {
          continue;
        }
        return script;
      }
      return null;
    };
    var injectScript = function injectScript2(params) {
      var queryString = params && !params.advancedFraudSignals ? "?advancedFraudSignals=false" : "";
      var script = document.createElement("script");
      script.src = "".concat(V3_URL).concat(queryString);
      var headOrBody = document.head || document.body;
      if (!headOrBody) {
        throw new Error("Expected document.body not to be null. Stripe.js requires a <body> element.");
      }
      headOrBody.appendChild(script);
      return script;
    };
    var registerWrapper = function registerWrapper2(stripe2, startTime) {
      if (!stripe2 || !stripe2._registerWrapper) {
        return;
      }
      stripe2._registerWrapper({
        name: "stripe-js",
        version: "1.54.1",
        startTime
      });
    };
    var stripePromise = null;
    var loadScript = function loadScript2(params) {
      if (stripePromise !== null) {
        return stripePromise;
      }
      stripePromise = new Promise(function(resolve, reject) {
        if (typeof window === "undefined" || typeof document === "undefined") {
          resolve(null);
          return;
        }
        if (window.Stripe && params) {
          console.warn(EXISTING_SCRIPT_MESSAGE);
        }
        if (window.Stripe) {
          resolve(window.Stripe);
          return;
        }
        try {
          var script = findScript();
          if (script && params) {
            console.warn(EXISTING_SCRIPT_MESSAGE);
          } else if (!script) {
            script = injectScript(params);
          }
          script.addEventListener("load", function() {
            if (window.Stripe) {
              resolve(window.Stripe);
            } else {
              reject(new Error("Stripe.js not available"));
            }
          });
          script.addEventListener("error", function() {
            reject(new Error("Failed to load Stripe.js"));
          });
        } catch (error) {
          reject(error);
          return;
        }
      });
      return stripePromise;
    };
    var initStripe = function initStripe2(maybeStripe, args, startTime) {
      if (maybeStripe === null) {
        return null;
      }
      var stripe2 = maybeStripe.apply(void 0, args);
      registerWrapper(stripe2, startTime);
      return stripe2;
    };
    var validateLoadParams = function validateLoadParams2(params) {
      var errorMessage = "invalid load parameters; expected object of shape\n\n    {advancedFraudSignals: boolean}\n\nbut received\n\n    ".concat(JSON.stringify(params), "\n");
      if (params === null || _typeof(params) !== "object") {
        throw new Error(errorMessage);
      }
      if (Object.keys(params).length === 1 && typeof params.advancedFraudSignals === "boolean") {
        return params;
      }
      throw new Error(errorMessage);
    };
    var loadParams;
    var loadStripeCalled = false;
    var loadStripe2 = function loadStripe3() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      loadStripeCalled = true;
      var startTime = Date.now();
      return loadScript(loadParams).then(function(maybeStripe) {
        return initStripe(maybeStripe, args, startTime);
      });
    };
    loadStripe2.setLoadParameters = function(params) {
      if (loadStripeCalled && loadParams) {
        var validatedParams = validateLoadParams(params);
        var parameterKeys = Object.keys(validatedParams);
        var sameParameters = parameterKeys.reduce(function(previousValue, currentValue) {
          var _loadParams;
          return previousValue && params[currentValue] === ((_loadParams = loadParams) === null || _loadParams === void 0 ? void 0 : _loadParams[currentValue]);
        }, true);
        if (sameParameters) {
          return;
        }
      }
      if (loadStripeCalled) {
        throw new Error("You cannot change load parameters after calling loadStripe");
      }
      loadParams = validateLoadParams(params);
    };
    exports.loadStripe = loadStripe2;
  }
});

// ../../../node_modules/@stripe/stripe-js/pure.js
var require_pure2 = __commonJS({
  "../../../node_modules/@stripe/stripe-js/pure.js"(exports, module) {
    "use strict";
    module.exports = require_pure();
  }
});

// ../../../node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r2 = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r2 = (c < 3 ? d(r2) : c > 3 ? d(target, key, r2) : d(target, key)) || r2;
  return c > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r2, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r2[k] = a[j];
  return r2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state2, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
}
function __classPrivateFieldSet(receiver, state2, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state2.set(receiver, value), value;
}
function __classPrivateFieldIn(state2, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 === "function" ? receiver === state2 : state2.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose3, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose3 = value[Symbol.asyncDispose];
    }
    if (dispose3 === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose3 = value[Symbol.dispose];
      if (async) inner = dispose3;
    }
    if (typeof dispose3 !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose3 = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose: dispose3, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r2, s = 0;
  function next() {
    while (r2 = env.stack.pop()) {
      try {
        if (!r2.async && s === 1) return s = 0, env.stack.push(r2), Promise.resolve().then(next);
        if (r2.dispose) {
          var result = r2.dispose.call(r2.value);
          if (r2.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "../../../node_modules/tslib/tslib.es6.mjs"() {
    "use strict";
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    ownKeys = function(o) {
      ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
        return ar;
      };
      return ownKeys(o);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/lib/WebmBase.js
var require_WebmBase = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/lib/WebmBase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebmBase = void 0;
    var WebmBase = class {
      constructor(name = "Unknown", start = 0) {
        this.name = name;
        this.start = start;
      }
      getType() {
        return "Unknown";
      }
      updateBySource() {
      }
      setSource(source) {
        this.source = source;
        this.updateBySource();
      }
      updateByData() {
      }
      setData(data) {
        this.data = data;
        this.updateByData();
      }
      getValue() {
        return this.data;
      }
      setValue(value) {
        this.setData(value);
      }
    };
    exports.WebmBase = WebmBase;
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/lib/SectionType.js
var require_SectionType = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/lib/SectionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SectionType = void 0;
    var SectionType;
    (function(SectionType2) {
      SectionType2["Container"] = "Container";
      SectionType2["Uint"] = "Uint";
      SectionType2["Int"] = "Int";
      SectionType2["Float"] = "Float";
      SectionType2["String"] = "String";
      SectionType2["Date"] = "Date";
      SectionType2["Binary"] = "Binary";
    })(SectionType || (exports.SectionType = SectionType = {}));
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/lib/sections.js
var require_sections = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/lib/sections.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sections = void 0;
    var SectionType_1 = require_SectionType();
    exports.sections = {
      172351395: { name: "EBML", type: SectionType_1.SectionType.Container },
      646: { name: "EBMLVersion", type: SectionType_1.SectionType.Uint },
      759: { name: "EBMLReadVersion", type: SectionType_1.SectionType.Uint },
      754: { name: "EBMLMaxIDLength", type: SectionType_1.SectionType.Uint },
      755: { name: "EBMLMaxSizeLength", type: SectionType_1.SectionType.Uint },
      642: { name: "DocType", type: SectionType_1.SectionType.String },
      647: { name: "DocTypeVersion", type: SectionType_1.SectionType.Uint },
      645: { name: "DocTypeReadVersion", type: SectionType_1.SectionType.Uint },
      108: { name: "Void", type: SectionType_1.SectionType.Binary },
      63: { name: "CRC-32", type: SectionType_1.SectionType.Binary },
      190023271: { name: "SignatureSlot", type: SectionType_1.SectionType.Container },
      16010: { name: "SignatureAlgo", type: SectionType_1.SectionType.Uint },
      16026: { name: "SignatureHash", type: SectionType_1.SectionType.Uint },
      16037: { name: "SignaturePublicKey", type: SectionType_1.SectionType.Binary },
      16053: { name: "Signature", type: SectionType_1.SectionType.Binary },
      15963: { name: "SignatureElements", type: SectionType_1.SectionType.Container },
      15995: { name: "SignatureElementList", type: SectionType_1.SectionType.Container },
      9522: { name: "SignedElement", type: SectionType_1.SectionType.Binary },
      139690087: { name: "Segment", type: SectionType_1.SectionType.Container },
      21863284: { name: "SeekHead", type: SectionType_1.SectionType.Container },
      3515: { name: "Seek", type: SectionType_1.SectionType.Container },
      5035: { name: "SeekID", type: SectionType_1.SectionType.Binary },
      5036: { name: "SeekPosition", type: SectionType_1.SectionType.Uint },
      88713574: { name: "Info", type: SectionType_1.SectionType.Container },
      13220: { name: "SegmentUID", type: SectionType_1.SectionType.Binary },
      13188: { name: "SegmentFilename", type: SectionType_1.SectionType.String },
      1882403: { name: "PrevUID", type: SectionType_1.SectionType.Binary },
      1868715: { name: "PrevFilename", type: SectionType_1.SectionType.String },
      2013475: { name: "NextUID", type: SectionType_1.SectionType.Binary },
      1999803: { name: "NextFilename", type: SectionType_1.SectionType.String },
      1092: { name: "SegmentFamily", type: SectionType_1.SectionType.Binary },
      10532: { name: "ChapterTranslate", type: SectionType_1.SectionType.Container },
      10748: { name: "ChapterTranslateEditionUID", type: SectionType_1.SectionType.Uint },
      10687: { name: "ChapterTranslateCodec", type: SectionType_1.SectionType.Uint },
      10661: { name: "ChapterTranslateID", type: SectionType_1.SectionType.Binary },
      710577: { name: "TimecodeScale", type: SectionType_1.SectionType.Uint },
      1161: { name: "Duration", type: SectionType_1.SectionType.Float },
      1121: { name: "DateUTC", type: SectionType_1.SectionType.Date },
      15273: { name: "Title", type: SectionType_1.SectionType.String },
      3456: { name: "MuxingApp", type: SectionType_1.SectionType.String },
      5953: { name: "WritingApp", type: SectionType_1.SectionType.String },
      // Intentionally don't recognize the Cluster section because it's large
      // 0xf43b675: { name: "Cluster", type: SectionType.Container },
      103: { name: "Timecode", type: SectionType_1.SectionType.Uint },
      6228: { name: "SilentTracks", type: SectionType_1.SectionType.Container },
      6359: { name: "SilentTrackNumber", type: SectionType_1.SectionType.Uint },
      39: { name: "Position", type: SectionType_1.SectionType.Uint },
      43: { name: "PrevSize", type: SectionType_1.SectionType.Uint },
      35: { name: "SimpleBlock", type: SectionType_1.SectionType.Binary },
      32: { name: "BlockGroup", type: SectionType_1.SectionType.Container },
      33: { name: "Block", type: SectionType_1.SectionType.Binary },
      34: { name: "BlockVirtual", type: SectionType_1.SectionType.Binary },
      13729: { name: "BlockAdditions", type: SectionType_1.SectionType.Container },
      38: { name: "BlockMore", type: SectionType_1.SectionType.Container },
      110: { name: "BlockAddID", type: SectionType_1.SectionType.Uint },
      37: { name: "BlockAdditional", type: SectionType_1.SectionType.Binary },
      27: { name: "BlockDuration", type: SectionType_1.SectionType.Uint },
      122: { name: "ReferencePriority", type: SectionType_1.SectionType.Uint },
      123: { name: "ReferenceBlock", type: SectionType_1.SectionType.Int },
      125: { name: "ReferenceVirtual", type: SectionType_1.SectionType.Int },
      36: { name: "CodecState", type: SectionType_1.SectionType.Binary },
      13730: { name: "DiscardPadding", type: SectionType_1.SectionType.Int },
      14: { name: "Slices", type: SectionType_1.SectionType.Container },
      104: { name: "TimeSlice", type: SectionType_1.SectionType.Container },
      76: { name: "LaceNumber", type: SectionType_1.SectionType.Uint },
      77: { name: "FrameNumber", type: SectionType_1.SectionType.Uint },
      75: { name: "BlockAdditionID", type: SectionType_1.SectionType.Uint },
      78: { name: "Delay", type: SectionType_1.SectionType.Uint },
      79: { name: "SliceDuration", type: SectionType_1.SectionType.Uint },
      72: { name: "ReferenceFrame", type: SectionType_1.SectionType.Container },
      73: { name: "ReferenceOffset", type: SectionType_1.SectionType.Uint },
      74: { name: "ReferenceTimeCode", type: SectionType_1.SectionType.Uint },
      47: { name: "EncryptedBlock", type: SectionType_1.SectionType.Binary },
      106212971: { name: "Tracks", type: SectionType_1.SectionType.Container },
      46: { name: "TrackEntry", type: SectionType_1.SectionType.Container },
      87: { name: "TrackNumber", type: SectionType_1.SectionType.Uint },
      13253: { name: "TrackUID", type: SectionType_1.SectionType.Uint },
      3: { name: "TrackType", type: SectionType_1.SectionType.Uint },
      57: { name: "FlagEnabled", type: SectionType_1.SectionType.Uint },
      8: { name: "FlagDefault", type: SectionType_1.SectionType.Uint },
      5546: { name: "FlagForced", type: SectionType_1.SectionType.Uint },
      28: { name: "FlagLacing", type: SectionType_1.SectionType.Uint },
      11751: { name: "MinCache", type: SectionType_1.SectionType.Uint },
      11768: { name: "MaxCache", type: SectionType_1.SectionType.Uint },
      254851: { name: "DefaultDuration", type: SectionType_1.SectionType.Uint },
      216698: { name: "DefaultDecodedFieldDuration", type: SectionType_1.SectionType.Uint },
      209231: { name: "TrackTimecodeScale", type: SectionType_1.SectionType.Float },
      4991: { name: "TrackOffset", type: SectionType_1.SectionType.Int },
      5614: { name: "MaxBlockAdditionID", type: SectionType_1.SectionType.Uint },
      4974: { name: "Name", type: SectionType_1.SectionType.String },
      177564: { name: "Language", type: SectionType_1.SectionType.String },
      6: { name: "CodecID", type: SectionType_1.SectionType.String },
      9122: { name: "CodecPrivate", type: SectionType_1.SectionType.Binary },
      362120: { name: "CodecName", type: SectionType_1.SectionType.String },
      13382: { name: "AttachmentLink", type: SectionType_1.SectionType.Uint },
      1742487: { name: "CodecSettings", type: SectionType_1.SectionType.String },
      1785920: { name: "CodecInfoURL", type: SectionType_1.SectionType.String },
      438848: { name: "CodecDownloadURL", type: SectionType_1.SectionType.String },
      42: { name: "CodecDecodeAll", type: SectionType_1.SectionType.Uint },
      12203: { name: "TrackOverlay", type: SectionType_1.SectionType.Uint },
      5802: { name: "CodecDelay", type: SectionType_1.SectionType.Uint },
      5819: { name: "SeekPreRoll", type: SectionType_1.SectionType.Uint },
      9764: { name: "TrackTranslate", type: SectionType_1.SectionType.Container },
      9980: { name: "TrackTranslateEditionUID", type: SectionType_1.SectionType.Uint },
      9919: { name: "TrackTranslateCodec", type: SectionType_1.SectionType.Uint },
      9893: { name: "TrackTranslateTrackID", type: SectionType_1.SectionType.Binary },
      96: { name: "Video", type: SectionType_1.SectionType.Container },
      26: { name: "FlagInterlaced", type: SectionType_1.SectionType.Uint },
      5048: { name: "StereoMode", type: SectionType_1.SectionType.Uint },
      5056: { name: "AlphaMode", type: SectionType_1.SectionType.Uint },
      5049: { name: "OldStereoMode", type: SectionType_1.SectionType.Uint },
      48: { name: "PixelWidth", type: SectionType_1.SectionType.Uint },
      58: { name: "PixelHeight", type: SectionType_1.SectionType.Uint },
      5290: { name: "PixelCropBottom", type: SectionType_1.SectionType.Uint },
      5307: { name: "PixelCropTop", type: SectionType_1.SectionType.Uint },
      5324: { name: "PixelCropLeft", type: SectionType_1.SectionType.Uint },
      5341: { name: "PixelCropRight", type: SectionType_1.SectionType.Uint },
      5296: { name: "DisplayWidth", type: SectionType_1.SectionType.Uint },
      5306: { name: "DisplayHeight", type: SectionType_1.SectionType.Uint },
      5298: { name: "DisplayUnit", type: SectionType_1.SectionType.Uint },
      5299: { name: "AspectRatioType", type: SectionType_1.SectionType.Uint },
      963876: { name: "ColourSpace", type: SectionType_1.SectionType.Binary },
      1029411: { name: "GammaValue", type: SectionType_1.SectionType.Float },
      230371: { name: "FrameRate", type: SectionType_1.SectionType.Float },
      97: { name: "Audio", type: SectionType_1.SectionType.Container },
      53: { name: "SamplingFrequency", type: SectionType_1.SectionType.Float },
      14517: { name: "OutputSamplingFrequency", type: SectionType_1.SectionType.Float },
      31: { name: "Channels", type: SectionType_1.SectionType.Uint },
      15739: { name: "ChannelPositions", type: SectionType_1.SectionType.Binary },
      8804: { name: "BitDepth", type: SectionType_1.SectionType.Uint },
      98: { name: "TrackOperation", type: SectionType_1.SectionType.Container },
      99: { name: "TrackCombinePlanes", type: SectionType_1.SectionType.Container },
      100: { name: "TrackPlane", type: SectionType_1.SectionType.Container },
      101: { name: "TrackPlaneUID", type: SectionType_1.SectionType.Uint },
      102: { name: "TrackPlaneType", type: SectionType_1.SectionType.Uint },
      105: { name: "TrackJoinBlocks", type: SectionType_1.SectionType.Container },
      109: { name: "TrackJoinUID", type: SectionType_1.SectionType.Uint },
      64: { name: "TrickTrackUID", type: SectionType_1.SectionType.Uint },
      65: { name: "TrickTrackSegmentUID", type: SectionType_1.SectionType.Binary },
      70: { name: "TrickTrackFlag", type: SectionType_1.SectionType.Uint },
      71: { name: "TrickMasterTrackUID", type: SectionType_1.SectionType.Uint },
      68: { name: "TrickMasterTrackSegmentUID", type: SectionType_1.SectionType.Binary },
      11648: { name: "ContentEncodings", type: SectionType_1.SectionType.Container },
      8768: { name: "ContentEncoding", type: SectionType_1.SectionType.Container },
      4145: { name: "ContentEncodingOrder", type: SectionType_1.SectionType.Uint },
      4146: { name: "ContentEncodingScope", type: SectionType_1.SectionType.Uint },
      4147: { name: "ContentEncodingType", type: SectionType_1.SectionType.Uint },
      4148: { name: "ContentCompression", type: SectionType_1.SectionType.Container },
      596: { name: "ContentCompAlgo", type: SectionType_1.SectionType.Uint },
      597: { name: "ContentCompSettings", type: SectionType_1.SectionType.Binary },
      4149: { name: "ContentEncryption", type: SectionType_1.SectionType.Container },
      2017: { name: "ContentEncAlgo", type: SectionType_1.SectionType.Uint },
      2018: { name: "ContentEncKeyID", type: SectionType_1.SectionType.Binary },
      2019: { name: "ContentSignature", type: SectionType_1.SectionType.Binary },
      2020: { name: "ContentSigKeyID", type: SectionType_1.SectionType.Binary },
      2021: { name: "ContentSigAlgo", type: SectionType_1.SectionType.Uint },
      2022: { name: "ContentSigHashAlgo", type: SectionType_1.SectionType.Uint },
      206814059: { name: "Cues", type: SectionType_1.SectionType.Container },
      59: { name: "CuePoint", type: SectionType_1.SectionType.Container },
      51: { name: "CueTime", type: SectionType_1.SectionType.Uint },
      55: { name: "CueTrackPositions", type: SectionType_1.SectionType.Container },
      119: { name: "CueTrack", type: SectionType_1.SectionType.Uint },
      113: { name: "CueClusterPosition", type: SectionType_1.SectionType.Uint },
      112: { name: "CueRelativePosition", type: SectionType_1.SectionType.Uint },
      50: { name: "CueDuration", type: SectionType_1.SectionType.Uint },
      4984: { name: "CueBlockNumber", type: SectionType_1.SectionType.Uint },
      106: { name: "CueCodecState", type: SectionType_1.SectionType.Uint },
      91: { name: "CueReference", type: SectionType_1.SectionType.Container },
      22: { name: "CueRefTime", type: SectionType_1.SectionType.Uint },
      23: { name: "CueRefCluster", type: SectionType_1.SectionType.Uint },
      4959: { name: "CueRefNumber", type: SectionType_1.SectionType.Uint },
      107: { name: "CueRefCodecState", type: SectionType_1.SectionType.Uint },
      155296873: { name: "Attachments", type: SectionType_1.SectionType.Container },
      8615: { name: "AttachedFile", type: SectionType_1.SectionType.Container },
      1662: { name: "FileDescription", type: SectionType_1.SectionType.String },
      1646: { name: "FileName", type: SectionType_1.SectionType.String },
      1632: { name: "FileMimeType", type: SectionType_1.SectionType.String },
      1628: { name: "FileData", type: SectionType_1.SectionType.Binary },
      1710: { name: "FileUID", type: SectionType_1.SectionType.Uint },
      1653: { name: "FileReferral", type: SectionType_1.SectionType.Binary },
      1633: { name: "FileUsedStartTime", type: SectionType_1.SectionType.Uint },
      1634: { name: "FileUsedEndTime", type: SectionType_1.SectionType.Uint },
      4433776: { name: "Chapters", type: SectionType_1.SectionType.Container },
      1465: { name: "EditionEntry", type: SectionType_1.SectionType.Container },
      1468: { name: "EditionUID", type: SectionType_1.SectionType.Uint },
      1469: { name: "EditionFlagHidden", type: SectionType_1.SectionType.Uint },
      1499: { name: "EditionFlagDefault", type: SectionType_1.SectionType.Uint },
      1501: { name: "EditionFlagOrdered", type: SectionType_1.SectionType.Uint },
      54: { name: "ChapterAtom", type: SectionType_1.SectionType.Container },
      13252: { name: "ChapterUID", type: SectionType_1.SectionType.Uint },
      5716: { name: "ChapterStringUID", type: SectionType_1.SectionType.String },
      17: { name: "ChapterTimeStart", type: SectionType_1.SectionType.Uint },
      18: { name: "ChapterTimeEnd", type: SectionType_1.SectionType.Uint },
      24: { name: "ChapterFlagHidden", type: SectionType_1.SectionType.Uint },
      1432: { name: "ChapterFlagEnabled", type: SectionType_1.SectionType.Uint },
      11879: { name: "ChapterSegmentUID", type: SectionType_1.SectionType.Binary },
      11964: { name: "ChapterSegmentEditionUID", type: SectionType_1.SectionType.Uint },
      9155: { name: "ChapterPhysicalEquiv", type: SectionType_1.SectionType.Uint },
      15: { name: "ChapterTrack", type: SectionType_1.SectionType.Container },
      9: { name: "ChapterTrackNumber", type: SectionType_1.SectionType.Uint },
      0: { name: "ChapterDisplay", type: SectionType_1.SectionType.Container },
      5: { name: "ChapString", type: SectionType_1.SectionType.String },
      892: { name: "ChapLanguage", type: SectionType_1.SectionType.String },
      894: { name: "ChapCountry", type: SectionType_1.SectionType.String },
      10564: { name: "ChapProcess", type: SectionType_1.SectionType.Container },
      10581: { name: "ChapProcessCodecID", type: SectionType_1.SectionType.Uint },
      1293: { name: "ChapProcessPrivate", type: SectionType_1.SectionType.Binary },
      10513: { name: "ChapProcessCommand", type: SectionType_1.SectionType.Container },
      10530: { name: "ChapProcessTime", type: SectionType_1.SectionType.Uint },
      10547: { name: "ChapProcessData", type: SectionType_1.SectionType.Binary },
      39109479: { name: "Tags", type: SectionType_1.SectionType.Container },
      13171: { name: "Tag", type: SectionType_1.SectionType.Container },
      9152: { name: "Targets", type: SectionType_1.SectionType.Container },
      10442: { name: "TargetTypeValue", type: SectionType_1.SectionType.Uint },
      9162: { name: "TargetType", type: SectionType_1.SectionType.String },
      9157: { name: "TagTrackUID", type: SectionType_1.SectionType.Uint },
      9161: { name: "TagEditionUID", type: SectionType_1.SectionType.Uint },
      9156: { name: "TagChapterUID", type: SectionType_1.SectionType.Uint },
      9158: { name: "TagAttachmentUID", type: SectionType_1.SectionType.Uint },
      10184: { name: "SimpleTag", type: SectionType_1.SectionType.Container },
      1443: { name: "TagName", type: SectionType_1.SectionType.String },
      1146: { name: "TagLanguage", type: SectionType_1.SectionType.String },
      1156: { name: "TagDefault", type: SectionType_1.SectionType.Uint },
      1159: { name: "TagString", type: SectionType_1.SectionType.String },
      1157: { name: "TagBinary", type: SectionType_1.SectionType.Binary },
      5552: { name: "Colour", type: SectionType_1.SectionType.Container },
      5553: { name: "MatrixCoefficients", type: SectionType_1.SectionType.Uint },
      5554: { name: "BitsPerChannel", type: SectionType_1.SectionType.Uint },
      5555: { name: "ChromaSubsamplingHorz", type: SectionType_1.SectionType.Uint },
      5556: { name: "ChromaSubsamplingVert", type: SectionType_1.SectionType.Uint },
      5557: { name: "CbSubsamplingHorz", type: SectionType_1.SectionType.Uint },
      5558: { name: "CbSubsamplingVert", type: SectionType_1.SectionType.Uint },
      5559: { name: "ChromaSitingHorz", type: SectionType_1.SectionType.Uint },
      5560: { name: "ChromaSitingVert", type: SectionType_1.SectionType.Uint },
      5561: { name: "Range", type: SectionType_1.SectionType.Uint },
      5562: { name: "TransferCharacteristics", type: SectionType_1.SectionType.Uint },
      5563: { name: "Primaries", type: SectionType_1.SectionType.Uint },
      5564: { name: "MaxCLL", type: SectionType_1.SectionType.Uint },
      5565: { name: "MaxFALL", type: SectionType_1.SectionType.Uint }
    };
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/lib/WebmUint.js
var require_WebmUint = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/lib/WebmUint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebmUint = void 0;
    var WebmBase_1 = require_WebmBase();
    function padHex(hex) {
      return hex.length % 2 === 1 ? "0" + hex : hex;
    }
    var WebmUint = class extends WebmBase_1.WebmBase {
      constructor(name, start = 0) {
        super(name, start);
      }
      getType() {
        return "Uint";
      }
      updateBySource() {
        this.data = "";
        for (let i = 0; i < this.source.length; i++) {
          const hex = this.source[i].toString(16);
          this.data += padHex(hex);
        }
      }
      updateByData() {
        const length = this.data.length / 2;
        this.source = new Uint8Array(length);
        for (let i = 0; i < length; i++) {
          const hex = this.data.substring(i * 2, i * 2 + 2);
          this.source[i] = parseInt(hex, 16);
        }
      }
      getValue() {
        return parseInt(this.data, 16);
      }
      setValue(value) {
        this.setData(padHex(value.toString(16)));
      }
    };
    exports.WebmUint = WebmUint;
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/lib/WebmFloat.js
var require_WebmFloat = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/lib/WebmFloat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebmFloat = void 0;
    var WebmBase_1 = require_WebmBase();
    var WebmFloat = class extends WebmBase_1.WebmBase {
      constructor(name, start = 0) {
        super(name, start);
      }
      getType() {
        return "Float";
      }
      getFloatArrayType() {
        return this.source && this.source.length === 4 ? Float32Array : Float64Array;
      }
      updateBySource() {
        const byteArray = this.source.reverse();
        const floatArrayType = this.getFloatArrayType();
        const floatArray = new floatArrayType(byteArray.buffer);
        this.data = floatArray[0];
      }
      updateByData() {
        const floatArrayType = this.getFloatArrayType();
        const floatArray = new floatArrayType([this.data]);
        const byteArray = new Uint8Array(floatArray.buffer);
        this.source = byteArray.reverse();
      }
    };
    exports.WebmFloat = WebmFloat;
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/lib/WebmString.js
var require_WebmString = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/lib/WebmString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebmString = void 0;
    var WebmBase_1 = require_WebmBase();
    var WebmString = class extends WebmBase_1.WebmBase {
      constructor(name, start = 0) {
        super(name, start);
      }
      getType() {
        return "String";
      }
      updateBySource() {
        this.data = this.source;
      }
      updateByData() {
        this.source = this.data;
      }
      getValue() {
        let result = "";
        this.source.forEach((code) => {
          result += String.fromCharCode(code);
        });
        return result;
      }
    };
    exports.WebmString = WebmString;
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/lib/WebmContainer.js
var require_WebmContainer = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/lib/WebmContainer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebmContainer = void 0;
    var WebmBase_1 = require_WebmBase();
    var sections_1 = require_sections();
    var SectionType_1 = require_SectionType();
    var WebmUint_1 = require_WebmUint();
    var WebmFloat_1 = require_WebmFloat();
    var WebmString_1 = require_WebmString();
    var WebmContainer = class _WebmContainer extends WebmBase_1.WebmBase {
      constructor(name, isInfinite = false, start = 0) {
        super(name, start);
        this.isInfinite = isInfinite;
        this.offset = 0;
      }
      getType() {
        return "Container";
      }
      readByte() {
        return this.source[this.offset++];
      }
      readUint() {
        const firstByte = this.readByte();
        const bytes = 8 - firstByte.toString(2).length;
        let value = firstByte - (1 << 7 - bytes);
        for (let i = 0; i < bytes; i++) {
          value <<= 8;
          value |= this.readByte();
        }
        return value;
      }
      updateBySource() {
        var _a;
        this.data = [];
        let end;
        for (this.offset = 0; this.offset < this.source.length; this.offset = end) {
          const start = this.offset;
          const id = this.readUint();
          const { name, type } = (_a = sections_1.sections[id]) !== null && _a !== void 0 ? _a : {};
          const len = this.readUint();
          end = this.source.length;
          if (len >= 0)
            end = Math.min(this.offset + len, end);
          const data = this.source.slice(this.offset, end);
          let section;
          switch (type) {
            case SectionType_1.SectionType.Container:
              section = new _WebmContainer(name, len < 0, start);
              break;
            case SectionType_1.SectionType.Uint:
              section = new WebmUint_1.WebmUint(name, start);
              break;
            case SectionType_1.SectionType.Float:
              section = new WebmFloat_1.WebmFloat(name, start);
              break;
            case SectionType_1.SectionType.String:
              section = new WebmString_1.WebmString(name, start);
              break;
            default:
              section = new WebmBase_1.WebmBase(name, start);
              break;
          }
          section.setSource(data);
          this.data.push({
            id,
            idHex: id.toString(16),
            data: section
          });
        }
      }
      writeUint(x, draft = false) {
        let bytes;
        for (bytes = 1; (x < 0 || x >= 1 << 7 * bytes) && bytes < 8; bytes++) {
        }
        if (!draft) {
          for (let i = 0; i < bytes; i++) {
            this.source[this.offset + i] = x >> 8 * (bytes - 1 - i) & 255;
          }
          this.source[this.offset] &= (1 << 8 - bytes) - 1;
          this.source[this.offset] |= 1 << 8 - bytes;
        }
        this.offset += bytes;
      }
      writeSections(draft = false) {
        this.offset = 0;
        for (let i = 0; i < this.data.length; i++) {
          const section = this.data[i], content = section.data.source, contentLength = content.length;
          this.writeUint(section.id, draft);
          this.writeUint(section.data instanceof _WebmContainer && section.data.isInfinite ? -1 : contentLength, draft);
          if (!draft) {
            this.source.set(content, this.offset);
          }
          this.offset += contentLength;
        }
        return this.offset;
      }
      updateByData() {
        const length = this.writeSections(true);
        this.source = new Uint8Array(length);
        this.writeSections();
      }
      getSectionById(id) {
        for (let i = 0; i < this.data.length; i++) {
          const section = this.data[i];
          if (section.id === id) {
            return section.data;
          }
        }
        return null;
      }
    };
    exports.WebmContainer = WebmContainer;
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/lib/WebmFile.js
var require_WebmFile = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/lib/WebmFile.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebmFile = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var WebmContainer_1 = require_WebmContainer();
    var WebmFile = class _WebmFile extends WebmContainer_1.WebmContainer {
      constructor(source) {
        super("File");
        this.setSource(source);
      }
      getType() {
        return "File";
      }
      toBlob(mimeType = "video/webm") {
        return new Blob([this.source.buffer], { type: mimeType });
      }
      static blobToArray(blob) {
        return new Promise((resolve, reject) => {
          try {
            const reader = new FileReader();
            reader.onloadend = () => {
              try {
                resolve(new Uint8Array(reader.result));
              } catch (ex) {
                reject(ex);
              }
            };
            reader.readAsArrayBuffer(blob);
          } catch (ex) {
            reject(ex);
          }
        });
      }
      static fromBlob(blob) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const array = yield _WebmFile.blobToArray(blob);
          return new _WebmFile(array);
        });
      }
    };
    exports.WebmFile = WebmFile;
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/lib/Options.js
var require_Options = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/lib/Options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// ../../../node_modules/@fix-webm-duration/parser/src/index.js
var require_src = __commonJS({
  "../../../node_modules/@fix-webm-duration/parser/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_WebmBase(), exports);
    tslib_1.__exportStar(require_WebmContainer(), exports);
    tslib_1.__exportStar(require_WebmFile(), exports);
    tslib_1.__exportStar(require_WebmFloat(), exports);
    tslib_1.__exportStar(require_WebmString(), exports);
    tslib_1.__exportStar(require_WebmUint(), exports);
    tslib_1.__exportStar(require_SectionType(), exports);
    tslib_1.__exportStar(require_Options(), exports);
    tslib_1.__exportStar(require_sections(), exports);
  }
});

// ../../../node_modules/@fix-webm-duration/fix/src/lib/fixParsedWebmDuration.js
var require_fixParsedWebmDuration = __commonJS({
  "../../../node_modules/@fix-webm-duration/fix/src/lib/fixParsedWebmDuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fixParsedWebmDuration = void 0;
    var parser_1 = require_src();
    var fixParsedWebmDuration = (file, duration, options2 = {}) => {
      let logger = options2.logger;
      if (logger === void 0) {
        logger = (message) => console.debug(message);
      } else if (!logger) {
        logger = () => {
        };
      }
      const segmentSection = file.getSectionById(139690087);
      if (!segmentSection) {
        logger("[fix-webm-duration] Segment section is missing");
        return false;
      }
      const infoSection = segmentSection.getSectionById(88713574);
      if (!infoSection) {
        logger("[fix-webm-duration] Info section is missing");
        return false;
      }
      const timeScaleSection = infoSection.getSectionById(710577);
      if (!timeScaleSection) {
        logger("[fix-webm-duration] TimecodeScale section is missing");
        return false;
      }
      let durationSection = infoSection.getSectionById(1161);
      if (durationSection) {
        if (durationSection.getValue() <= 0) {
          logger(`[fix-webm-duration] Duration section is present, but the value is ${durationSection.getValue()}`);
          durationSection.setValue(duration);
        } else {
          logger(`[fix-webm-duration] Duration section is present, and the value is ${durationSection.getValue()}`);
          return false;
        }
      } else {
        logger("[fix-webm-duration] Duration section is missing");
        durationSection = new parser_1.WebmFloat("Duration");
        durationSection.setValue(duration);
        infoSection.data.push({
          id: 1161,
          data: durationSection
        });
      }
      timeScaleSection.setValue(1e6);
      infoSection.updateByData();
      segmentSection.updateByData();
      file.updateByData();
      return true;
    };
    exports.fixParsedWebmDuration = fixParsedWebmDuration;
  }
});

// ../../../node_modules/@fix-webm-duration/fix/src/lib/fixWebmDuration.js
var require_fixWebmDuration = __commonJS({
  "../../../node_modules/@fix-webm-duration/fix/src/lib/fixWebmDuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fixWebmDuration = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var parser_1 = require_src();
    var fixParsedWebmDuration_1 = require_fixParsedWebmDuration();
    var fixWebmDuration2 = (blob, duration, options2) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
      try {
        const file = yield parser_1.WebmFile.fromBlob(blob);
        if ((0, fixParsedWebmDuration_1.fixParsedWebmDuration)(file, duration, options2)) {
          return file.toBlob(blob.type);
        }
      } catch (_a) {
      }
      return blob;
    });
    exports.fixWebmDuration = fixWebmDuration2;
  }
});

// ../../../node_modules/@fix-webm-duration/fix/src/index.js
var require_src2 = __commonJS({
  "../../../node_modules/@fix-webm-duration/fix/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_fixWebmDuration(), exports);
    tslib_1.__exportStar(require_fixParsedWebmDuration(), exports);
  }
});

// ../../../node_modules/component-register/dist/component-register.js
function cloneProps(props7) {
  const propKeys = Object.keys(props7);
  return propKeys.reduce((memo3, k) => {
    const prop = props7[k];
    memo3[k] = Object.assign({}, prop);
    if (isObject(prop.value) && !isFunction(prop.value) && !Array.isArray(prop.value)) memo3[k].value = Object.assign({}, prop.value);
    if (Array.isArray(prop.value)) memo3[k].value = prop.value.slice(0);
    return memo3;
  }, {});
}
function normalizePropDefs(props7) {
  if (!props7) return {};
  const propKeys = Object.keys(props7);
  return propKeys.reduce((memo3, k) => {
    const v = props7[k];
    memo3[k] = !(isObject(v) && "value" in v) ? {
      value: v
    } : v;
    memo3[k].attribute || (memo3[k].attribute = toAttribute(k));
    memo3[k].parse = "parse" in memo3[k] ? memo3[k].parse : typeof memo3[k].value !== "string";
    return memo3;
  }, {});
}
function propValues(props7) {
  const propKeys = Object.keys(props7);
  return propKeys.reduce((memo3, k) => {
    memo3[k] = props7[k].value;
    return memo3;
  }, {});
}
function initializeProps(element, propDefinition) {
  const props7 = cloneProps(propDefinition), propKeys = Object.keys(propDefinition);
  propKeys.forEach((key) => {
    const prop = props7[key], attr = element.getAttribute(prop.attribute), value = element[key];
    if (attr != null) prop.value = prop.parse ? parseAttributeValue(attr) : attr;
    if (value != null) prop.value = Array.isArray(value) ? value.slice(0) : value;
    prop.reflect && reflect(element, prop.attribute, prop.value, !!prop.parse);
    Object.defineProperty(element, key, {
      get() {
        return prop.value;
      },
      set(val) {
        const oldValue = prop.value;
        prop.value = val;
        prop.reflect && reflect(this, prop.attribute, prop.value, !!prop.parse);
        for (let i = 0, l = this.__propertyChangedCallbacks.length; i < l; i++) {
          this.__propertyChangedCallbacks[i](key, val, oldValue);
        }
      },
      enumerable: true,
      configurable: true
    });
  });
  return props7;
}
function parseAttributeValue(value) {
  if (!value) return;
  try {
    return JSON.parse(value);
  } catch (err) {
    return value;
  }
}
function reflect(node, attribute, value, parse) {
  if (value == null || value === false) return node.removeAttribute(attribute);
  let reflect2 = parse ? JSON.stringify(value) : value;
  node.__updating[attribute] = true;
  if (reflect2 === "true") reflect2 = "";
  node.setAttribute(attribute, reflect2);
  Promise.resolve().then(() => delete node.__updating[attribute]);
}
function toAttribute(propName) {
  return propName.replace(/\.?([A-Z]+)/g, (x, y) => "-" + y.toLowerCase()).replace("_", "-").replace(/^-/, "");
}
function isObject(obj) {
  return obj != null && (typeof obj === "object" || typeof obj === "function");
}
function isFunction(val) {
  return Object.prototype.toString.call(val) === "[object Function]";
}
function isConstructor(f) {
  return typeof f === "function" && f.toString().indexOf("class") === 0;
}
var currentElement;
function createElementType(BaseElement, propDefinition) {
  const propKeys = Object.keys(propDefinition);
  return class CustomElement extends BaseElement {
    static get observedAttributes() {
      return propKeys.map((k) => propDefinition[k].attribute);
    }
    constructor() {
      super();
      this.__initialized = false;
      this.__released = false;
      this.__releaseCallbacks = [];
      this.__propertyChangedCallbacks = [];
      this.__updating = {};
      this.props = {};
    }
    connectedCallback() {
      if (this.__initialized) return;
      this.__releaseCallbacks = [];
      this.__propertyChangedCallbacks = [];
      this.__updating = {};
      this.props = initializeProps(this, propDefinition);
      const props7 = propValues(this.props), ComponentType = this.Component, outerElement = currentElement;
      try {
        currentElement = this;
        this.__initialized = true;
        if (isConstructor(ComponentType)) new ComponentType(props7, {
          element: this
        });
        else ComponentType(props7, {
          element: this
        });
      } finally {
        currentElement = outerElement;
      }
    }
    async disconnectedCallback() {
      await Promise.resolve();
      if (this.isConnected) return;
      this.__propertyChangedCallbacks.length = 0;
      let callback = null;
      while (callback = this.__releaseCallbacks.pop()) callback(this);
      delete this.__initialized;
      this.__released = true;
    }
    attributeChangedCallback(name, oldVal, newVal) {
      if (!this.__initialized) return;
      if (this.__updating[name]) return;
      name = this.lookupProp(name);
      if (name in propDefinition) {
        if (newVal == null && !this[name]) return;
        this[name] = propDefinition[name].parse ? parseAttributeValue(newVal) : newVal;
      }
    }
    lookupProp(attrName) {
      if (!propDefinition) return;
      return propKeys.find((k) => attrName === k || attrName === propDefinition[k].attribute);
    }
    get renderRoot() {
      return this.shadowRoot || this.attachShadow({
        mode: "open"
      });
    }
    addReleaseCallback(fn) {
      this.__releaseCallbacks.push(fn);
    }
    addPropertyChangedCallback(fn) {
      this.__propertyChangedCallbacks.push(fn);
    }
  };
}
var EC = Symbol("element-context");
function register(tag, props7 = {}, options2 = {}) {
  const {
    BaseElement = HTMLElement,
    extension,
    customElements = window.customElements
  } = options2;
  return (ComponentType) => {
    if (!tag) throw new Error("tag is required to register a Component");
    let ElementType = customElements.get(tag);
    if (ElementType) {
      ElementType.prototype.Component = ComponentType;
      return ElementType;
    }
    ElementType = createElementType(BaseElement, normalizePropDefs(props7));
    ElementType.prototype.Component = ComponentType;
    ElementType.prototype.registeredTag = tag;
    customElements.define(tag, ElementType, extension);
    return ElementType;
  };
}

// ../../../node_modules/solid-js/dist/solid.js
var sharedConfig = {
  context: void 0,
  registry: void 0,
  effects: void 0,
  done: false,
  getContextId() {
    return getContextId(this.context.count);
  },
  getNextContextId() {
    return getContextId(this.context.count++);
  }
};
function getContextId(count) {
  const num = String(count), len = num.length - 1;
  return sharedConfig.context.id + (len ? String.fromCharCode(96 + len) : "") + num;
}
function setHydrateContext(context) {
  sharedConfig.context = context;
}
function nextHydrateContext() {
  return {
    ...sharedConfig.context,
    id: sharedConfig.getNextContextId(),
    count: 0
  };
}
var IS_DEV = false;
var equalFn = (a, b) => a === b;
var $PROXY = Symbol("solid-proxy");
var SUPPORTS_PROXY = typeof Proxy === "function";
var $TRACK = Symbol("solid-track");
var $DEVCOMP = Symbol("solid-dev-component");
var signalOptions = {
  equals: equalFn
};
var ERROR = null;
var runEffects = runQueue;
var STALE = 1;
var PENDING = 2;
var UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Owner = null;
var Transition = null;
var Scheduler = null;
var ExternalSourceConfig = null;
var Listener = null;
var Updates = null;
var Effects = null;
var ExecCount = 0;
function createRoot(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, current = detachedOwner === void 0 ? owner : detachedOwner, root = unowned ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: current ? current.context : null,
    owner: current
  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value, options2) {
  options2 = options2 ? Object.assign({}, signalOptions, options2) : signalOptions;
  const s = {
    value,
    observers: null,
    observerSlots: null,
    comparator: options2.equals || void 0
  };
  const setter = (value2) => {
    if (typeof value2 === "function") {
      if (Transition && Transition.running && Transition.sources.has(s)) value2 = value2(s.tValue);
      else value2 = value2(s.value);
    }
    return writeSignal(s, value2);
  };
  return [readSignal.bind(s), setter];
}
function createRenderEffect(fn, value, options2) {
  const c = createComputation(fn, value, false, STALE);
  if (Scheduler && Transition && Transition.running) Updates.push(c);
  else updateComputation(c);
}
function createEffect(fn, value, options2) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value, false, STALE), s = SuspenseContext && useContext(SuspenseContext);
  if (s) c.suspense = s;
  if (!options2 || !options2.render) c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createMemo(fn, value, options2) {
  options2 = options2 ? Object.assign({}, signalOptions, options2) : signalOptions;
  const c = createComputation(fn, value, true, 0);
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options2.equals || void 0;
  if (Scheduler && Transition && Transition.running) {
    c.tState = STALE;
    Updates.push(c);
  } else updateComputation(c);
  return readSignal.bind(c);
}
function untrack(fn) {
  if (!ExternalSourceConfig && Listener === null) return fn();
  const listener = Listener;
  Listener = null;
  try {
    if (ExternalSourceConfig) return ExternalSourceConfig.untrack(fn);
    return fn();
  } finally {
    Listener = listener;
  }
}
function on(deps, fn, options2) {
  const isArray2 = Array.isArray(deps);
  let prevInput;
  let defer = options2 && options2.defer;
  return (prevValue) => {
    let input;
    if (isArray2) {
      input = Array(deps.length);
      for (let i = 0; i < deps.length; i++) input[i] = deps[i]();
    } else input = deps();
    if (defer) {
      defer = false;
      return prevValue;
    }
    const result = untrack(() => fn(input, prevInput, prevValue));
    prevInput = input;
    return result;
  };
}
function onMount(fn) {
  createEffect(() => untrack(fn));
}
function onCleanup(fn) {
  if (Owner === null) ;
  else if (Owner.cleanups === null) Owner.cleanups = [fn];
  else Owner.cleanups.push(fn);
  return fn;
}
function getOwner() {
  return Owner;
}
function runWithOwner(o, fn) {
  const prev = Owner;
  const prevListener = Listener;
  Owner = o;
  Listener = null;
  try {
    return runUpdates(fn, true);
  } catch (err) {
    handleError(err);
  } finally {
    Owner = prev;
    Listener = prevListener;
  }
}
function startTransition(fn) {
  if (Transition && Transition.running) {
    fn();
    return Transition.done;
  }
  const l = Listener;
  const o = Owner;
  return Promise.resolve().then(() => {
    Listener = l;
    Owner = o;
    let t;
    if (Scheduler || SuspenseContext) {
      t = Transition || (Transition = {
        sources: /* @__PURE__ */ new Set(),
        effects: [],
        promises: /* @__PURE__ */ new Set(),
        disposed: /* @__PURE__ */ new Set(),
        queue: /* @__PURE__ */ new Set(),
        running: true
      });
      t.done || (t.done = new Promise((res) => t.resolve = res));
      t.running = true;
    }
    runUpdates(fn, false);
    Listener = Owner = null;
    return t ? t.done : void 0;
  });
}
var [transPending, setTransPending] = /* @__PURE__ */ createSignal(false);
function createContext(defaultValue, options2) {
  const id = Symbol("context");
  return {
    id,
    Provider: createProvider(id),
    defaultValue
  };
}
function useContext(context) {
  let value;
  return Owner && Owner.context && (value = Owner.context[context.id]) !== void 0 ? value : context.defaultValue;
}
function children(fn) {
  const children2 = createMemo(fn);
  const memo3 = createMemo(() => resolveChildren(children2()));
  memo3.toArray = () => {
    const c = memo3();
    return Array.isArray(c) ? c : c != null ? [c] : [];
  };
  return memo3;
}
var SuspenseContext;
function readSignal() {
  const runningTransition = Transition && Transition.running;
  if (this.sources && (runningTransition ? this.tState : this.state)) {
    if ((runningTransition ? this.tState : this.state) === STALE) updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  if (runningTransition && Transition.sources.has(this)) return this.tValue;
  return this.value;
}
function writeSignal(node, value, isComp) {
  let current = Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value;
  if (!node.comparator || !node.comparator(current, value)) {
    if (Transition) {
      const TransitionRunning = Transition.running;
      if (TransitionRunning || !isComp && Transition.sources.has(node)) {
        Transition.sources.add(node);
        node.tValue = value;
      }
      if (!TransitionRunning) node.value = value;
    } else node.value = value;
    if (node.observers && node.observers.length) {
      runUpdates(() => {
        for (let i = 0; i < node.observers.length; i += 1) {
          const o = node.observers[i];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o)) continue;
          if (TransitionRunning ? !o.tState : !o.state) {
            if (o.pure) Updates.push(o);
            else Effects.push(o);
            if (o.observers) markDownstream(o);
          }
          if (!TransitionRunning) o.state = STALE;
          else o.tState = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (IS_DEV) ;
          throw new Error();
        }
      }, false);
    }
  }
  return value;
}
function updateComputation(node) {
  if (!node.fn) return;
  cleanNode(node);
  const time = ExecCount;
  runComputation(
    node,
    Transition && Transition.running && Transition.sources.has(node) ? node.tValue : node.value,
    time
  );
  if (Transition && !Transition.running && Transition.sources.has(node)) {
    queueMicrotask(() => {
      runUpdates(() => {
        Transition && (Transition.running = true);
        Listener = Owner = node;
        runComputation(node, node.tValue, time);
        Listener = Owner = null;
      }, false);
    });
  }
}
function runComputation(node, value, time) {
  let nextValue;
  const owner = Owner, listener = Listener;
  Listener = Owner = node;
  try {
    nextValue = node.fn(value);
  } catch (err) {
    if (node.pure) {
      if (Transition && Transition.running) {
        node.tState = STALE;
        node.tOwned && node.tOwned.forEach(cleanNode);
        node.tOwned = void 0;
      } else {
        node.state = STALE;
        node.owned && node.owned.forEach(cleanNode);
        node.owned = null;
      }
    }
    node.updatedAt = time + 1;
    return handleError(err);
  } finally {
    Listener = listener;
    Owner = owner;
  }
  if (!node.updatedAt || node.updatedAt <= time) {
    if (node.updatedAt != null && "observers" in node) {
      writeSignal(node, nextValue, true);
    } else if (Transition && Transition.running && node.pure) {
      Transition.sources.add(node);
      node.tValue = nextValue;
    } else node.value = nextValue;
    node.updatedAt = time;
  }
}
function createComputation(fn, init, pure, state2 = STALE, options2) {
  const c = {
    fn,
    state: state2,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: Owner ? Owner.context : null,
    pure
  };
  if (Transition && Transition.running) {
    c.state = 0;
    c.tState = state2;
  }
  if (Owner === null) ;
  else if (Owner !== UNOWNED) {
    if (Transition && Transition.running && Owner.pure) {
      if (!Owner.tOwned) Owner.tOwned = [c];
      else Owner.tOwned.push(c);
    } else {
      if (!Owner.owned) Owner.owned = [c];
      else Owner.owned.push(c);
    }
  }
  if (ExternalSourceConfig && c.fn) {
    const [track, trigger] = createSignal(void 0, {
      equals: false
    });
    const ordinary = ExternalSourceConfig.factory(c.fn, trigger);
    onCleanup(() => ordinary.dispose());
    const triggerInTransition = () => startTransition(trigger).then(() => inTransition.dispose());
    const inTransition = ExternalSourceConfig.factory(c.fn, triggerInTransition);
    c.fn = (x) => {
      track();
      return Transition && Transition.running ? inTransition.track(x) : ordinary.track(x);
    };
  }
  return c;
}
function runTop(node) {
  const runningTransition = Transition && Transition.running;
  if ((runningTransition ? node.tState : node.state) === 0) return;
  if ((runningTransition ? node.tState : node.state) === PENDING) return lookUpstream(node);
  if (node.suspense && untrack(node.suspense.inFallback)) return node.suspense.effects.push(node);
  const ancestors = [node];
  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {
    if (runningTransition && Transition.disposed.has(node)) return;
    if (runningTransition ? node.tState : node.state) ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    node = ancestors[i];
    if (runningTransition) {
      let top = node, prev = ancestors[i + 1];
      while ((top = top.owner) && top !== prev) {
        if (Transition.disposed.has(top)) return;
      }
    }
    if ((runningTransition ? node.tState : node.state) === STALE) {
      updateComputation(node);
    } else if ((runningTransition ? node.tState : node.state) === PENDING) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates) return fn();
  let wait = false;
  if (!init) Updates = [];
  if (Effects) wait = true;
  else Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait) Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    if (Scheduler && Transition && Transition.running) scheduleQueue(Updates);
    else runQueue(Updates);
    Updates = null;
  }
  if (wait) return;
  let res;
  if (Transition) {
    if (!Transition.promises.size && !Transition.queue.size) {
      const sources = Transition.sources;
      const disposed = Transition.disposed;
      Effects.push.apply(Effects, Transition.effects);
      res = Transition.resolve;
      for (const e2 of Effects) {
        "tState" in e2 && (e2.state = e2.tState);
        delete e2.tState;
      }
      Transition = null;
      runUpdates(() => {
        for (const d of disposed) cleanNode(d);
        for (const v of sources) {
          v.value = v.tValue;
          if (v.owned) {
            for (let i = 0, len = v.owned.length; i < len; i++) cleanNode(v.owned[i]);
          }
          if (v.tOwned) v.owned = v.tOwned;
          delete v.tValue;
          delete v.tOwned;
          v.tState = 0;
        }
        setTransPending(false);
      }, false);
    } else if (Transition.running) {
      Transition.running = false;
      Transition.effects.push.apply(Transition.effects, Effects);
      Effects = null;
      setTransPending(true);
      return;
    }
  }
  const e = Effects;
  Effects = null;
  if (e.length) runUpdates(() => runEffects(e), false);
  if (res) res();
}
function runQueue(queue) {
  for (let i = 0; i < queue.length; i++) runTop(queue[i]);
}
function scheduleQueue(queue) {
  for (let i = 0; i < queue.length; i++) {
    const item = queue[i];
    const tasks = Transition.queue;
    if (!tasks.has(item)) {
      tasks.add(item);
      Scheduler(() => {
        tasks.delete(item);
        runUpdates(() => {
          Transition.running = true;
          runTop(item);
        }, false);
        Transition && (Transition.running = false);
      });
    }
  }
}
function runUserEffects(queue) {
  let i, userLength = 0;
  for (i = 0; i < queue.length; i++) {
    const e = queue[i];
    if (!e.user) runTop(e);
    else queue[userLength++] = e;
  }
  if (sharedConfig.context) {
    if (sharedConfig.count) {
      sharedConfig.effects || (sharedConfig.effects = []);
      sharedConfig.effects.push(...queue.slice(0, userLength));
      return;
    }
    setHydrateContext();
  }
  if (sharedConfig.effects && (sharedConfig.done || !sharedConfig.count)) {
    queue = [...sharedConfig.effects, ...queue];
    userLength += sharedConfig.effects.length;
    delete sharedConfig.effects;
  }
  for (i = 0; i < userLength; i++) runTop(queue[i]);
}
function lookUpstream(node, ignore) {
  const runningTransition = Transition && Transition.running;
  if (runningTransition) node.tState = 0;
  else node.state = 0;
  for (let i = 0; i < node.sources.length; i += 1) {
    const source = node.sources[i];
    if (source.sources) {
      const state2 = runningTransition ? source.tState : source.state;
      if (state2 === STALE) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
          runTop(source);
      } else if (state2 === PENDING) lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node) {
  const runningTransition = Transition && Transition.running;
  for (let i = 0; i < node.observers.length; i += 1) {
    const o = node.observers[i];
    if (runningTransition ? !o.tState : !o.state) {
      if (runningTransition) o.tState = PENDING;
      else o.state = PENDING;
      if (o.pure) Updates.push(o);
      else Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node) {
  let i;
  if (node.sources) {
    while (node.sources.length) {
      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (node.tOwned) {
    for (i = node.tOwned.length - 1; i >= 0; i--) cleanNode(node.tOwned[i]);
    delete node.tOwned;
  }
  if (Transition && Transition.running && node.pure) {
    reset(node, true);
  } else if (node.owned) {
    for (i = node.owned.length - 1; i >= 0; i--) cleanNode(node.owned[i]);
    node.owned = null;
  }
  if (node.cleanups) {
    for (i = node.cleanups.length - 1; i >= 0; i--) node.cleanups[i]();
    node.cleanups = null;
  }
  if (Transition && Transition.running) node.tState = 0;
  else node.state = 0;
}
function reset(node, top) {
  if (!top) {
    node.tState = 0;
    Transition.disposed.add(node);
  }
  if (node.owned) {
    for (let i = 0; i < node.owned.length; i++) reset(node.owned[i]);
  }
}
function castError(err) {
  if (err instanceof Error) return err;
  return new Error(typeof err === "string" ? err : "Unknown error", {
    cause: err
  });
}
function runErrors(err, fns, owner) {
  try {
    for (const f of fns) f(err);
  } catch (e) {
    handleError(e, owner && owner.owner || null);
  }
}
function handleError(err, owner = Owner) {
  const fns = ERROR && owner && owner.context && owner.context[ERROR];
  const error = castError(err);
  if (!fns) throw error;
  if (Effects)
    Effects.push({
      fn() {
        runErrors(error, fns, owner);
      },
      state: STALE
    });
  else runErrors(error, fns, owner);
}
function resolveChildren(children2) {
  if (typeof children2 === "function" && !children2.length) return resolveChildren(children2());
  if (Array.isArray(children2)) {
    const results = [];
    for (let i = 0; i < children2.length; i++) {
      const result = resolveChildren(children2[i]);
      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return children2;
}
function createProvider(id, options2) {
  return function provider(props7) {
    let res;
    createRenderEffect(
      () => res = untrack(() => {
        Owner.context = {
          ...Owner.context,
          [id]: props7.value
        };
        return children(() => props7.children);
      }),
      void 0
    );
    return res;
  };
}
var FALLBACK = Symbol("fallback");
function dispose(d) {
  for (let i = 0; i < d.length; i++) d[i]();
}
function mapArray(list, mapFn, options2 = {}) {
  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list() || [], newLen = newItems.length, i, j;
    newItems[$TRACK];
    return untrack(() => {
      let newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options2.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options2.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j = 0; j < newLen; j++) {
          items[j] = newItems[j];
          mapped[j] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++) ;
        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {
          temp[newEnd] = mapped[end];
          tempdisposers[newEnd] = disposers[end];
          indexes && (tempIndexes[newEnd] = indexes[end]);
        }
        newIndices = /* @__PURE__ */ new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j = newEnd; j >= start; j--) {
          item = newItems[j];
          i = newIndices.get(item);
          newIndicesNext[j] = i === void 0 ? -1 : i;
          newIndices.set(item, j);
        }
        for (i = start; i <= end; i++) {
          item = items[i];
          j = newIndices.get(item);
          if (j !== void 0 && j !== -1) {
            temp[j] = mapped[i];
            tempdisposers[j] = disposers[i];
            indexes && (tempIndexes[j] = indexes[i]);
            j = newIndicesNext[j];
            newIndices.set(item, j);
          } else disposers[i]();
        }
        for (j = start; j < newLen; j++) {
          if (j in temp) {
            mapped[j] = temp[j];
            disposers[j] = tempdisposers[j];
            if (indexes) {
              indexes[j] = tempIndexes[j];
              indexes[j](j);
            }
          } else mapped[j] = createRoot(mapper);
        }
        mapped = mapped.slice(0, len = newLen);
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j] = disposer;
      if (indexes) {
        const [s, set2] = createSignal(j);
        indexes[j] = set2;
        return mapFn(newItems[j], s);
      }
      return mapFn(newItems[j]);
    }
  };
}
function indexArray(list, mapFn, options2 = {}) {
  let items = [], mapped = [], disposers = [], signals = [], len = 0, i;
  onCleanup(() => dispose(disposers));
  return () => {
    const newItems = list() || [], newLen = newItems.length;
    newItems[$TRACK];
    return untrack(() => {
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          signals = [];
        }
        if (options2.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options2.fallback();
          });
          len = 1;
        }
        return mapped;
      }
      if (items[0] === FALLBACK) {
        disposers[0]();
        disposers = [];
        items = [];
        mapped = [];
        len = 0;
      }
      for (i = 0; i < newLen; i++) {
        if (i < items.length && items[i] !== newItems[i]) {
          signals[i](() => newItems[i]);
        } else if (i >= items.length) {
          mapped[i] = createRoot(mapper);
        }
      }
      for (; i < items.length; i++) {
        disposers[i]();
      }
      len = signals.length = disposers.length = newLen;
      items = newItems.slice(0);
      return mapped = mapped.slice(0, len);
    });
    function mapper(disposer) {
      disposers[i] = disposer;
      const [s, set2] = createSignal(newItems[i]);
      signals[i] = set2;
      return mapFn(s, i);
    }
  };
}
var hydrationEnabled = false;
function createComponent(Comp, props7) {
  if (hydrationEnabled) {
    if (sharedConfig.context) {
      const c = sharedConfig.context;
      setHydrateContext(nextHydrateContext());
      const r2 = untrack(() => Comp(props7 || {}));
      setHydrateContext(c);
      return r2;
    }
  }
  return untrack(() => Comp(props7 || {}));
}
function trueFn() {
  return true;
}
var propTraps = {
  get(_, property, receiver) {
    if (property === $PROXY) return receiver;
    return _.get(property);
  },
  has(_, property) {
    if (property === $PROXY) return true;
    return _.has(property);
  },
  set: trueFn,
  deleteProperty: trueFn,
  getOwnPropertyDescriptor(_, property) {
    return {
      configurable: true,
      enumerable: true,
      get() {
        return _.get(property);
      },
      set: trueFn,
      deleteProperty: trueFn
    };
  },
  ownKeys(_) {
    return _.keys();
  }
};
function resolveSource(s) {
  return !(s = typeof s === "function" ? s() : s) ? {} : s;
}
function resolveSources() {
  for (let i = 0, length = this.length; i < length; ++i) {
    const v = this[i]();
    if (v !== void 0) return v;
  }
}
function mergeProps(...sources) {
  let proxy = false;
  for (let i = 0; i < sources.length; i++) {
    const s = sources[i];
    proxy = proxy || !!s && $PROXY in s;
    sources[i] = typeof s === "function" ? (proxy = true, createMemo(s)) : s;
  }
  if (SUPPORTS_PROXY && proxy) {
    return new Proxy(
      {
        get(property) {
          for (let i = sources.length - 1; i >= 0; i--) {
            const v = resolveSource(sources[i])[property];
            if (v !== void 0) return v;
          }
        },
        has(property) {
          for (let i = sources.length - 1; i >= 0; i--) {
            if (property in resolveSource(sources[i])) return true;
          }
          return false;
        },
        keys() {
          const keys = [];
          for (let i = 0; i < sources.length; i++)
            keys.push(...Object.keys(resolveSource(sources[i])));
          return [...new Set(keys)];
        }
      },
      propTraps
    );
  }
  const sourcesMap = {};
  const defined = /* @__PURE__ */ Object.create(null);
  for (let i = sources.length - 1; i >= 0; i--) {
    const source = sources[i];
    if (!source) continue;
    const sourceKeys = Object.getOwnPropertyNames(source);
    for (let i2 = sourceKeys.length - 1; i2 >= 0; i2--) {
      const key = sourceKeys[i2];
      if (key === "__proto__" || key === "constructor") continue;
      const desc = Object.getOwnPropertyDescriptor(source, key);
      if (!defined[key]) {
        defined[key] = desc.get ? {
          enumerable: true,
          configurable: true,
          get: resolveSources.bind(sourcesMap[key] = [desc.get.bind(source)])
        } : desc.value !== void 0 ? desc : void 0;
      } else {
        const sources2 = sourcesMap[key];
        if (sources2) {
          if (desc.get) sources2.push(desc.get.bind(source));
          else if (desc.value !== void 0) sources2.push(() => desc.value);
        }
      }
    }
  }
  const target = {};
  const definedKeys = Object.keys(defined);
  for (let i = definedKeys.length - 1; i >= 0; i--) {
    const key = definedKeys[i], desc = defined[key];
    if (desc && desc.get) Object.defineProperty(target, key, desc);
    else target[key] = desc ? desc.value : void 0;
  }
  return target;
}
function splitProps(props7, ...keys) {
  if (SUPPORTS_PROXY && $PROXY in props7) {
    const blocked = new Set(keys.length > 1 ? keys.flat() : keys[0]);
    const res = keys.map((k) => {
      return new Proxy(
        {
          get(property) {
            return k.includes(property) ? props7[property] : void 0;
          },
          has(property) {
            return k.includes(property) && property in props7;
          },
          keys() {
            return k.filter((property) => property in props7);
          }
        },
        propTraps
      );
    });
    res.push(
      new Proxy(
        {
          get(property) {
            return blocked.has(property) ? void 0 : props7[property];
          },
          has(property) {
            return blocked.has(property) ? false : property in props7;
          },
          keys() {
            return Object.keys(props7).filter((k) => !blocked.has(k));
          }
        },
        propTraps
      )
    );
    return res;
  }
  const otherObject = {};
  const objects = keys.map(() => ({}));
  for (const propName of Object.getOwnPropertyNames(props7)) {
    const desc = Object.getOwnPropertyDescriptor(props7, propName);
    const isDefaultDesc = !desc.get && !desc.set && desc.enumerable && desc.writable && desc.configurable;
    let blocked = false;
    let objectIndex = 0;
    for (const k of keys) {
      if (k.includes(propName)) {
        blocked = true;
        isDefaultDesc ? objects[objectIndex][propName] = desc.value : Object.defineProperty(objects[objectIndex], propName, desc);
      }
      ++objectIndex;
    }
    if (!blocked) {
      isDefaultDesc ? otherObject[propName] = desc.value : Object.defineProperty(otherObject, propName, desc);
    }
  }
  return [...objects, otherObject];
}
var counter = 0;
function createUniqueId() {
  const ctx = sharedConfig.context;
  return ctx ? sharedConfig.getNextContextId() : `cl-${counter++}`;
}
var narrowedError = (name) => `Stale read from <${name}>.`;
function For(props7) {
  const fallback = "fallback" in props7 && {
    fallback: () => props7.fallback
  };
  return createMemo(mapArray(() => props7.each, props7.children, fallback || void 0));
}
function Index(props7) {
  const fallback = "fallback" in props7 && {
    fallback: () => props7.fallback
  };
  return createMemo(indexArray(() => props7.each, props7.children, fallback || void 0));
}
function Show(props7) {
  const keyed = props7.keyed;
  const conditionValue = createMemo(() => props7.when, void 0, void 0);
  const condition = keyed ? conditionValue : createMemo(conditionValue, void 0, {
    equals: (a, b) => !a === !b
  });
  return createMemo(
    () => {
      const c = condition();
      if (c) {
        const child = props7.children;
        const fn = typeof child === "function" && child.length > 0;
        return fn ? untrack(
          () => child(
            keyed ? c : () => {
              if (!untrack(condition)) throw narrowedError("Show");
              return conditionValue();
            }
          )
        ) : child;
      }
      return props7.fallback;
    },
    void 0,
    void 0
  );
}
function Switch(props7) {
  const chs = children(() => props7.children);
  const switchFunc = createMemo(() => {
    const ch = chs();
    const mps = Array.isArray(ch) ? ch : [ch];
    let func = () => void 0;
    for (let i = 0; i < mps.length; i++) {
      const index = i;
      const mp = mps[i];
      const prevFunc = func;
      const conditionValue = createMemo(
        () => prevFunc() ? void 0 : mp.when,
        void 0,
        void 0
      );
      const condition = mp.keyed ? conditionValue : createMemo(conditionValue, void 0, {
        equals: (a, b) => !a === !b
      });
      func = () => prevFunc() || (condition() ? [index, conditionValue, mp] : void 0);
    }
    return func;
  });
  return createMemo(
    () => {
      const sel = switchFunc()();
      if (!sel) return props7.fallback;
      const [index, conditionValue, mp] = sel;
      const child = mp.children;
      const fn = typeof child === "function" && child.length > 0;
      return fn ? untrack(
        () => child(
          mp.keyed ? conditionValue() : () => {
            if (untrack(switchFunc)()?.[0] !== index) throw narrowedError("Match");
            return conditionValue();
          }
        )
      ) : child;
    },
    void 0,
    void 0
  );
}
function Match(props7) {
  return props7;
}

// ../../../node_modules/solid-js/web/dist/web.js
var booleans = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected"
];
var Properties = /* @__PURE__ */ new Set([
  "className",
  "value",
  "readOnly",
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  ...booleans
]);
var ChildProperties = /* @__PURE__ */ new Set([
  "innerHTML",
  "textContent",
  "innerText",
  "children"
]);
var Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
});
var PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  formnovalidate: {
    $: "formNoValidate",
    BUTTON: 1,
    INPUT: 1
  },
  ismap: {
    $: "isMap",
    IMG: 1
  },
  nomodule: {
    $: "noModule",
    SCRIPT: 1
  },
  playsinline: {
    $: "playsInline",
    VIDEO: 1
  },
  readonly: {
    $: "readOnly",
    INPUT: 1,
    TEXTAREA: 1
  }
});
function getPropAlias(prop, tagName) {
  const a = PropAliases[prop];
  return typeof a === "object" ? a[tagName] ? a["$"] : void 0 : a;
}
var DelegatedEvents = /* @__PURE__ */ new Set([
  "beforeinput",
  "click",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
]);
var SVGElements = /* @__PURE__ */ new Set([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "use",
  "view",
  "vkern"
]);
var SVGNamespace = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(parentNode, a, b) {
  let bLength = b.length, aEnd = a.length, bEnd = bLength, aStart = 0, bStart = 0, after = a[aEnd - 1].nextSibling, map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
      while (bStart < bEnd) parentNode.insertBefore(b[bStart++], node);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart])) a[aStart].remove();
        aStart++;
      }
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node = a[--aEnd].nextSibling;
      parentNode.insertBefore(b[bStart++], a[aStart++].nextSibling);
      parentNode.insertBefore(b[--bEnd], node);
      a[aEnd] = b[bEnd];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i = bStart;
        while (i < bEnd) map.set(b[i], i++);
      }
      const index = map.get(a[aStart]);
      if (index != null) {
        if (bStart < index && index < bEnd) {
          let i = aStart, sequence = 1, t;
          while (++i < aEnd && i < bEnd) {
            if ((t = map.get(a[i])) == null || t !== index + sequence) break;
            sequence++;
          }
          if (sequence > index - bStart) {
            const node = a[aStart];
            while (bStart < index) parentNode.insertBefore(b[bStart++], node);
          } else parentNode.replaceChild(b[bStart++], a[aStart++]);
        } else aStart++;
      } else a[aStart++].remove();
    }
  }
}
var $$EVENTS = "_$DX_DELEGATE";
function template(html2, isImportNode, isSVG, isMathML) {
  let node;
  const create2 = () => {
    const t = isMathML ? document.createElementNS("http://www.w3.org/1998/Math/MathML", "template") : document.createElement("template");
    t.innerHTML = html2;
    return isSVG ? t.content.firstChild.firstChild : isMathML ? t.firstChild : t.content.firstChild;
  };
  const fn = isImportNode ? () => untrack(() => document.importNode(node || (node = create2()), true)) : () => (node || (node = create2())).cloneNode(true);
  fn.cloneNode = fn;
  return fn;
}
function delegateEvents(eventNames, document2 = window.document) {
  const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
  for (let i = 0, l = eventNames.length; i < l; i++) {
    const name = eventNames[i];
    if (!e.has(name)) {
      e.add(name);
      document2.addEventListener(name, eventHandler);
    }
  }
}
function setAttribute(node, name, value) {
  if (isHydrating(node)) return;
  if (value == null) node.removeAttribute(name);
  else node.setAttribute(name, value);
}
function setAttributeNS(node, namespace, name, value) {
  if (isHydrating(node)) return;
  if (value == null) node.removeAttributeNS(namespace, name);
  else node.setAttributeNS(namespace, name, value);
}
function setBoolAttribute(node, name, value) {
  if (isHydrating(node)) return;
  value ? node.setAttribute(name, "") : node.removeAttribute(name);
}
function className(node, value) {
  if (isHydrating(node)) return;
  if (value == null) node.removeAttribute("class");
  else node.className = value;
}
function addEventListener(node, name, handler, delegate) {
  if (delegate) {
    if (Array.isArray(handler)) {
      node[`$$${name}`] = handler[0];
      node[`$$${name}Data`] = handler[1];
    } else node[`$$${name}`] = handler;
  } else if (Array.isArray(handler)) {
    const handlerFn = handler[0];
    node.addEventListener(name, handler[0] = (e) => handlerFn.call(node, handler[1], e));
  } else node.addEventListener(name, handler, typeof handler !== "function" && handler);
}
function classList(node, value, prev = {}) {
  const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);
  let i, len;
  for (i = 0, len = prevKeys.length; i < len; i++) {
    const key = prevKeys[i];
    if (!key || key === "undefined" || value[key]) continue;
    toggleClassKey(node, key, false);
    delete prev[key];
  }
  for (i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i], classValue = !!value[key];
    if (!key || key === "undefined" || prev[key] === classValue || !classValue) continue;
    toggleClassKey(node, key, true);
    prev[key] = classValue;
  }
  return prev;
}
function style(node, value, prev) {
  if (!value) return prev ? setAttribute(node, "style") : value;
  const nodeStyle = node.style;
  if (typeof value === "string") return nodeStyle.cssText = value;
  typeof prev === "string" && (nodeStyle.cssText = prev = void 0);
  prev || (prev = {});
  value || (value = {});
  let v, s;
  for (s in prev) {
    value[s] == null && nodeStyle.removeProperty(s);
    delete prev[s];
  }
  for (s in value) {
    v = value[s];
    if (v !== prev[s]) {
      nodeStyle.setProperty(s, v);
      prev[s] = v;
    }
  }
  return prev;
}
function spread(node, props7 = {}, isSVG, skipChildren) {
  const prevProps = {};
  if (!skipChildren) {
    createRenderEffect(
      () => prevProps.children = insertExpression(node, props7.children, prevProps.children)
    );
  }
  createRenderEffect(() => typeof props7.ref === "function" && use(props7.ref, node));
  createRenderEffect(() => assign(node, props7, isSVG, true, prevProps, true));
  return prevProps;
}
function use(fn, element, arg) {
  return untrack(() => fn(element, arg));
}
function insert(parent2, accessor, marker, initial) {
  if (marker !== void 0 && !initial) initial = [];
  if (typeof accessor !== "function") return insertExpression(parent2, accessor, initial, marker);
  createRenderEffect((current) => insertExpression(parent2, accessor(), current, marker), initial);
}
function assign(node, props7, isSVG, skipChildren, prevProps = {}, skipRef = false) {
  props7 || (props7 = {});
  for (const prop in prevProps) {
    if (!(prop in props7)) {
      if (prop === "children") continue;
      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef, props7);
    }
  }
  for (const prop in props7) {
    if (prop === "children") {
      if (!skipChildren) insertExpression(node, props7.children);
      continue;
    }
    const value = props7[prop];
    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef, props7);
  }
}
function getNextElement(template2) {
  let node, key, hydrating = isHydrating();
  if (!hydrating || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {
    return template2();
  }
  if (sharedConfig.completed) sharedConfig.completed.add(node);
  sharedConfig.registry.delete(key);
  return node;
}
function isHydrating(node) {
  return !!sharedConfig.context && !sharedConfig.done && (!node || node.isConnected);
}
function toPropertyName(name) {
  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}
function toggleClassKey(node, key, value) {
  const classNames = key.trim().split(/\s+/);
  for (let i = 0, nameLen = classNames.length; i < nameLen; i++)
    node.classList.toggle(classNames[i], value);
}
function assignProp(node, prop, value, prev, isSVG, skipRef, props7) {
  let isCE, isProp, isChildProp, propAlias, forceProp;
  if (prop === "style") return style(node, value, prev);
  if (prop === "classList") return classList(node, value, prev);
  if (value === prev) return prev;
  if (prop === "ref") {
    if (!skipRef) value(node);
  } else if (prop.slice(0, 3) === "on:") {
    const e = prop.slice(3);
    prev && node.removeEventListener(e, prev, typeof prev !== "function" && prev);
    value && node.addEventListener(e, value, typeof value !== "function" && value);
  } else if (prop.slice(0, 10) === "oncapture:") {
    const e = prop.slice(10);
    prev && node.removeEventListener(e, prev, true);
    value && node.addEventListener(e, value, true);
  } else if (prop.slice(0, 2) === "on") {
    const name = prop.slice(2).toLowerCase();
    const delegate = DelegatedEvents.has(name);
    if (!delegate && prev) {
      const h = Array.isArray(prev) ? prev[0] : prev;
      node.removeEventListener(name, h);
    }
    if (delegate || value) {
      addEventListener(node, name, value, delegate);
      delegate && delegateEvents([name]);
    }
  } else if (prop.slice(0, 5) === "attr:") {
    setAttribute(node, prop.slice(5), value);
  } else if (prop.slice(0, 5) === "bool:") {
    setBoolAttribute(node, prop.slice(5), value);
  } else if ((forceProp = prop.slice(0, 5) === "prop:") || (isChildProp = ChildProperties.has(prop)) || !isSVG && ((propAlias = getPropAlias(prop, node.tagName)) || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes("-") || "is" in props7)) {
    if (forceProp) {
      prop = prop.slice(5);
      isProp = true;
    } else if (isHydrating(node)) return value;
    if (prop === "class" || prop === "className") className(node, value);
    else if (isCE && !isProp && !isChildProp) node[toPropertyName(prop)] = value;
    else node[propAlias || prop] = value;
  } else {
    const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
    if (ns) setAttributeNS(node, ns, prop, value);
    else setAttribute(node, Aliases[prop] || prop, value);
  }
  return value;
}
function eventHandler(e) {
  if (sharedConfig.registry && sharedConfig.events) {
    if (sharedConfig.events.find(([el, ev]) => ev === e)) return;
  }
  let node = e.target;
  const key = `$$${e.type}`;
  const oriTarget = e.target;
  const oriCurrentTarget = e.currentTarget;
  const retarget = (value) => Object.defineProperty(e, "target", {
    configurable: true,
    value
  });
  const handleNode = () => {
    const handler = node[key];
    if (handler && !node.disabled) {
      const data = node[`${key}Data`];
      data !== void 0 ? handler.call(node, data, e) : handler.call(node, e);
      if (e.cancelBubble) return;
    }
    node.host && typeof node.host !== "string" && !node.host._$host && node.contains(e.target) && retarget(node.host);
    return true;
  };
  const walkUpTree = () => {
    while (handleNode() && (node = node._$host || node.parentNode || node.host)) ;
  };
  Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  if (sharedConfig.registry && !sharedConfig.done) sharedConfig.done = _$HY.done = true;
  if (e.composedPath) {
    const path = e.composedPath();
    retarget(path[0]);
    for (let i = 0; i < path.length - 2; i++) {
      node = path[i];
      if (!handleNode()) break;
      if (node._$host) {
        node = node._$host;
        walkUpTree();
        break;
      }
      if (node.parentNode === oriCurrentTarget) {
        break;
      }
    }
  } else walkUpTree();
  retarget(oriTarget);
}
function insertExpression(parent2, value, current, marker, unwrapArray) {
  const hydrating = isHydrating(parent2);
  if (hydrating) {
    !current && (current = [...parent2.childNodes]);
    let cleaned = [];
    for (let i = 0; i < current.length; i++) {
      const node = current[i];
      if (node.nodeType === 8 && node.data.slice(0, 2) === "!$") node.remove();
      else cleaned.push(node);
    }
    current = cleaned;
  }
  while (typeof current === "function") current = current();
  if (value === current) return current;
  const t = typeof value, multi = marker !== void 0;
  parent2 = multi && current[0] && current[0].parentNode || parent2;
  if (t === "string" || t === "number") {
    if (hydrating) return current;
    if (t === "number") {
      value = value.toString();
      if (value === current) return current;
    }
    if (multi) {
      let node = current[0];
      if (node && node.nodeType === 3) {
        node.data !== value && (node.data = value);
      } else node = document.createTextNode(value);
      current = cleanChildren(parent2, current, marker, node);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent2.firstChild.data = value;
      } else current = parent2.textContent = value;
    }
  } else if (value == null || t === "boolean") {
    if (hydrating) return current;
    current = cleanChildren(parent2, current, marker);
  } else if (t === "function") {
    createRenderEffect(() => {
      let v = value();
      while (typeof v === "function") v = v();
      current = insertExpression(parent2, v, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value)) {
    const array = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array, value, current, unwrapArray)) {
      createRenderEffect(() => current = insertExpression(parent2, array, current, marker, true));
      return () => current;
    }
    if (hydrating) {
      if (!array.length) return current;
      if (marker === void 0) return current = [...parent2.childNodes];
      let node = array[0];
      if (node.parentNode !== parent2) return current;
      const nodes = [node];
      while ((node = node.nextSibling) !== marker) nodes.push(node);
      return current = nodes;
    }
    if (array.length === 0) {
      current = cleanChildren(parent2, current, marker);
      if (multi) return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent2, array, marker);
      } else reconcileArrays(parent2, current, array);
    } else {
      current && cleanChildren(parent2);
      appendNodes(parent2, array);
    }
    current = array;
  } else if (value.nodeType) {
    if (hydrating && value.parentNode) return current = multi ? [value] : value;
    if (Array.isArray(current)) {
      if (multi) return current = cleanChildren(parent2, current, marker, value);
      cleanChildren(parent2, current, null, value);
    } else if (current == null || current === "" || !parent2.firstChild) {
      parent2.appendChild(value);
    } else parent2.replaceChild(value, parent2.firstChild);
    current = value;
  } else ;
  return current;
}
function normalizeIncomingArray(normalized, array, current, unwrap2) {
  let dynamic = false;
  for (let i = 0, len = array.length; i < len; i++) {
    let item = array[i], prev = current && current[normalized.length], t;
    if (item == null || item === true || item === false) ;
    else if ((t = typeof item) === "object" && item.nodeType) {
      normalized.push(item);
    } else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;
    } else if (t === "function") {
      if (unwrap2) {
        while (typeof item === "function") item = item();
        dynamic = normalizeIncomingArray(
          normalized,
          Array.isArray(item) ? item : [item],
          Array.isArray(prev) ? prev : [prev]
        ) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value = String(item);
      if (prev && prev.nodeType === 3 && prev.data === value) normalized.push(prev);
      else normalized.push(document.createTextNode(value));
    }
  }
  return dynamic;
}
function appendNodes(parent2, array, marker = null) {
  for (let i = 0, len = array.length; i < len; i++) parent2.insertBefore(array[i], marker);
}
function cleanChildren(parent2, current, marker, replacement) {
  if (marker === void 0) return parent2.textContent = "";
  const node = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i = current.length - 1; i >= 0; i--) {
      const el = current[i];
      if (node !== el) {
        const isParent = el.parentNode === parent2;
        if (!inserted && !i)
          isParent ? parent2.replaceChild(node, el) : parent2.insertBefore(node, marker);
        else isParent && el.remove();
      } else inserted = true;
    }
  } else parent2.insertBefore(node, marker);
  return [node];
}
function getHydrationKey() {
  return sharedConfig.getNextContextId();
}
var RequestContext = Symbol();
var isServer = false;
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
function createElement(tagName, isSVG = false) {
  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);
}
function Portal(props7) {
  const { useShadow } = props7, marker = document.createTextNode(""), mount = () => props7.mount || document.body, owner = getOwner();
  let content;
  let hydrating = !!sharedConfig.context;
  createEffect(
    () => {
      if (hydrating) getOwner().user = hydrating = false;
      content || (content = runWithOwner(owner, () => createMemo(() => props7.children)));
      const el = mount();
      if (el instanceof HTMLHeadElement) {
        const [clean, setClean] = createSignal(false);
        const cleanup = () => setClean(true);
        createRoot((dispose3) => insert(el, () => !clean() ? content() : dispose3(), null));
        onCleanup(cleanup);
      } else {
        const container = createElement(props7.isSVG ? "g" : "div", props7.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({
          mode: "open"
        }) : container;
        Object.defineProperty(container, "_$host", {
          get() {
            return marker.parentNode;
          },
          configurable: true
        });
        insert(renderRoot, content);
        el.appendChild(container);
        props7.ref && props7.ref(container);
        onCleanup(() => el.removeChild(container));
      }
    },
    void 0,
    {
      render: !hydrating
    }
  );
  return marker;
}
function createDynamic(component, props7) {
  const cached = createMemo(component);
  return createMemo(() => {
    const component2 = cached();
    switch (typeof component2) {
      case "function":
        return untrack(() => component2(props7));
      case "string":
        const isSvg = SVGElements.has(component2);
        const el = sharedConfig.context ? getNextElement() : createElement(component2, isSvg);
        spread(el, props7, isSvg);
        return el;
    }
  });
}
function Dynamic(props7) {
  const [, others] = splitProps(props7, ["component"]);
  return createDynamic(() => props7.component, others);
}

// ../../../node_modules/solid-element/dist/index.js
function createProps(raw) {
  const keys = Object.keys(raw);
  const props7 = {};
  for (let i = 0; i < keys.length; i++) {
    const [get, set2] = createSignal(raw[keys[i]]);
    Object.defineProperty(props7, keys[i], {
      get,
      set(v) {
        set2(() => v);
      }
    });
  }
  return props7;
}
function lookupContext(el) {
  if (el.assignedSlot && el.assignedSlot._$owner) return el.assignedSlot._$owner;
  let next = el.parentNode;
  while (next && !next._$owner && !(next.assignedSlot && next.assignedSlot._$owner))
    next = next.parentNode;
  return next && next.assignedSlot ? next.assignedSlot._$owner : el._$owner;
}
function withSolid(ComponentType) {
  return (rawProps, options2) => {
    const { element } = options2;
    return createRoot((dispose3) => {
      const props7 = createProps(rawProps);
      element.addPropertyChangedCallback((key, val) => props7[key] = val);
      element.addReleaseCallback(() => {
        element.renderRoot.textContent = "";
        dispose3();
      });
      const comp = ComponentType(props7, options2);
      return insert(element.renderRoot, comp);
    }, lookupContext(element));
  };
}
function customElement(tag, props7, ComponentType) {
  if (arguments.length === 2) {
    ComponentType = props7;
    props7 = {};
  }
  return register(tag, props7)(withSolid(ComponentType));
}

// src/constants.ts
var defaultBotProps = {
  id: void 0,
  typebot: void 0,
  onNewInputBlock: void 0,
  onAnswer: void 0,
  onEnd: void 0,
  onInit: void 0,
  onNewLogs: void 0,
  onChatStatePersisted: void 0,
  onScriptExecutionSuccess: void 0,
  font: void 0,
  progressBarRef: void 0,
  isPreview: void 0,
  startFrom: void 0,
  prefilledVariables: void 0,
  apiHost: void 0,
  wsHost: void 0,
  resultId: void 0,
  sessionId: void 0
};
var defaultPopupProps = {
  ...defaultBotProps,
  onClose: void 0,
  onOpen: void 0,
  theme: void 0,
  autoShowDelay: void 0,
  isOpen: void 0,
  defaultOpen: void 0
};
var defaultBubbleProps = {
  ...defaultBotProps,
  onClose: void 0,
  onOpen: void 0,
  theme: void 0,
  previewMessage: void 0,
  onPreviewMessageClick: void 0,
  onPreviewMessageDismissed: void 0,
  autoShowDelay: void 0,
  inlineStyle: void 0
};

// src/features/blocks/inputs/payment/helpers/paymentInProgressStorage.ts
var setPaymentInProgressInStorage = (state2) => {
  sessionStorage.setItem("typebotPaymentInProgress", JSON.stringify(state2));
};
var getPaymentInProgressInStorage = () => sessionStorage.getItem("typebotPaymentInProgress");
var removePaymentInProgressFromStorage = () => {
  sessionStorage.removeItem("typebotPaymentInProgress");
};

// ../../env/src/getRuntimeVariable.ts
var getRuntimeVariable = (key, defaultValue) => {
  if (typeof window !== "undefined")
    return window.__ENV ? window.__ENV[key] ?? defaultValue : void 0;
  if (typeof process === "undefined") return void 0;
  return process.env[key] ?? defaultValue;
};

// src/utils/guessApiHost.ts
var chatApiCloudFallbackHost = "https://typebot.io";
var guessApiHost = ({ ignoreChatApiUrl } = { ignoreChatApiUrl: false }) => {
  const chatApiUrl = getRuntimeVariable("NEXT_PUBLIC_CHAT_API_URL");
  const newChatApiOnUrls = getRuntimeVariable("NEXT_PUBLIC_USE_EXPERIMENTAL_CHAT_API_ON")?.split(",");
  if (!ignoreChatApiUrl && chatApiUrl && (!newChatApiOnUrls || newChatApiOnUrls.some((url) => url === window.location.href))) {
    return chatApiUrl;
  }
  const viewerUrls = getRuntimeVariable("NEXT_PUBLIC_VIEWER_URL")?.split(",");
  const matchedUrl = viewerUrls?.find(
    (url) => window.location.href.startsWith(url)
  );
  return matchedUrl ?? viewerUrls?.[0] ?? chatApiCloudFallbackHost;
};

// ../../lib/src/utils.ts
var sendRequest = async (params) => {
  let response;
  try {
    const url = typeof params === "string" ? params : params.url;
    response = await fetch(url, {
      method: typeof params === "string" ? "GET" : params.method,
      mode: "cors",
      headers: typeof params !== "string" && isDefined(params.body) ? {
        "Content-Type": "application/json"
      } : void 0,
      body: typeof params !== "string" && isDefined(params.body) ? JSON.stringify(params.body) : void 0
    });
    const data = await response.json();
    if (!response.ok) throw "error" in data ? data.error : data;
    return { data, response };
  } catch (e) {
    console.error(e);
    return { error: e, response };
  }
};
var isDefined = (value) => value !== void 0 && value !== null;
var isNotDefined = (value) => value === void 0 || value === null;
var isEmpty = (value) => value === void 0 || value === null || value === "";
var isNotEmpty = (value) => value !== void 0 && value !== null && value !== "";
var injectCustomHeadCode = (customHeadCode) => {
  const headCodes = customHeadCode.split("</noscript>");
  headCodes.forEach((headCode) => {
    const [codeToInject, noScriptContentToInject] = headCode.split("<noscript>");
    const fragment = document.createRange().createContextualFragment(codeToInject ?? "");
    document.head.append(fragment);
    if (isNotDefined(noScriptContentToInject)) return;
    const noScriptElement = document.createElement("noscript");
    const noScriptContentFragment = document.createRange().createContextualFragment(noScriptContentToInject);
    noScriptElement.append(noScriptContentFragment);
    document.head.append(noScriptElement);
  });
};
var isSvgSrc = (src) => src?.startsWith("data:image/svg") || src?.endsWith(".svg");

// ../../../node_modules/ky/distribution/errors/HTTPError.js
var HTTPError = class extends Error {
  constructor(response, request, options2) {
    const code = response.status || response.status === 0 ? response.status : "";
    const title = response.statusText || "";
    const status = `${code} ${title}`.trim();
    const reason = status ? `status code ${status}` : "an unknown error";
    super(`Request failed with ${reason}`);
    Object.defineProperty(this, "response", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "request", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "HTTPError";
    this.response = response;
    this.request = request;
    this.options = options2;
  }
};

// ../../../node_modules/ky/distribution/errors/TimeoutError.js
var TimeoutError = class extends Error {
  constructor(request) {
    super("Request timed out");
    Object.defineProperty(this, "request", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.name = "TimeoutError";
    this.request = request;
  }
};

// ../../../node_modules/ky/distribution/utils/is.js
var isObject2 = (value) => value !== null && typeof value === "object";

// ../../../node_modules/ky/distribution/utils/merge.js
var validateAndMerge = (...sources) => {
  for (const source of sources) {
    if ((!isObject2(source) || Array.isArray(source)) && source !== void 0) {
      throw new TypeError("The `options` argument must be an object");
    }
  }
  return deepMerge({}, ...sources);
};
var mergeHeaders = (source1 = {}, source2 = {}) => {
  const result = new globalThis.Headers(source1);
  const isHeadersInstance = source2 instanceof globalThis.Headers;
  const source = new globalThis.Headers(source2);
  for (const [key, value] of source.entries()) {
    if (isHeadersInstance && value === "undefined" || value === void 0) {
      result.delete(key);
    } else {
      result.set(key, value);
    }
  }
  return result;
};
var deepMerge = (...sources) => {
  let returnValue = {};
  let headers = {};
  for (const source of sources) {
    if (Array.isArray(source)) {
      if (!Array.isArray(returnValue)) {
        returnValue = [];
      }
      returnValue = [...returnValue, ...source];
    } else if (isObject2(source)) {
      for (let [key, value] of Object.entries(source)) {
        if (isObject2(value) && key in returnValue) {
          value = deepMerge(returnValue[key], value);
        }
        returnValue = { ...returnValue, [key]: value };
      }
      if (isObject2(source.headers)) {
        headers = mergeHeaders(headers, source.headers);
        returnValue.headers = headers;
      }
    }
  }
  return returnValue;
};

// ../../../node_modules/ky/distribution/core/constants.js
var supportsRequestStreams = (() => {
  let duplexAccessed = false;
  let hasContentType = false;
  const supportsReadableStream = typeof globalThis.ReadableStream === "function";
  const supportsRequest = typeof globalThis.Request === "function";
  if (supportsReadableStream && supportsRequest) {
    hasContentType = new globalThis.Request("https://empty.invalid", {
      body: new globalThis.ReadableStream(),
      method: "POST",
      // @ts-expect-error - Types are outdated.
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
  }
  return duplexAccessed && !hasContentType;
})();
var supportsAbortController = typeof globalThis.AbortController === "function";
var supportsResponseStreams = typeof globalThis.ReadableStream === "function";
var supportsFormData = typeof globalThis.FormData === "function";
var requestMethods = ["get", "post", "put", "patch", "head", "delete"];
var validate = () => void 0;
validate();
var responseTypes = {
  json: "application/json",
  text: "text/*",
  formData: "multipart/form-data",
  arrayBuffer: "*/*",
  blob: "*/*"
};
var maxSafeTimeout = 2147483647;
var stop = Symbol("stop");
var kyOptionKeys = {
  json: true,
  parseJson: true,
  searchParams: true,
  prefixUrl: true,
  retry: true,
  timeout: true,
  hooks: true,
  throwHttpErrors: true,
  onDownloadProgress: true,
  fetch: true
};
var requestOptionsRegistry = {
  method: true,
  headers: true,
  body: true,
  mode: true,
  credentials: true,
  cache: true,
  redirect: true,
  referrer: true,
  referrerPolicy: true,
  integrity: true,
  keepalive: true,
  signal: true,
  window: true,
  dispatcher: true,
  duplex: true,
  priority: true
};

// ../../../node_modules/ky/distribution/utils/normalize.js
var normalizeRequestMethod = (input) => requestMethods.includes(input) ? input.toUpperCase() : input;
var retryMethods = ["get", "put", "head", "delete", "options", "trace"];
var retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
var retryAfterStatusCodes = [413, 429, 503];
var defaultRetryOptions = {
  limit: 2,
  methods: retryMethods,
  statusCodes: retryStatusCodes,
  afterStatusCodes: retryAfterStatusCodes,
  maxRetryAfter: Number.POSITIVE_INFINITY,
  backoffLimit: Number.POSITIVE_INFINITY,
  delay: (attemptCount) => 0.3 * 2 ** (attemptCount - 1) * 1e3
};
var normalizeRetryOptions = (retry = {}) => {
  if (typeof retry === "number") {
    return {
      ...defaultRetryOptions,
      limit: retry
    };
  }
  if (retry.methods && !Array.isArray(retry.methods)) {
    throw new Error("retry.methods must be an array");
  }
  if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
    throw new Error("retry.statusCodes must be an array");
  }
  return {
    ...defaultRetryOptions,
    ...retry,
    afterStatusCodes: retryAfterStatusCodes
  };
};

// ../../../node_modules/ky/distribution/utils/timeout.js
async function timeout(request, init, abortController2, options2) {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      if (abortController2) {
        abortController2.abort();
      }
      reject(new TimeoutError(request));
    }, options2.timeout);
    void options2.fetch(request, init).then(resolve).catch(reject).then(() => {
      clearTimeout(timeoutId);
    });
  });
}

// ../../../node_modules/ky/distribution/utils/delay.js
async function delay(ms, { signal }) {
  return new Promise((resolve, reject) => {
    if (signal) {
      signal.throwIfAborted();
      signal.addEventListener("abort", abortHandler, { once: true });
    }
    function abortHandler() {
      clearTimeout(timeoutId);
      reject(signal.reason);
    }
    const timeoutId = setTimeout(() => {
      signal?.removeEventListener("abort", abortHandler);
      resolve();
    }, ms);
  });
}

// ../../../node_modules/ky/distribution/utils/options.js
var findUnknownOptions = (request, options2) => {
  const unknownOptions = {};
  for (const key in options2) {
    if (!(key in requestOptionsRegistry) && !(key in kyOptionKeys) && !(key in request)) {
      unknownOptions[key] = options2[key];
    }
  }
  return unknownOptions;
};

// ../../../node_modules/ky/distribution/core/Ky.js
var Ky = class _Ky {
  static create(input, options2) {
    const ky2 = new _Ky(input, options2);
    const function_ = async () => {
      if (typeof ky2._options.timeout === "number" && ky2._options.timeout > maxSafeTimeout) {
        throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
      }
      await Promise.resolve();
      let response = await ky2._fetch();
      for (const hook of ky2._options.hooks.afterResponse) {
        const modifiedResponse = await hook(ky2.request, ky2._options, ky2._decorateResponse(response.clone()));
        if (modifiedResponse instanceof globalThis.Response) {
          response = modifiedResponse;
        }
      }
      ky2._decorateResponse(response);
      if (!response.ok && ky2._options.throwHttpErrors) {
        let error = new HTTPError(response, ky2.request, ky2._options);
        for (const hook of ky2._options.hooks.beforeError) {
          error = await hook(error);
        }
        throw error;
      }
      if (ky2._options.onDownloadProgress) {
        if (typeof ky2._options.onDownloadProgress !== "function") {
          throw new TypeError("The `onDownloadProgress` option must be a function");
        }
        if (!supportsResponseStreams) {
          throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
        }
        return ky2._stream(response.clone(), ky2._options.onDownloadProgress);
      }
      return response;
    };
    const isRetriableMethod = ky2._options.retry.methods.includes(ky2.request.method.toLowerCase());
    const result = isRetriableMethod ? ky2._retry(function_) : function_();
    for (const [type, mimeType] of Object.entries(responseTypes)) {
      result[type] = async () => {
        ky2.request.headers.set("accept", ky2.request.headers.get("accept") || mimeType);
        const awaitedResult = await result;
        const response = awaitedResult.clone();
        if (type === "json") {
          if (response.status === 204) {
            return "";
          }
          const arrayBuffer = await response.clone().arrayBuffer();
          const responseSize = arrayBuffer.byteLength;
          if (responseSize === 0) {
            return "";
          }
          if (options2.parseJson) {
            return options2.parseJson(await response.text());
          }
        }
        return response[type]();
      };
    }
    return result;
  }
  // eslint-disable-next-line complexity
  constructor(input, options2 = {}) {
    Object.defineProperty(this, "request", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "abortController", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_retryCount", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "_input", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "_options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this._input = input;
    const credentials = this._input instanceof Request && "credentials" in Request.prototype ? this._input.credentials : void 0;
    this._options = {
      ...credentials && { credentials },
      // For exactOptionalPropertyTypes
      ...options2,
      headers: mergeHeaders(this._input.headers, options2.headers),
      hooks: deepMerge({
        beforeRequest: [],
        beforeRetry: [],
        beforeError: [],
        afterResponse: []
      }, options2.hooks),
      method: normalizeRequestMethod(options2.method ?? this._input.method),
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      prefixUrl: String(options2.prefixUrl || ""),
      retry: normalizeRetryOptions(options2.retry),
      throwHttpErrors: options2.throwHttpErrors !== false,
      timeout: options2.timeout ?? 1e4,
      fetch: options2.fetch ?? globalThis.fetch.bind(globalThis)
    };
    if (typeof this._input !== "string" && !(this._input instanceof URL || this._input instanceof globalThis.Request)) {
      throw new TypeError("`input` must be a string, URL, or Request");
    }
    if (this._options.prefixUrl && typeof this._input === "string") {
      if (this._input.startsWith("/")) {
        throw new Error("`input` must not begin with a slash when using `prefixUrl`");
      }
      if (!this._options.prefixUrl.endsWith("/")) {
        this._options.prefixUrl += "/";
      }
      this._input = this._options.prefixUrl + this._input;
    }
    if (supportsAbortController) {
      this.abortController = new globalThis.AbortController();
      if (this._options.signal) {
        const originalSignal = this._options.signal;
        this._options.signal.addEventListener("abort", () => {
          this.abortController.abort(originalSignal.reason);
        });
      }
      this._options.signal = this.abortController.signal;
    }
    if (supportsRequestStreams) {
      this._options.duplex = "half";
    }
    this.request = new globalThis.Request(this._input, this._options);
    if (this._options.searchParams) {
      const textSearchParams = typeof this._options.searchParams === "string" ? this._options.searchParams.replace(/^\?/, "") : new URLSearchParams(this._options.searchParams).toString();
      const searchParams = "?" + textSearchParams;
      const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
      if ((supportsFormData && this._options.body instanceof globalThis.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers["content-type"])) {
        this.request.headers.delete("content-type");
      }
      this.request = new globalThis.Request(new globalThis.Request(url, { ...this.request }), this._options);
    }
    if (this._options.json !== void 0) {
      this._options.body = JSON.stringify(this._options.json);
      this.request.headers.set("content-type", this._options.headers.get("content-type") ?? "application/json");
      this.request = new globalThis.Request(this.request, { body: this._options.body });
    }
  }
  _calculateRetryDelay(error) {
    this._retryCount++;
    if (this._retryCount <= this._options.retry.limit && !(error instanceof TimeoutError)) {
      if (error instanceof HTTPError) {
        if (!this._options.retry.statusCodes.includes(error.response.status)) {
          return 0;
        }
        const retryAfter = error.response.headers.get("Retry-After");
        if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
          let after = Number(retryAfter);
          if (Number.isNaN(after)) {
            after = Date.parse(retryAfter) - Date.now();
          } else {
            after *= 1e3;
          }
          if (this._options.retry.maxRetryAfter !== void 0 && after > this._options.retry.maxRetryAfter) {
            return 0;
          }
          return after;
        }
        if (error.response.status === 413) {
          return 0;
        }
      }
      const retryDelay = this._options.retry.delay(this._retryCount);
      return Math.min(this._options.retry.backoffLimit, retryDelay);
    }
    return 0;
  }
  _decorateResponse(response) {
    if (this._options.parseJson) {
      response.json = async () => this._options.parseJson(await response.text());
    }
    return response;
  }
  async _retry(function_) {
    try {
      return await function_();
    } catch (error) {
      const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
      if (ms !== 0 && this._retryCount > 0) {
        await delay(ms, { signal: this._options.signal });
        for (const hook of this._options.hooks.beforeRetry) {
          const hookResult = await hook({
            request: this.request,
            options: this._options,
            error,
            retryCount: this._retryCount
          });
          if (hookResult === stop) {
            return;
          }
        }
        return this._retry(function_);
      }
      throw error;
    }
  }
  async _fetch() {
    for (const hook of this._options.hooks.beforeRequest) {
      const result = await hook(this.request, this._options);
      if (result instanceof Request) {
        this.request = result;
        break;
      }
      if (result instanceof Response) {
        return result;
      }
    }
    const nonRequestOptions = findUnknownOptions(this.request, this._options);
    if (this._options.timeout === false) {
      return this._options.fetch(this.request.clone(), nonRequestOptions);
    }
    return timeout(this.request.clone(), nonRequestOptions, this.abortController, this._options);
  }
  /* istanbul ignore next */
  _stream(response, onDownloadProgress) {
    const totalBytes = Number(response.headers.get("content-length")) || 0;
    let transferredBytes = 0;
    if (response.status === 204) {
      if (onDownloadProgress) {
        onDownloadProgress({ percent: 1, totalBytes, transferredBytes }, new Uint8Array());
      }
      return new globalThis.Response(null, {
        status: response.status,
        statusText: response.statusText,
        headers: response.headers
      });
    }
    return new globalThis.Response(new globalThis.ReadableStream({
      async start(controller) {
        const reader = response.body.getReader();
        if (onDownloadProgress) {
          onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
        }
        async function read() {
          const { done, value } = await reader.read();
          if (done) {
            controller.close();
            return;
          }
          if (onDownloadProgress) {
            transferredBytes += value.byteLength;
            const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
            onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
          }
          controller.enqueue(value);
          await read();
        }
        await read();
      }
    }), {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
  }
};

// ../../../node_modules/ky/distribution/index.js
var createInstance = (defaults) => {
  const ky2 = (input, options2) => Ky.create(input, validateAndMerge(defaults, options2));
  for (const method of requestMethods) {
    ky2[method] = (input, options2) => Ky.create(input, validateAndMerge(defaults, options2, { method }));
  }
  ky2.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
  ky2.extend = (newDefaults) => createInstance(validateAndMerge(defaults, newDefaults));
  ky2.stop = stop;
  return ky2;
};
var ky = createInstance();
var distribution_default = ky;

// src/queries/startChatQuery.ts
async function startChatQuery({
  typebot: typebot2,
  isPreview,
  apiHost,
  prefilledVariables,
  resultId,
  stripeRedirectStatus,
  startFrom,
  sessionId
}) {
  if (isNotDefined(typebot2))
    throw new Error("Typebot ID is required to get initial messages");
  const paymentInProgressStateStr = getPaymentInProgressInStorage() ?? void 0;
  const paymentInProgressState = paymentInProgressStateStr ? JSON.parse(paymentInProgressStateStr) : void 0;
  if (paymentInProgressState) {
    return resumeChatAfterPaymentRedirect({
      apiHost,
      stripeRedirectStatus,
      paymentInProgressState
    });
  }
  const typebotId = typeof typebot2 === "string" ? typebot2 : typebot2.id;
  if (isPreview) {
    return startPreviewChat({
      apiHost,
      typebotId,
      startFrom,
      typebot: typebot2,
      prefilledVariables,
      sessionId
    });
  }
  try {
    const iframeReferrerOrigin = parent !== window && isNotEmpty(document.referrer) ? new URL(document.referrer).origin : void 0;
    const response = await distribution_default.post(
      `${getApiHost(apiHost)}/api/v1/typebots/${typebotId}/startChat`,
      {
        headers: {
          "x-typebot-iframe-referrer-origin": iframeReferrerOrigin
        },
        json: {
          isStreamEnabled: true,
          prefilledVariables,
          resultId,
          isOnlyRegistering: false
        },
        timeout: false
      }
    );
    return { data: await response.json() };
  } catch (error) {
    return { error };
  }
}
var resumeChatAfterPaymentRedirect = async ({
  apiHost,
  stripeRedirectStatus,
  paymentInProgressState
}) => {
  removePaymentInProgressFromStorage();
  try {
    const data = await distribution_default.post(
      `${getApiHost(apiHost)}/api/v1/sessions/${paymentInProgressState.sessionId}/continueChat`,
      {
        json: {
          message: stripeRedirectStatus === "failed" ? "fail" : "Success"
        },
        timeout: false
      }
    ).json();
    return {
      data: {
        ...data,
        ...paymentInProgressState
      }
    };
  } catch (error) {
    return { error };
  }
};
var startPreviewChat = async ({
  apiHost,
  typebotId,
  startFrom,
  typebot: typebot2,
  prefilledVariables,
  sessionId
}) => {
  try {
    const data = await distribution_default.post(
      `${getApiHost(apiHost)}/api/v1/typebots/${typebotId}/preview/startChat`,
      {
        json: {
          isStreamEnabled: true,
          startFrom,
          typebot: typebot2,
          prefilledVariables,
          sessionId
        },
        timeout: false
      }
    ).json();
    return { data };
  } catch (error) {
    return { error };
  }
};
var getApiHost = (apiHost) => isNotEmpty(apiHost) ? apiHost : guessApiHost();

// src/utils/CorsError.ts
var CorsError = class extends Error {
  constructor(origin) {
    super("This bot can only be executed on " + origin);
  }
};

// src/utils/botContainerHeightSignal.ts
var [botContainerHeight, setBotContainerHeight] = createSignal("100%");

// src/utils/botContainerSignal.ts
var [botContainer, setBotContainer] = createSignal();

// src/utils/dynamicTheme.ts
var mergeThemes = (initialTheme, dynamicTheme) => ({
  ...initialTheme,
  general: initialTheme.general ? {
    ...initialTheme.general,
    background: initialTheme.general.background ? {
      ...initialTheme.general.background,
      content: dynamicTheme?.backgroundUrl ?? initialTheme.general.background?.content
    } : void 0
  } : void 0,
  chat: {
    ...initialTheme.chat,
    hostAvatar: initialTheme.chat?.hostAvatar && dynamicTheme?.hostAvatarUrl ? {
      ...initialTheme.chat.hostAvatar,
      url: dynamicTheme.hostAvatarUrl
    } : initialTheme.chat?.hostAvatar,
    guestAvatar: initialTheme.chat?.guestAvatar && dynamicTheme?.guestAvatarUrl ? {
      ...initialTheme.chat.guestAvatar,
      url: dynamicTheme?.guestAvatarUrl
    } : initialTheme.chat?.guestAvatar
  }
});

// ../../ui/src/colors.ts
var colors = {
  blue: {
    light: {
      1: "#fcfdfe",
      2: "#f6f9ff",
      3: "#ebf2ff",
      4: "#ddeaff",
      5: "#ccdfff",
      6: "#b7d2ff",
      7: "#a0bfff",
      8: "#7fa5fd",
      9: "#3566fc",
      10: "#2f5be1",
      11: "#2c57dd",
      12: "#172c65"
    },
    dark: {
      1: "#070d1a",
      2: "#0f1627",
      3: "#12234e",
      4: "#162c6a",
      5: "#1d377e",
      6: "#25428f",
      7: "#2e4ea4",
      8: "#365bc1",
      9: "#3566fc",
      10: "#2a57ec",
      11: "#8db4ff",
      12: "#d1e2ff"
    }
  },
  orange: {
    light: {
      1: "#fefcfb",
      2: "#fff4f0",
      3: "#ffe8de",
      4: "#ffd6c7",
      5: "#ffc8b5",
      6: "#ffb8a0",
      7: "#ffa286",
      8: "#f98868",
      9: "#ff5924",
      10: "#f24905",
      11: "#dc3b00",
      12: "#5b2a1c"
    },
    dark: {
      1: "#120b09",
      2: "#1f1411",
      3: "#371810",
      4: "#4e1606",
      5: "#5e1e0b",
      6: "#6e2c18",
      7: "#873c26",
      8: "#ad4d31",
      9: "#ff5924",
      10: "#f14b0f",
      11: "#ff9776",
      12: "#ffd7ca"
    }
  },
  purple: {
    light: {
      1: "#fcfcff",
      2: "#f9f8ff",
      3: "#f2f0ff",
      4: "#e7e4ff",
      5: "#ddd8ff",
      6: "#d0c9ff",
      7: "#bdb3ff",
      8: "#a595ff",
      9: "#8055fd",
      10: "#7447ec",
      11: "#6841d3",
      12: "#321e6c"
    },
    dark: {
      1: "#0d0a1b",
      2: "#17132a",
      3: "#261b4f",
      4: "#321d6c",
      5: "#3b257c",
      6: "#46318b",
      7: "#543ea2",
      8: "#684cc7",
      9: "#8055fd",
      10: "#7446ee",
      11: "#b4a6ff",
      12: "#e0dcff"
    }
  },
  red: {
    light: {
      1: "#fffcfc",
      2: "#fff7f6",
      3: "#ffebe9",
      4: "#ffdad6",
      5: "#ffcbc6",
      6: "#ffbab5",
      7: "#fca5a0",
      8: "#f48984",
      9: "#f83b45",
      10: "#ea2638",
      11: "#d8062a",
      12: "#6a0d14"
    },
    dark: {
      1: "#130a0a",
      2: "#201211",
      3: "#3e0e0f",
      4: "#55050c",
      5: "#670b13",
      6: "#791b1f",
      7: "#932b2d",
      8: "#be3a3c",
      9: "#f83b45",
      10: "#e92939",
      11: "#ff8f89",
      12: "#ffd0cb"
    }
  },
  gray: {
    light: {
      1: "#ffffff",
      2: "#f1f1f1",
      3: "#f0f0f0",
      4: "#e8e8e8",
      5: "#e0e0e0",
      6: "#dfdfdf",
      7: "#cecece",
      8: "#bbbbbb",
      9: "#8d8d8d",
      10: "#838383",
      11: "#464646",
      12: "#202020"
    },
    dark: {
      1: "#0D0D0D",
      2: "#1D1D1D",
      3: "#222222",
      4: "#2a2a2a",
      5: "#313131",
      6: "#3a3a3a",
      7: "#484848",
      8: "#606060",
      9: "#6e6e6e",
      10: "#7b7b7b",
      11: "#b4b4b4",
      12: "#eeeeee"
    }
  }
};

// ../../theme/src/constants.ts
var defaultFontType = "Google";
var defaultFontFamily = "Open Sans";
var defaultBackgroundType = "Color" /* COLOR */;
var defaultBackgroundColor = {
  "6": "#FFFFFF",
  "6.1": colors.gray.light["2"]
};
var defaultProgressBarColor = {
  "6": "#e0edff",
  "6.1": colors.orange.light["9"]
};
var defaultProgressBarBackgroundColor = {
  "6": colors.gray.light["3"],
  "6.1": colors.gray.light["9"]
};
var defaultProgressBarThickness = 4;
var defaultProgressBarPosition = "absolute";
var defaultProgressBarPlacement = "Top";
var defaultRoundness = "medium";
var defaultOpacity = 1;
var defaultBlur = 0;
var defaultContainerMaxWidth = "800px";
var defaultContainerMaxHeight = "100%";
var defaultContainerBackgroundColor = "transparent";
var defaultHostBubblesBackgroundColor = {
  "6": "#F7F8FF",
  "6.1": colors.gray.light["1"]
};
var defaultHostBubblesColor = colors.gray.light["12"];
var defaultHostBubbleBorderThickness = {
  "6": 0,
  "6.1": 1
};
var defaultHostBubbleBorderColor = colors.gray.light["6"];
var defaultGuestBubblesBackgroundColor = {
  "6": "#FF8E21",
  "6.1": colors.orange.light["9"]
};
var defaultGuestBubblesColor = colors.gray.light["1"];
var defaultGuestBubbleBorderThickness = {
  "6": 0,
  "6.1": 1
};
var defaultGuestBubbleBorderColor = colors.orange.light["6"];
var defaultButtonsBackgroundColor = {
  "6": "#0042DA",
  "6.1": colors.orange.light["9"]
};
var defaultButtonsColor = colors.gray.light["1"];
var defaultButtonsBorderThickness = {
  "6": 0,
  "6.1": 1
};
var defaultButtonsBorderColor = colors.orange.light["8"];
var defaultInputsBackgroundColor = "#FFFFFF";
var defaultInputsColor = colors.gray.light["12"];
var defaultInputsPlaceholderColor = "#9095A0";
var defaultInputsBorderThickness = {
  "6": 0,
  "6.1": 1
};
var defaultInputsBorderColor = {
  "6": void 0,
  "6.1": colors.gray.light["7"]
};
var defaultInputsShadow = {
  "6": "md",
  "6.1": void 0
};
var defaultHostAvatarIsEnabled = true;
var defaultGuestAvatarIsEnabled = false;
var defaultButtonsInputLayout = "wrap";
var botCssVariableNames = {
  general: {
    bgImage: "--typebot-container-bg-image",
    bgColor: "--typebot-container-bg-color",
    fontFamily: "--typebot-container-font-family",
    progressBar: {
      position: "--typebot-progress-bar-position",
      color: "--typebot-progress-bar-color",
      colorRgb: "--typebot-progress-bar-bg-rgb",
      height: "--typebot-progress-bar-height",
      top: "--typebot-progress-bar-top",
      bottom: "--typebot-progress-bar-bottom"
    }
  },
  chat: {
    container: {
      maxWidth: "--typebot-chat-container-max-width",
      maxHeight: "--typebot-chat-container-max-height",
      bgColor: "--typebot-chat-container-bg-rgb",
      color: "--typebot-chat-container-color",
      borderRadius: "--typebot-chat-container-border-radius",
      borderWidth: "--typebot-chat-container-border-width",
      borderColor: "--typebot-chat-container-border-rgb",
      borderOpacity: "--typebot-chat-container-border-opacity",
      opacity: "--typebot-chat-container-opacity",
      blur: "--typebot-chat-container-blur",
      boxShadow: "--typebot-chat-container-box-shadow"
    },
    hostBubbles: {
      bgColor: "--typebot-host-bubble-bg-rgb",
      color: "--typebot-host-bubble-color",
      borderRadius: "--typebot-host-bubble-border-radius",
      borderWidth: "--typebot-host-bubble-border-width",
      borderColor: "--typebot-host-bubble-border-rgb",
      borderOpacity: "--typebot-host-bubble-border-opacity",
      opacity: "--typebot-host-bubble-opacity",
      blur: "--typebot-host-bubble-blur",
      boxShadow: "--typebot-host-bubble-box-shadow"
    },
    guestBubbles: {
      bgColor: "--typebot-guest-bubble-bg-rgb",
      color: "--typebot-guest-bubble-color",
      borderRadius: "--typebot-guest-bubble-border-radius",
      borderWidth: "--typebot-guest-bubble-border-width",
      borderColor: "--typebot-guest-bubble-border-rgb",
      borderOpacity: "--typebot-guest-bubble-border-opacity",
      opacity: "--typebot-guest-bubble-opacity",
      blur: "--typebot-guest-bubble-blur",
      boxShadow: "--typebot-guest-bubble-box-shadow"
    },
    inputs: {
      bgColor: "--typebot-input-bg-rgb",
      color: "--typebot-input-color",
      placeholderColor: "--typebot-input-placeholder-color",
      borderRadius: "--typebot-input-border-radius",
      borderWidth: "--typebot-input-border-width",
      borderColor: "--typebot-input-border-rgb",
      borderOpacity: "--typebot-input-border-opacity",
      opacity: "--typebot-input-opacity",
      blur: "--typebot-input-blur",
      boxShadow: "--typebot-input-box-shadow"
    },
    buttons: {
      bgRgb: "--typebot-button-bg-rgb",
      color: "--typebot-button-color",
      borderRadius: "--typebot-button-border-radius",
      borderWidth: "--typebot-button-border-width",
      borderColor: "--typebot-button-border-rgb",
      borderOpacity: "--typebot-button-border-opacity",
      opacity: "--typebot-button-opacity",
      blur: "--typebot-button-blur",
      boxShadow: "--typebot-button-box-shadow",
      flexDirection: "--typebot-buttons-input-flex-direction"
    },
    checkbox: {
      bgRgb: "--typebot-checkbox-bg-rgb",
      alphaRatio: "--selectable-alpha-ratio"
    }
  }
};

// src/utils/injectFont.ts
var googleFontCdnBaseUrl = "https://fonts.bunny.net/css2";
var elementId = "typebot-font";
var injectFont = (font) => {
  const existingFont = document.getElementById(elementId);
  if (typeof font === "string" || font.type === "Google") {
    const fontFamily = (typeof font === "string" ? font : font.family) ?? defaultFontFamily;
    if (existingFont?.getAttribute("href")?.includes(fontFamily)) return;
    existingFont?.remove();
    const fontElement = document.createElement("link");
    fontElement.href = `${googleFontCdnBaseUrl}?family=${fontFamily}:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap`;
    fontElement.rel = "stylesheet";
    fontElement.id = elementId;
    document.head.appendChild(fontElement);
    return;
  }
  if (font.type === "Custom") {
    if (isNotEmpty(font.css)) {
      if (existingFont?.innerHTML === font.css) return;
      existingFont?.remove();
      const style2 = document.createElement("style");
      style2.innerHTML = font.css;
      style2.id = elementId;
      document.head.appendChild(style2);
    }
    if (isNotEmpty(font.url)) {
      if (existingFont?.getAttribute("href") === font.url) return;
      existingFont?.remove();
      const fontElement = document.createElement("link");
      fontElement.href = font.url;
      fontElement.rel = "stylesheet";
      fontElement.id = elementId;
      document.head.appendChild(fontElement);
    }
  }
};

// ../../settings/src/constants.ts
var defaultSettings = {
  general: {
    isInputPrefillEnabled: false,
    isHideQueryParamsEnabled: true,
    isNewResultOnRefreshEnabled: true,
    rememberUser: {
      isEnabled: false,
      storage: "session"
    },
    isBrandingEnabled: false,
    isTypingEmulationEnabled: true
  },
  typingEmulation: {
    enabled: true,
    speed: 400,
    maxDelay: 3,
    delayBetweenBubbles: 0,
    isDisabledOnFirstMessage: true
  },
  metadata: {
    description: "Build beautiful conversational forms and embed them directly in your applications without a line of code. Triple your response rate and collect answers that has more value compared to a traditional form.",
    favIconUrl: (viewerBaseUrl) => viewerBaseUrl + "/favicon.svg",
    imageUrl: (viewerBaseUrl) => viewerBaseUrl + "/site-preview.png"
  }
};
var defaultSystemMessages = {
  invalidMessage: "Invalid message. Please, try again.",
  botClosed: "This bot is now closed",
  networkErrorTitle: "Network Error",
  networkErrorMessage: "Please check your internet connection and try again.",
  popupBlockedTitle: "Popup blocked",
  popupBlockedDescription: "The bot wants to open a new tab but it was blocked by your browser. It needs a manual approval.",
  popupBlockedButtonLabel: "Continue in new tab",
  fileUploadError: "An error occured while uploading the files",
  fileUploadSizeError: "[[file]] is larger than [[limit]]MB",
  whatsAppPictureChoiceSelectLabel: "Select"
};

// ../../../node_modules/solid-js/store/dist/store.js
var $RAW = Symbol("store-raw");
var $NODE = Symbol("store-node");
var $HAS = Symbol("store-has");
var $SELF = Symbol("store-self");
function isWrappable(obj) {
  let proto;
  return obj != null && typeof obj === "object" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));
}
function unwrap(item, set2 = /* @__PURE__ */ new Set()) {
  let result, unwrapped, v, prop;
  if (result = item != null && item[$RAW]) return result;
  if (!isWrappable(item) || set2.has(item)) return item;
  if (Array.isArray(item)) {
    if (Object.isFrozen(item)) item = item.slice(0);
    else set2.add(item);
    for (let i = 0, l = item.length; i < l; i++) {
      v = item[i];
      if ((unwrapped = unwrap(v, set2)) !== v) item[i] = unwrapped;
    }
  } else {
    if (Object.isFrozen(item)) item = Object.assign({}, item);
    else set2.add(item);
    const keys = Object.keys(item), desc = Object.getOwnPropertyDescriptors(item);
    for (let i = 0, l = keys.length; i < l; i++) {
      prop = keys[i];
      if (desc[prop].get) continue;
      v = item[prop];
      if ((unwrapped = unwrap(v, set2)) !== v) item[prop] = unwrapped;
    }
  }
  return item;
}
function getNodes(target, symbol) {
  let nodes = target[symbol];
  if (!nodes)
    Object.defineProperty(target, symbol, {
      value: nodes = /* @__PURE__ */ Object.create(null)
    });
  return nodes;
}
function getNode(nodes, property, value) {
  if (nodes[property]) return nodes[property];
  const [s, set2] = createSignal(value, {
    equals: false,
    internal: true
  });
  s.$ = set2;
  return nodes[property] = s;
}
function setProperty(state2, property, value, deleting = false) {
  if (!deleting && state2[property] === value) return;
  const prev = state2[property], len = state2.length;
  if (value === void 0) {
    delete state2[property];
    if (state2[$HAS] && state2[$HAS][property] && prev !== void 0) state2[$HAS][property].$();
  } else {
    state2[property] = value;
    if (state2[$HAS] && state2[$HAS][property] && prev === void 0) state2[$HAS][property].$();
  }
  let nodes = getNodes(state2, $NODE), node;
  if (node = getNode(nodes, property, prev)) node.$(() => value);
  if (Array.isArray(state2) && state2.length !== len) {
    for (let i = state2.length; i < len; i++) (node = nodes[i]) && node.$();
    (node = getNode(nodes, "length", len)) && node.$(state2.length);
  }
  (node = nodes[$SELF]) && node.$();
}
var $ROOT = Symbol("store-root");
function applyState(target, parent2, property, merge, key) {
  const previous = parent2[property];
  if (target === previous) return;
  const isArray2 = Array.isArray(target);
  if (property !== $ROOT && (!isWrappable(target) || !isWrappable(previous) || isArray2 !== Array.isArray(previous) || key && target[key] !== previous[key])) {
    setProperty(parent2, property, target);
    return;
  }
  if (isArray2) {
    if (target.length && previous.length && (!merge || key && target[0] && target[0][key] != null)) {
      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;
      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start] && target[start] && previous[start][key] === target[start][key]); start++) {
        applyState(target[start], previous, start, merge, key);
      }
      const temp = new Array(target.length), newIndices = /* @__PURE__ */ new Map();
      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end] && target[newEnd] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {
        temp[newEnd] = previous[end];
      }
      if (start > newEnd || start > end) {
        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);
        for (; j < target.length; j++) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        }
        if (previous.length > target.length) setProperty(previous, "length", target.length);
        return;
      }
      newIndicesNext = new Array(newEnd + 1);
      for (j = newEnd; j >= start; j--) {
        item = target[j];
        keyVal = key && item ? item[key] : item;
        i = newIndices.get(keyVal);
        newIndicesNext[j] = i === void 0 ? -1 : i;
        newIndices.set(keyVal, j);
      }
      for (i = start; i <= end; i++) {
        item = previous[i];
        keyVal = key && item ? item[key] : item;
        j = newIndices.get(keyVal);
        if (j !== void 0 && j !== -1) {
          temp[j] = previous[i];
          j = newIndicesNext[j];
          newIndices.set(keyVal, j);
        }
      }
      for (j = start; j < target.length; j++) {
        if (j in temp) {
          setProperty(previous, j, temp[j]);
          applyState(target[j], previous, j, merge, key);
        } else setProperty(previous, j, target[j]);
      }
    } else {
      for (let i = 0, len = target.length; i < len; i++) {
        applyState(target[i], previous, i, merge, key);
      }
    }
    if (previous.length > target.length) setProperty(previous, "length", target.length);
    return;
  }
  const targetKeys = Object.keys(target);
  for (let i = 0, len = targetKeys.length; i < len; i++) {
    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);
  }
  const previousKeys = Object.keys(previous);
  for (let i = 0, len = previousKeys.length; i < len; i++) {
    if (target[previousKeys[i]] === void 0) setProperty(previous, previousKeys[i], void 0);
  }
}
function reconcile(value, options2 = {}) {
  const { merge, key = "id" } = options2, v = unwrap(value);
  return (state2) => {
    if (!isWrappable(state2) || !isWrappable(v)) return v;
    const res = applyState(
      v,
      {
        [$ROOT]: state2
      },
      $ROOT,
      merge,
      key
    );
    return res === void 0 ? state2 : res;
  };
}

// src/utils/persist.ts
function persist(signal, params) {
  if (!params.storage) return [...signal];
  const storage = parseRememberUserStorage(
    params.storage || defaultSettings.general.rememberUser.storage
  );
  const serialize3 = (data) => {
    const clonedData = JSON.parse(JSON.stringify(data));
    if (typeof clonedData !== "object") return JSON.stringify(clonedData);
    if ("blobUrl" in clonedData) {
      clonedData.blobUrl = void 0;
    }
    if ("attachments" in clonedData && Array.isArray(clonedData.attachments)) {
      clonedData.attachments.forEach((attachment) => {
        if (attachment && "blobUrl" in attachment) {
          attachment.blobUrl = void 0;
        }
      });
    }
    return JSON.stringify(clonedData);
  };
  const deserialize = JSON.parse.bind(JSON);
  const init = storage.getItem(params.key);
  const set2 = typeof signal[0] === "function" ? (data) => signal[1](() => deserialize(data)) : (data) => signal[1](reconcile(deserialize(data)));
  if (init) {
    set2(init);
    params.onRecovered?.();
  }
  return [
    signal[0],
    typeof signal[0] === "function" ? (value) => {
      const output = signal[1](value);
      if (value) storage.setItem(params.key, serialize3(output));
      else storage.removeItem(params.key);
      return output;
    } : (...args) => {
      signal[1](...args);
      const value = serialize3(untrack(() => signal[0]));
      storage.setItem(params.key, value);
    }
  ];
}
var parseRememberUserStorage = (storage) => (storage ?? defaultSettings.general.rememberUser.storage) === "session" ? sessionStorage : localStorage;

// ../../lib/src/hexToRgb.ts
var hexToRgb = (hex) => {
  const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  hex = hex.replace(shorthandRegex, (_m, r2, g, b) => {
    return r2 + r2 + g + g + b + b;
  });
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? [
    Number.parseInt(result[1] ?? "", 16),
    Number.parseInt(result[2] ?? "", 16),
    Number.parseInt(result[3] ?? "", 16)
  ] : [0, 0, 0];
};
var isLight = (hexColor) => (([r2, g, b]) => (r2 * 299 + g * 587 + b * 114) / 1e3 > 155)(
  hexToRgb(hexColor)
);

// ../../theme/src/helpers/isChatContainerLight.ts
var isChatContainerLight = ({
  chatContainer,
  generalBackground
}) => {
  const chatContainerBgColor = chatContainer?.backgroundColor ?? defaultContainerBackgroundColor;
  const ignoreChatBackground = (chatContainer?.opacity ?? defaultOpacity) <= 0.3 || chatContainerBgColor === "transparent" || isEmpty(chatContainerBgColor);
  if (ignoreChatBackground) {
    const bgType = generalBackground?.type ?? defaultBackgroundType;
    const backgroundColor = bgType === "Image" /* IMAGE */ ? "#000000" : bgType === "Color" /* COLOR */ && isNotEmpty(generalBackground?.content) ? generalBackground.content : "#ffffff";
    return isLight(backgroundColor);
  }
  return isLight(chatContainerBgColor);
};

// src/utils/setCssVariablesValue.ts
var setCssVariablesValue = ({
  theme,
  container,
  isPreview,
  typebotVersion
}) => {
  if (!theme) return;
  const documentStyle = container?.style;
  if (!documentStyle) return;
  setGeneralTheme({
    generalTheme: theme.general,
    documentStyle,
    isPreview,
    typebotVersion
  });
  setChatTheme({
    chatTheme: theme.chat,
    generalBackground: theme.general?.background,
    documentStyle,
    typebotVersion
  });
};
var setGeneralTheme = ({
  generalTheme,
  documentStyle,
  isPreview,
  typebotVersion
}) => {
  setGeneralBackground({
    background: generalTheme?.background,
    documentStyle,
    typebotVersion
  });
  documentStyle.setProperty(
    botCssVariableNames.general.fontFamily,
    (typeof generalTheme?.font === "string" ? generalTheme.font : generalTheme?.font?.family) ?? defaultFontFamily
  );
  setProgressBar({
    progressBar: generalTheme?.progressBar,
    documentStyle,
    isPreview,
    typebotVersion
  });
};
var setProgressBar = ({
  progressBar,
  documentStyle,
  isPreview,
  typebotVersion
}) => {
  const position = progressBar?.position ?? defaultProgressBarPosition;
  documentStyle.setProperty(
    botCssVariableNames.general.progressBar.position,
    position === "fixed" ? isPreview ? "absolute" : "fixed" : position
  );
  documentStyle.setProperty(
    botCssVariableNames.general.progressBar.color,
    progressBar?.color ?? defaultProgressBarColor[typebotVersion]
  );
  documentStyle.setProperty(
    botCssVariableNames.general.progressBar.colorRgb,
    hexToRgb(
      progressBar?.backgroundColor ?? defaultProgressBarBackgroundColor[typebotVersion]
    ).join(", ")
  );
  documentStyle.setProperty(
    botCssVariableNames.general.progressBar.height,
    `${progressBar?.thickness ?? defaultProgressBarThickness}px`
  );
  const placement = progressBar?.placement ?? defaultProgressBarPlacement;
  documentStyle.setProperty(
    botCssVariableNames.general.progressBar.top,
    placement === "Top" ? "0" : "auto"
  );
  documentStyle.setProperty(
    botCssVariableNames.general.progressBar.bottom,
    placement === "Bottom" ? "0" : "auto"
  );
};
var setChatTheme = ({
  chatTheme,
  generalBackground,
  documentStyle,
  typebotVersion
}) => {
  setChatContainer({
    container: chatTheme?.container,
    generalBackground,
    documentStyle,
    legacyRoundness: chatTheme?.roundness,
    typebotVersion
  });
  setHostBubbles({
    hostBubbles: chatTheme?.hostBubbles,
    documentStyle,
    legacyRoundness: chatTheme?.roundness,
    typebotVersion
  });
  setGuestBubbles({
    guestBubbles: chatTheme?.guestBubbles,
    documentStyle,
    legacyRoundness: chatTheme?.roundness,
    typebotVersion
  });
  setButtons({
    buttons: chatTheme?.buttons,
    documentStyle,
    legacyRoundness: chatTheme?.roundness,
    typebotVersion
  });
  setInputs({
    inputs: chatTheme?.inputs,
    documentStyle,
    legacyRoundness: chatTheme?.roundness,
    typebotVersion
  });
  setCheckbox(chatTheme?.container, generalBackground, documentStyle);
  setButtonsInput({
    buttonsInput: chatTheme?.buttonsInput,
    documentStyle,
    typebotVersion
  });
};
var setChatContainer = ({
  container,
  generalBackground,
  documentStyle,
  legacyRoundness
}) => {
  const chatContainerBgColor = container?.backgroundColor ?? defaultContainerBackgroundColor;
  const isBgDisabled = chatContainerBgColor === "transparent" || isEmpty(chatContainerBgColor);
  documentStyle.setProperty(
    botCssVariableNames.chat.container.bgColor,
    isBgDisabled ? "0, 0, 0" : hexToRgb(chatContainerBgColor).join(", ")
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.container.color,
    hexToRgb(
      container?.color ?? (isChatContainerLight({
        chatContainer: container,
        generalBackground
      }) ? colors.gray.light[12] : colors.gray.dark[12])
    ).join(", ")
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.container.maxWidth,
    container?.maxWidth ?? defaultContainerMaxWidth
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.container.maxHeight,
    container?.maxHeight ?? defaultContainerMaxHeight
  );
  const opacity = isBgDisabled ? "1" : (container?.opacity ?? defaultOpacity).toString();
  documentStyle.setProperty(
    botCssVariableNames.chat.container.opacity,
    isBgDisabled ? "0" : (container?.opacity ?? defaultOpacity).toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.container.blur,
    opacity === "1" || isBgDisabled ? "0xp" : `${container?.blur ?? defaultBlur}px`
  );
  setShadow(
    container?.shadow,
    documentStyle,
    botCssVariableNames.chat.container.boxShadow
  );
  setBorderRadius(
    container?.border ?? {
      roundeness: legacyRoundness ?? defaultRoundness
    },
    documentStyle,
    botCssVariableNames.chat.container.borderRadius
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.container.borderWidth,
    isDefined(container?.border?.thickness) ? `${container?.border?.thickness}px` : "0"
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.container.borderOpacity,
    isDefined(container?.border?.opacity) ? container.border.opacity.toString() : defaultOpacity.toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.container.borderColor,
    hexToRgb(container?.border?.color ?? "").join(", ")
  );
};
var setHostBubbles = ({
  hostBubbles,
  documentStyle,
  legacyRoundness,
  typebotVersion
}) => {
  documentStyle.setProperty(
    botCssVariableNames.chat.hostBubbles.bgColor,
    hexToRgb(
      hostBubbles?.backgroundColor ?? defaultHostBubblesBackgroundColor[typebotVersion]
    ).join(", ")
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.hostBubbles.color,
    hostBubbles?.color ?? defaultHostBubblesColor
  );
  setBorderRadius(
    hostBubbles?.border ?? {
      roundeness: legacyRoundness ?? defaultRoundness
    },
    documentStyle,
    botCssVariableNames.chat.hostBubbles.borderRadius
  );
  const borderThickness = hostBubbles?.border?.thickness ?? defaultHostBubbleBorderThickness[typebotVersion];
  if (isDefined(borderThickness)) {
    documentStyle.setProperty(
      botCssVariableNames.chat.hostBubbles.borderWidth,
      borderThickness + "px"
    );
  }
  documentStyle.setProperty(
    botCssVariableNames.chat.hostBubbles.borderColor,
    hexToRgb(hostBubbles?.border?.color ?? defaultHostBubbleBorderColor).join(
      ", "
    )
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.hostBubbles.opacity,
    hostBubbles?.backgroundColor === "transparent" ? "0" : isDefined(hostBubbles?.opacity) ? hostBubbles.opacity.toString() : defaultOpacity.toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.hostBubbles.borderOpacity,
    isDefined(hostBubbles?.border?.opacity) ? hostBubbles.border.opacity.toString() : defaultOpacity.toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.hostBubbles.blur,
    isDefined(hostBubbles?.blur) ? `${hostBubbles.blur ?? 0}px` : "none"
  );
  setShadow(
    hostBubbles?.shadow,
    documentStyle,
    botCssVariableNames.chat.hostBubbles.boxShadow
  );
};
var setGuestBubbles = ({
  guestBubbles,
  documentStyle,
  legacyRoundness,
  typebotVersion
}) => {
  documentStyle.setProperty(
    botCssVariableNames.chat.guestBubbles.bgColor,
    hexToRgb(
      guestBubbles?.backgroundColor ?? defaultGuestBubblesBackgroundColor[typebotVersion]
    ).join(", ")
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.guestBubbles.color,
    guestBubbles?.color ?? defaultGuestBubblesColor
  );
  setBorderRadius(
    guestBubbles?.border ?? {
      roundeness: legacyRoundness ?? defaultRoundness
    },
    documentStyle,
    botCssVariableNames.chat.guestBubbles.borderRadius
  );
  const borderThickness = guestBubbles?.border?.thickness ?? defaultGuestBubbleBorderThickness[typebotVersion];
  if (isDefined(borderThickness)) {
    documentStyle.setProperty(
      botCssVariableNames.chat.guestBubbles.borderWidth,
      borderThickness + "px"
    );
  }
  documentStyle.setProperty(
    botCssVariableNames.chat.guestBubbles.borderColor,
    hexToRgb(guestBubbles?.border?.color ?? defaultGuestBubbleBorderColor).join(
      ", "
    )
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.guestBubbles.borderOpacity,
    isDefined(guestBubbles?.border?.opacity) ? guestBubbles.border.opacity.toString() : defaultOpacity.toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.guestBubbles.opacity,
    guestBubbles?.backgroundColor === "transparent" ? "0" : isDefined(guestBubbles?.opacity) ? guestBubbles.opacity.toString() : defaultOpacity.toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.guestBubbles.blur,
    isDefined(guestBubbles?.blur) ? `${guestBubbles.blur ?? 0}px` : "none"
  );
  setShadow(
    guestBubbles?.shadow,
    documentStyle,
    botCssVariableNames.chat.guestBubbles.boxShadow
  );
};
var setButtons = ({
  buttons,
  documentStyle,
  legacyRoundness,
  typebotVersion
}) => {
  const bgColor = buttons?.backgroundColor ?? defaultButtonsBackgroundColor[typebotVersion];
  documentStyle.setProperty(
    botCssVariableNames.chat.buttons.bgRgb,
    hexToRgb(bgColor).join(", ")
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.buttons.bgRgb,
    hexToRgb(bgColor).join(", ")
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.buttons.color,
    buttons?.color ?? defaultButtonsColor
  );
  setBorderRadius(
    buttons?.border ?? {
      roundeness: legacyRoundness ?? defaultRoundness
    },
    documentStyle,
    botCssVariableNames.chat.buttons.borderRadius
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.buttons.borderWidth,
    isDefined(buttons?.border?.thickness) ? `${buttons?.border?.thickness}px` : `${defaultButtonsBorderThickness[typebotVersion]}px`
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.buttons.borderColor,
    hexToRgb(
      buttons?.border?.color ?? buttons?.backgroundColor ?? defaultButtonsBorderColor
    ).join(", ")
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.buttons.borderOpacity,
    isDefined(buttons?.border?.opacity) ? buttons.border.opacity.toString() : defaultOpacity.toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.buttons.opacity,
    buttons?.backgroundColor === "transparent" ? "0" : isDefined(buttons?.opacity) ? buttons.opacity.toString() : defaultOpacity.toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.buttons.blur,
    isDefined(buttons?.blur) ? `${buttons.blur ?? 0}px` : defaultBlur.toString()
  );
  setShadow(
    buttons?.shadow,
    documentStyle,
    botCssVariableNames.chat.buttons.boxShadow
  );
};
var setButtonsInput = ({
  buttonsInput,
  documentStyle
}) => {
  documentStyle.setProperty(
    botCssVariableNames.chat.buttons.flexDirection,
    (buttonsInput?.layout ?? defaultButtonsInputLayout) === "vertical" ? "column" : "unset"
  );
};
var setInputs = ({
  inputs,
  documentStyle,
  legacyRoundness,
  typebotVersion
}) => {
  documentStyle.setProperty(
    botCssVariableNames.chat.inputs.bgColor,
    hexToRgb(inputs?.backgroundColor ?? defaultInputsBackgroundColor).join(
      ", "
    )
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.inputs.color,
    inputs?.color ?? defaultInputsColor
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.inputs.placeholderColor,
    inputs?.placeholderColor ?? defaultInputsPlaceholderColor
  );
  setBorderRadius(
    inputs?.border ?? {
      roundeness: legacyRoundness ?? defaultRoundness
    },
    documentStyle,
    botCssVariableNames.chat.inputs.borderRadius
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.inputs.borderWidth,
    `${inputs?.border?.thickness ?? defaultInputsBorderThickness[typebotVersion]}px`
  );
  const borderHexColor = inputs?.border?.color ?? defaultInputsBorderColor[typebotVersion];
  if (isDefined(borderHexColor)) {
    documentStyle.setProperty(
      botCssVariableNames.chat.inputs.borderColor,
      hexToRgb(borderHexColor).join(", ")
    );
  }
  documentStyle.setProperty(
    botCssVariableNames.chat.inputs.borderOpacity,
    isDefined(inputs?.border?.opacity) ? inputs.border.opacity.toString() : defaultOpacity.toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.inputs.opacity,
    inputs?.backgroundColor === "transparent" ? "0" : isDefined(inputs?.opacity) ? inputs.opacity.toString() : defaultOpacity.toString()
  );
  documentStyle.setProperty(
    botCssVariableNames.chat.inputs.blur,
    isDefined(inputs?.blur) ? `${inputs.blur ?? 0}px` : "none"
  );
  setShadow(
    inputs?.shadow ?? defaultInputsShadow[typebotVersion],
    documentStyle,
    botCssVariableNames.chat.inputs.boxShadow
  );
};
var setCheckbox = (container, generalBackground, documentStyle) => {
  const chatContainerBgColor = container?.backgroundColor ?? defaultContainerBackgroundColor;
  const isChatBgTransparent = chatContainerBgColor === "transparent" || isEmpty(chatContainerBgColor) || (container?.opacity ?? defaultOpacity) <= 0.2;
  if (isChatBgTransparent) {
    const bgType = generalBackground?.type ?? defaultBackgroundType;
    documentStyle.setProperty(
      botCssVariableNames.chat.checkbox.bgRgb,
      bgType === "Image" /* IMAGE */ ? "rgba(255, 255, 255, 0.75)" : hexToRgb(
        (bgType === "Color" /* COLOR */ ? generalBackground?.content : "#ffffff") ?? "#ffffff"
      ).join(", ")
    );
    if (bgType === "Image" /* IMAGE */) {
      documentStyle.setProperty(
        botCssVariableNames.chat.checkbox.alphaRatio,
        "3"
      );
    } else {
      documentStyle.setProperty(
        botCssVariableNames.chat.checkbox.alphaRatio,
        generalBackground?.content && isLight(generalBackground?.content) ? "1" : "2"
      );
    }
  } else {
    documentStyle.setProperty(
      botCssVariableNames.chat.checkbox.bgRgb,
      hexToRgb(chatContainerBgColor).concat(container?.opacity ?? 1).join(", ")
    );
    documentStyle.setProperty(
      botCssVariableNames.chat.checkbox.alphaRatio,
      isLight(chatContainerBgColor) ? "1" : "2"
    );
  }
};
var setGeneralBackground = ({
  background,
  documentStyle,
  typebotVersion
}) => {
  documentStyle.setProperty(botCssVariableNames.general.bgImage, null);
  documentStyle.setProperty(botCssVariableNames.general.bgColor, null);
  documentStyle.setProperty(
    (background?.type ?? defaultBackgroundType) === "Image" /* IMAGE */ ? botCssVariableNames.general.bgImage : botCssVariableNames.general.bgColor,
    parseBackgroundValue({
      type: background?.type ?? defaultBackgroundType,
      content: background?.content ?? defaultBackgroundColor[typebotVersion]
    })
  );
};
var parseBackgroundValue = ({
  type,
  content
}) => {
  switch (type) {
    case "None" /* NONE */:
      return "transparent";
    case void 0:
    case "Color" /* COLOR */:
      return content;
    case "Image" /* IMAGE */:
      return `url(${content})`;
  }
};
var setBorderRadius = (border, documentStyle, variableName) => {
  switch (border?.roundeness ?? defaultRoundness) {
    case "none": {
      documentStyle.setProperty(variableName, "0");
      break;
    }
    case "medium": {
      documentStyle.setProperty(variableName, "6px");
      break;
    }
    case "large": {
      documentStyle.setProperty(variableName, "20px");
      break;
    }
    case "custom": {
      documentStyle.setProperty(
        variableName,
        `${border.customRoundeness ?? 6}px`
      );
      break;
    }
  }
};
var setShadow = (shadow, documentStyle, variableName) => {
  if (shadow === void 0) {
    documentStyle.setProperty(variableName, "0 0 #0000");
    return;
  }
  switch (shadow) {
    case "none":
      documentStyle.setProperty(variableName, "0 0 #0000");
      break;
    case "sm":
      documentStyle.setProperty(variableName, "0 1px 2px 0 rgb(0 0 0 / 0.05)");
      break;
    case "md":
      documentStyle.setProperty(
        variableName,
        "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)"
      );
      break;
    case "lg":
      documentStyle.setProperty(
        variableName,
        "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)"
      );
      break;
    case "xl":
      documentStyle.setProperty(
        variableName,
        "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)"
      );
      break;
    case "2xl":
      documentStyle.setProperty(
        variableName,
        "0 25px 50px -12px rgb(0 0 0 / 0.25)"
      );
      break;
  }
};

// src/utils/storage.ts
var storageResultIdKey = "resultId";
var getExistingResultIdFromStorage = (typebotId) => {
  if (!typebotId) return;
  try {
    return sessionStorage.getItem(`${storageResultIdKey}-${typebotId}`) ?? localStorage.getItem(`${storageResultIdKey}-${typebotId}`) ?? void 0;
  } catch {
  }
};
var setResultInStorage = (storageType = "session") => (typebotId, resultId) => {
  try {
    parseRememberUserStorage2(storageType).setItem(
      `${storageResultIdKey}-${typebotId}`,
      resultId
    );
  } catch {
  }
};
var getInitialChatReplyFromStorage = (typebotId) => {
  if (!typebotId) return;
  try {
    const rawInitialChatReply = sessionStorage.getItem(`typebot-${typebotId}-initialChatReply`) ?? localStorage.getItem(`typebot-${typebotId}-initialChatReply`);
    if (!rawInitialChatReply) return;
    return JSON.parse(rawInitialChatReply);
  } catch {
  }
};
var setInitialChatReplyInStorage = (initialChatReply, {
  typebotId,
  storage
}) => {
  try {
    const rawInitialChatReply = JSON.stringify(initialChatReply);
    parseRememberUserStorage2(storage).setItem(
      `typebot-${typebotId}-initialChatReply`,
      rawInitialChatReply
    );
  } catch {
  }
};
var setBotOpenedStateInStorage = () => {
  try {
    sessionStorage.setItem(`typebot-botOpened`, "true");
  } catch {
  }
};
var removeBotOpenedStateInStorage = () => {
  try {
    sessionStorage.removeItem(`typebot-botOpened`);
  } catch {
  }
};
var getBotOpenedStateFromStorage = () => {
  try {
    return sessionStorage.getItem(`typebot-botOpened`) === "true";
  } catch {
    return false;
  }
};
var parseRememberUserStorage2 = (storage) => (storage ?? defaultSettings.general.rememberUser.storage) === "session" ? sessionStorage : localStorage;
var wipeExistingChatStateInStorage = (typebotId) => {
  Object.keys(localStorage).forEach((key) => {
    if (key.startsWith(`typebot-${typebotId}`)) localStorage.removeItem(key);
  });
  Object.keys(sessionStorage).forEach((key) => {
    if (key.startsWith(`typebot-${typebotId}`)) sessionStorage.removeItem(key);
  });
};

// ../../../node_modules/@ark-ui/solid/dist/chunk/ZMHI4GDJ.js
var createSplitProps = () => (props7, keys) => splitProps(props7, keys);

// ../../../node_modules/@solid-primitives/keyed/dist/index.js
var FALLBACK2 = Symbol("fallback");
function dispose2(list) {
  for (const o of list)
    o.dispose();
}
function keyArray(items, keyFn, mapFn, options2 = {}) {
  if (isServer) {
    const itemsRef = items();
    let s = [];
    if (itemsRef && itemsRef.length) {
      for (let i = 0, len = itemsRef.length; i < len; i++)
        s.push(mapFn(() => itemsRef[i], () => i));
    } else if (options2.fallback)
      s = [options2.fallback()];
    return () => s;
  }
  const prev = /* @__PURE__ */ new Map();
  onCleanup(() => dispose2(prev.values()));
  return () => {
    const list = items() || [];
    list[$TRACK];
    return untrack(() => {
      if (!list.length) {
        dispose2(prev.values());
        prev.clear();
        if (!options2.fallback)
          return [];
        const fb2 = createRoot((dispose3) => {
          prev.set(FALLBACK2, { dispose: dispose3 });
          return options2.fallback();
        });
        return [fb2];
      }
      const result = new Array(list.length);
      const fb = prev.get(FALLBACK2);
      if (!prev.size || fb) {
        fb?.dispose();
        prev.delete(FALLBACK2);
        for (let i = 0; i < list.length; i++) {
          const item = list[i];
          const key = keyFn(item, i);
          addNewItem(result, item, i, key);
        }
        return result;
      }
      const prevKeys = new Set(prev.keys());
      for (let i = 0; i < list.length; i++) {
        const item = list[i];
        const key = keyFn(item, i);
        prevKeys.delete(key);
        const lookup = prev.get(key);
        if (lookup) {
          result[i] = lookup.mapped;
          lookup.setIndex?.(i);
          lookup.setItem(() => item);
        } else
          addNewItem(result, item, i, key);
      }
      for (const key of prevKeys) {
        prev.get(key)?.dispose();
        prev.delete(key);
      }
      return result;
    });
  };
  function addNewItem(list, item, i, key) {
    createRoot((dispose3) => {
      const [getItem, setItem] = createSignal(item);
      const save = { setItem, dispose: dispose3 };
      if (mapFn.length > 1) {
        const [index, setIndex] = createSignal(i);
        save.setIndex = setIndex;
        save.mapped = mapFn(getItem, index);
      } else
        save.mapped = mapFn(getItem);
      prev.set(key, save);
      list[i] = save.mapped;
    });
  }
}
function Key(props7) {
  const { by } = props7;
  return createMemo(keyArray(() => props7.each, typeof by === "function" ? by : (v) => v[by], props7.children, "fallback" in props7 ? { fallback: () => props7.fallback } : void 0));
}

// ../../../node_modules/@zag-js/utils/dist/index.mjs
function toArray(v) {
  if (!v) return [];
  return Array.isArray(v) ? v : [v];
}
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var add = (v, ...items) => v.concat(items);
var remove = (v, ...items) => v.filter((t) => !items.includes(t));
var uniq = (v) => Array.from(new Set(v));
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next2 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1) return step > 0 ? 0 : last2;
  if (next2 < 0) return loop ? last2 : 0;
  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;
  return next2;
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
var isArrayLike = (value) => value?.constructor.name === "Array";
var isArrayEqual = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (!isEqual(a[i], b[i])) return false;
  }
  return true;
};
var isEqual = (a, b) => {
  if (Object.is(a, b)) return true;
  if (a == null && b != null || a != null && b == null) return false;
  if (typeof a?.isEqual === "function" && typeof b?.isEqual === "function") {
    return a.isEqual(b);
  }
  if (typeof a === "function" && typeof b === "function") {
    return a.toString() === b.toString();
  }
  if (isArrayLike(a) && isArrayLike(b)) {
    return isArrayEqual(Array.from(a), Array.from(b));
  }
  if (!(typeof a === "object") || !(typeof b === "object")) return false;
  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const hasKey = Reflect.has(a, keys[i]);
    if (!hasKey) return false;
  }
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    if (!isEqual(a[key], b[key])) return false;
  }
  return true;
};
var isArray = (v) => Array.isArray(v);
var isObjectLike = (v) => v != null && typeof v === "object";
var isObject3 = (v) => isObjectLike(v) && !isArray(v);
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString = (v) => typeof v === "string";
var isFunction2 = (v) => typeof v === "function";
var isNull = (v) => v == null;
var fnToString = Function.prototype.toString;
var objectCtorString = fnToString.call(Object);
var runIfFn = (v, ...a) => {
  const res = typeof v === "function" ? v(...a) : v;
  return res ?? void 0;
};
var noop = () => {
};
var callAll = (...fns) => (...a) => {
  fns.forEach(function(fn) {
    fn?.(...a);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
function throttle(fn, wait = 0) {
  let lastCall = 0;
  let timeout2 = null;
  return (...args) => {
    const now = Date.now();
    const timeSinceLastCall = now - lastCall;
    if (timeSinceLastCall >= wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      fn(...args);
      lastCall = now;
    } else if (!timeout2) {
      timeout2 = setTimeout(() => {
        fn(...args);
        lastCall = Date.now();
        timeout2 = null;
      }, wait - timeSinceLastCall);
    }
  };
}
var { floor, abs, round, min, max, pow, sign } = Math;
var isNaN2 = (v) => Number.isNaN(v);
var nan = (v) => isNaN2(v) ? 0 : v;
var wrap = (v, vmax) => (v % vmax + vmax) % vmax;
var isValueAtMax = (v, vmax) => nan(v) >= vmax;
var isValueAtMin = (v, vmin) => nan(v) <= vmin;
var isValueWithinRange = (v, vmin, vmax) => nan(v) >= vmin && nan(v) <= vmax;
var clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);
var getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);
var roundToDpr = (v, dpr) => typeof dpr === "number" ? floor(v * dpr + 0.5) / dpr : round(v);
var countDecimals = (value) => {
  if (!Number.isFinite(value)) return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
};
var decimalOp = (a, op, b) => {
  let result = op === "+" ? a + b : a - b;
  if (a % 1 !== 0 || b % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));
    a = Math.round(a * multiplier);
    b = Math.round(b * multiplier);
    result = op === "+" ? a + b : a - b;
    result /= multiplier;
  }
  return result;
};
var incrementValue = (v, s) => decimalOp(nan(v), "+", s);
var decrementValue = (v, s) => decimalOp(nan(v), "-", s);
function compact(obj) {
  if (!isPlainObject2(obj) || obj === void 0) return obj;
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (v) => {
  return v && typeof v === "object" && v.constructor === Object;
};
function splitProps2(props7, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props7) {
    if (keySet.has(key)) {
      result[key] = props7[key];
    } else {
      rest[key] = props7[key];
    }
  }
  return [result, rest];
}
var createSplitProps2 = (keys) => {
  return function split(props7) {
    return splitProps2(props7, keys);
  };
};
function setRafTimeout(callback, delay3) {
  const start = performance.now();
  let handle;
  function loop(now) {
    handle = requestAnimationFrame(loop);
    const delta = now - start;
    if (delta >= delay3) {
      callback();
    }
  }
  handle = requestAnimationFrame(loop);
  return () => cancelAnimationFrame(handle);
}
function warn(...a) {
  const m = a.length === 1 ? a[0] : a[1];
  const c = a.length === 2 ? a[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function ensure(c, m) {
  if (c == null) throw new Error(m);
}
function ensureProps(props7, keys, scope) {
  let missingKeys = [];
  for (const key of keys) {
    if (props7[key] == null) missingKeys.push(key);
  }
  if (missingKeys.length > 0)
    throw new Error(`[zag-js${scope ? ` > ${scope}` : ""}] missing required props: ${missingKeys.join(", ")}`);
}

// ../../../node_modules/@zag-js/dom-query/dist/index.mjs
var wrap2 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
var isObject4 = (v) => typeof v === "object" && v !== null;
var MAX_Z_INDEX = 2147483647;
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var ELEMENT_NODE = 1;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;
var isHTMLElement = (el) => isObject4(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === "string";
var isDocument = (el) => isObject4(el) && el.nodeType === DOCUMENT_NODE;
var isWindow = (el) => isObject4(el) && el === el.window;
var getNodeName = (node) => {
  if (isHTMLElement(node)) return node.localName || "";
  return "#document";
};
function isRootElement(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var isNode = (el) => isObject4(el) && el.nodeType !== void 0;
var isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && "host" in el;
var isInputElement = (el) => isHTMLElement(el) && el.localName === "input";
var isAnchorElement = (el) => !!el?.matches("a[href]");
var isElementVisible = (el) => {
  if (!isHTMLElement(el)) return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
};
var TEXTAREA_SELECT_REGEX = /(textarea|select)/;
function isEditableElement(el) {
  if (el == null || !isHTMLElement(el)) return false;
  try {
    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute("contenteditable") === "true" || el.getAttribute("contenteditable") === "";
  } catch {
    return false;
  }
}
function contains(parent2, child) {
  if (!parent2 || !child) return false;
  if (!isHTMLElement(parent2) || !isHTMLElement(child)) return false;
  const rootNode = child.getRootNode?.();
  if (parent2 === child) return true;
  if (parent2.contains(child)) return true;
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent2 === next) return true;
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getDocument(el) {
  if (isDocument(el)) return el;
  if (isWindow(el)) return el.document;
  return el?.ownerDocument ?? document;
}
function getDocumentElement(el) {
  return getDocument(el).documentElement;
}
function getWindow(el) {
  if (isShadowRoot(el)) return getWindow(el.host);
  if (isDocument(el)) return el.defaultView ?? window;
  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;
  return window;
}
function getActiveElement(rootNode) {
  let activeElement = rootNode.activeElement;
  while (activeElement?.shadowRoot) {
    const el = activeElement.shadowRoot.activeElement;
    if (el === activeElement) break;
    else activeElement = el;
  }
  return activeElement;
}
function getParentNode(node) {
  if (getNodeName(node) === "html") return node;
  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle2(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return agent?.platform ?? navigator.platform;
}
function getUserAgent() {
  const ua2 = navigator.userAgentData;
  if (ua2 && Array.isArray(ua2.brands)) {
    return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(" ");
  }
  return navigator.userAgent;
}
var pt = (v) => isDom() && v.test(getPlatform());
var ua = (v) => isDom() && v.test(getUserAgent());
var vn = (v) => isDom() && v.test(navigator.vendor);
var isMac = () => pt(/^Mac/);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/firefox\//i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => pt(/iP(hone|ad|od)|iOS/);
function getComposedPath(event) {
  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return composedPath?.[0] ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const isAppleDevice = isApple();
  if (isAppleDevice && !event.metaKey) return false;
  if (!isAppleDevice && !event.ctrlKey) return false;
  const localName = element.localName;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isDownloadingEvent(event) {
  const element = event.currentTarget;
  if (!element) return false;
  const localName = element.localName;
  if (!event.altKey) return false;
  if (localName === "a") return true;
  if (localName === "button" && element.type === "submit") return true;
  if (localName === "input" && element.type === "submit") return true;
  return false;
}
function isComposingEvent(event) {
  return getNativeEvent(event).isComposing;
}
function isPrintableKey(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
var isLeftClick = (e) => e.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options2 = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options2;
  let key = event.key;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];
  return key;
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
var pageKeys = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var arrowKeys = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = pageKeys.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getEventPoint(event, type = "client") {
  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var addDomEvent = (target, eventName, handler, options2) => {
  const node = typeof target === "function" ? target() : target;
  node?.addEventListener(eventName, handler, options2);
  return () => {
    node?.removeEventListener(eventName, handler, options2);
  };
};
function getDescriptor(el, options2) {
  const { type = "HTMLInputElement", property = "value" } = options2;
  const proto = getWindow(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function getElementType(el) {
  if (el.localName === "input") return "HTMLInputElement";
  if (el.localName === "textarea") return "HTMLTextAreaElement";
  if (el.localName === "select") return "HTMLSelectElement";
}
function setElementValue(el, value, property = "value") {
  if (!el) return;
  const type = getElementType(el);
  if (type) {
    const descriptor = getDescriptor(el, { type, property });
    descriptor.set?.call(el, value);
  }
  el.setAttribute(property, value);
}
function getClosestForm(el) {
  return isFormElement(el) ? el.form : el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el) return;
  const form = getClosestForm(el);
  const onReset = (e) => {
    if (e.defaultPrevented) return;
    callback();
  };
  form?.addEventListener("reset", onReset, { passive: true });
  return () => form?.removeEventListener("reset", onReset);
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el?.closest("fieldset");
  if (!fieldset) return;
  callback(fieldset.disabled);
  const win = getWindow(fieldset);
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el, options2) {
  if (!el) return;
  const { onFieldsetDisabledChange, onFormReset } = options2;
  const cleanups2 = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
  return () => cleanups2.forEach((cleanup) => cleanup?.());
}
var isFrame = (el) => isHTMLElement(el) && el.tagName === "IFRAME";
var hasTabIndex = (el) => !Number.isNaN(parseInt(el.getAttribute("tabindex") || "0", 10));
var hasNegativeTabIndex = (el) => parseInt(el.getAttribute("tabindex") || "0", 10) < 0;
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container) return [];
  const elements2 = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements2.length === 0;
  if (include && isHTMLElement(container) && isFocusable(container)) {
    elements2.unshift(container);
  }
  const focusableElements = elements2.filter(isFocusable);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]")) return false;
  return element.matches(focusableSelector) && isElementVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container) return [];
  const elements2 = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements2.filter(isTabbable);
  if (includeContainer && isTabbable(container)) {
    tabbableElements.unshift(container);
  }
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) {
    return elements2;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (el != null && el.tabIndex > 0) return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getTabbableEdges(container, includeContainer) {
  const elements2 = getTabbables(container, includeContainer);
  const first2 = elements2[0] || null;
  const last2 = elements2[elements2.length - 1] || null;
  return [first2, last2];
}
function getTabIndex(node) {
  if (node.tabIndex < 0) {
    if ((/^(audio|video|details)$/.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
}
function getInitialFocus(options2) {
  const { root, getInitialEl, filter, enabled = true } = options2;
  if (!enabled) return;
  let node = null;
  node || (node = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node || (node = root?.querySelector("[data-autofocus],[autofocus]"));
  if (!node) {
    const tabbables = getTabbables(root);
    node = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container) return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey) return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;
  if (!firstTabbable && !lastTabbable) return false;
  return true;
}
function nextTick(fn) {
  const set2 = /* @__PURE__ */ new Set();
  function raf22(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set2.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf22(() => raf22(fn));
  return function cleanup() {
    set2.forEach((fn2) => fn2());
  };
}
function raf(fn) {
  let cleanup;
  const id = globalThis.requestAnimationFrame(() => {
    cleanup = fn();
  });
  return () => {
    globalThis.cancelAnimationFrame(id);
    cleanup?.();
  };
}
function queueBeforeEvent(el, type, cb) {
  const cancelTimer = raf(() => {
    el.removeEventListener(type, exec, true);
    cb();
  });
  const exec = () => {
    cancelTimer();
    cb();
  };
  el.addEventListener(type, exec, { once: true, capture: true });
  return cancelTimer;
}
function observeAttributesImpl(node, options2) {
  if (!node) return;
  const { attributes, callback: fn } = options2;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options2) {
  const { defer } = options2;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeAttributesImpl(node, options2));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
function clickIfLink(el) {
  const click = () => el.click();
  if (isFirefox()) {
    queueBeforeEvent(el, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function getNearestOverflowAncestor(el) {
  const parentNode = getParentNode(el);
  if (isRootElement(parentNode)) return getDocument(parentNode).body;
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;
  return getNearestOverflowAncestor(parentNode);
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
  const win = getWindow(el);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isScrollable(el) {
  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options2) {
  const { rootEl, ...scrollOptions } = options2 || {};
  if (!el || !rootEl) return;
  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;
  el.scrollIntoView(scrollOptions);
}
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
    fn?.(isLocked());
  }
  function onPointerError(event) {
    if (isLocked()) fn?.(false);
    console.error("PointerLock error occurred:", event);
    doc.exitPointerLock();
  }
  if (!supported) return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options2 = {}) {
  const { target, doc } = options2;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options2 = {}) {
  const { target, doc } = options2;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled") return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options2 = {}) {
  const { defer, target, ...restOptions } = options2;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof target === "function" ? target() : target;
      cleanups2.push(disableTextSelectionImpl({ ...restOptions, target: node }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const handleMove = (event) => {
    const point = getEventPoint(event);
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer) return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point, event });
  };
  const cleanups2 = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", onPointerUp, false),
    addDomEvent(doc, "pointercancel", onPointerUp, false),
    addDomEvent(doc, "contextmenu", onPointerUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups2.forEach((cleanup) => cleanup());
  };
}
function queryAll(root, selector) {
  return Array.from(root?.querySelectorAll(selector) ?? []);
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1) return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var sanitize = (str) => str.split("").map((char) => {
  const code = char.charCodeAt(0);
  if (code > 0 && code < 128) return char;
  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (el) => {
  return sanitize(el.dataset?.valuetext ?? el.textContent ?? "");
};
var match = (valueText, query2) => {
  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
};
function getByText(v, text2, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap2(v, index) : v;
  const isSingleKey = text2.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match(getValueText(item), text2));
}
var cleanups = /* @__PURE__ */ new WeakMap();
function set(element, key, setup2) {
  if (!cleanups.has(element)) {
    cleanups.set(element, /* @__PURE__ */ new Map());
  }
  const elementCleanups = cleanups.get(element);
  const prevCleanup = elementCleanups.get(key);
  if (!prevCleanup) {
    elementCleanups.set(key, setup2());
    return () => {
      elementCleanups.get(key)?.();
      elementCleanups.delete(key);
    };
  }
  const cleanup = setup2();
  const nextCleanup = () => {
    cleanup();
    prevCleanup();
    elementCleanups.delete(key);
  };
  elementCleanups.set(key, nextCleanup);
  return () => {
    const isCurrent = elementCleanups.get(key) === nextCleanup;
    if (!isCurrent) return;
    cleanup();
    elementCleanups.set(key, prevCleanup);
  };
}
function setStyle(element, style2) {
  if (!element) return () => {
  };
  const setup2 = () => {
    const prevStyle = element.style.cssText;
    Object.assign(element.style, style2);
    return () => {
      element.style.cssText = prevStyle;
    };
  };
  return set(element, "style", setup2);
}
function getByTypeaheadImpl(baseItems, options2) {
  const { state: state2, activeId, key, timeout: timeout2 = 350, itemToId } = options2;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = baseItems.slice();
  const next = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout2);
    }
  }
  update(search);
  return next;
}
var getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var fps = 1e3 / 60;
function waitForElement(query2, cb) {
  const el = query2();
  if (isHTMLElement(el) && el.isConnected) {
    cb(el);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el2 = query2();
      if (isHTMLElement(el2) && el2.isConnected) {
        cb(el2);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb) {
  const cleanups2 = [];
  queries?.forEach((query2) => {
    const clean = waitForElement(query2, cb);
    cleanups2.push(clean);
  });
  return () => {
    cleanups2.forEach((fn) => fn());
  };
}

// ../../../node_modules/@zag-js/solid/node_modules/@zag-js/core/dist/index.mjs
var clsx = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style2) => {
  const res = {};
  let match2;
  while (match2 = CSS_REGEX.exec(style2)) {
    res[match2[1]] = match2[2];
  }
  return res;
};
var css = (a, b) => {
  if (isString(a)) {
    if (isString(b)) return `${a};${b}`;
    a = serialize(a);
  } else if (isString(b)) {
    b = serialize(b);
  }
  return Object.assign({}, a ?? {}, b ?? {});
};
function mergeProps2(...args) {
  let result = {};
  for (let props7 of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props7[key] === "function") {
        result[key] = callAll(props7[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props7[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props7[key]);
        continue;
      }
      result[key] = props7[key] !== void 0 ? props7[key] : result[key];
    }
    for (let key in props7) {
      if (result[key] === void 0) {
        result[key] = props7[key];
      }
    }
  }
  return result;
}
function createScope(props7) {
  const getRootNode = () => props7.getRootNode?.() ?? document;
  const getDoc = () => getDocument(getRootNode());
  const getWin = () => getDoc().defaultView ?? window;
  const getActiveElementFn = () => getActiveElement(getRootNode());
  const isActiveElement = (elem) => elem === getActiveElementFn();
  const getById = (id) => getRootNode().getElementById(id);
  return {
    ...props7,
    getRootNode,
    getDoc,
    getWin,
    getActiveElement: getActiveElementFn,
    isActiveElement,
    getById
  };
}

// ../../../node_modules/@zag-js/types/dist/index.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get(_target, key) {
      if (key === "style")
        return (props7) => {
          return fn({ style: props7 }).style;
        };
      return fn;
    }
  });
}
var createProps2 = () => (props7) => Array.from(new Set(props7));

// ../../../node_modules/@zag-js/solid/dist/index.mjs
function createBindable(props7) {
  const initial = props7().value ?? props7().defaultValue;
  const eq = props7().isEqual ?? Object.is;
  const [value, setValue] = createSignal(initial);
  const controlled = createMemo(() => props7().value != void 0);
  const valueRef = { current: value() };
  const prevValue = { current: void 0 };
  createEffect(() => {
    const v = controlled() ? props7().value : value();
    prevValue.current = v;
    valueRef.current = v;
  });
  const set2 = (v) => {
    const prev = prevValue.current;
    const next = isFunction2(v) ? v(valueRef.current) : v;
    if (props7().debug) {
      console.log(`[bindable > ${props7().debug}] setValue`, { next, prev });
    }
    if (!controlled()) setValue(next);
    if (!eq(next, prev)) {
      props7().onChange?.(next, prev);
    }
  };
  function get() {
    const v = controlled() ? props7().value : value;
    return isFunction2(v) ? v() : v;
  }
  return {
    initial,
    ref: valueRef,
    get,
    set: set2,
    invoke(nextValue, prevValue2) {
      props7().onChange?.(nextValue, prevValue2);
    },
    hash(value2) {
      return props7().hash?.(value2) ?? String(value2);
    }
  };
}
function createRefs(refs) {
  const [ref, setRef2] = createSignal(refs);
  return {
    get(key) {
      return ref()[key];
    },
    set(key, value) {
      setRef2((prev) => ({ ...prev, [key]: value }));
    }
  };
}
function access(v) {
  if (isFunction2(v)) return v();
  return v;
}
var createTrack = (deps, effect) => {
  let prevDeps = [];
  let isFirstRun = true;
  createEffect(() => {
    if (isFirstRun) {
      prevDeps = deps.map((d) => access(d));
      isFirstRun = false;
      return;
    }
    let changed = false;
    for (let i = 0; i < deps.length; i++) {
      if (!isEqual(prevDeps[i], access(deps[i]))) {
        changed = true;
        break;
      }
    }
    if (changed) {
      prevDeps = deps.map((d) => access(d));
      effect();
    }
  });
};
function useMachine(machine8, userProps = {}) {
  const scope = createMemo(() => {
    const { id, ids, getRootNode } = access2(userProps);
    return createScope({ id, ids, getRootNode });
  });
  const debug = (...args) => {
    if (machine8.debug) console.log(...args);
  };
  const props7 = createMemo(
    () => machine8.props?.({
      props: compact(access2(userProps)),
      scope: scope()
    }) ?? access2(userProps)
  );
  const prop = createProp(props7);
  const context = machine8.context?.({
    prop,
    bindable: createBindable,
    get scope() {
      return scope();
    },
    flush,
    getContext() {
      return ctx;
    },
    getComputed() {
      return computed;
    }
  });
  const ctx = {
    get(key) {
      return context?.[key].get();
    },
    set(key, value) {
      context?.[key].set(value);
    },
    initial(key) {
      return context?.[key].initial;
    },
    hash(key) {
      const current = context?.[key].get();
      return context?.[key].hash(current);
    }
  };
  const effects = { current: /* @__PURE__ */ new Map() };
  const transitionRef = { current: null };
  const previousEventRef = { current: null };
  const eventRef = { current: { type: "" } };
  const getEvent = () => mergeProps(eventRef.current, {
    current() {
      return eventRef.current;
    },
    previous() {
      return previousEventRef.current;
    }
  });
  const getState = () => mergeProps(state2, {
    matches(...values) {
      const current = state2.get();
      return values.includes(current);
    },
    hasTag(tag) {
      const current = state2.get();
      return !!machine8.states[current]?.tags?.includes(tag);
    }
  });
  const refs = createRefs(machine8.refs?.({ prop, context: ctx }) ?? {});
  const getParams = () => ({
    state: getState(),
    context: ctx,
    event: getEvent(),
    prop,
    send,
    action,
    guard,
    track: createTrack,
    refs,
    computed,
    flush,
    get scope() {
      return scope();
    },
    choose: choose2
  });
  const action = (keys) => {
    const strs = isFunction2(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine8.implementations?.actions?.[s];
      if (!fn) warn(`[zag-js] No implementation found for action "${JSON.stringify(s)}"`);
      return fn;
    });
    for (const fn of fns) {
      fn?.(getParams());
    }
  };
  const guard = (str) => {
    if (isFunction2(str)) return str(getParams());
    return machine8.implementations?.guards?.[str](getParams());
  };
  const effect = (keys) => {
    const strs = isFunction2(keys) ? keys(getParams()) : keys;
    if (!strs) return;
    const fns = strs.map((s) => {
      const fn = machine8.implementations?.effects?.[s];
      if (!fn) warn(`[zag-js] No implementation found for effect "${JSON.stringify(s)}"`);
      return fn;
    });
    const cleanups2 = [];
    for (const fn of fns) {
      const cleanup = fn?.(getParams());
      if (cleanup) cleanups2.push(cleanup);
    }
    return () => cleanups2.forEach((fn) => fn?.());
  };
  const choose2 = (transitions) => {
    return toArray(transitions).find((t) => {
      let result = !t.guard;
      if (isString(t.guard)) result = !!guard(t.guard);
      else if (isFunction2(t.guard)) result = t.guard(getParams());
      return result;
    });
  };
  const computed = (key) => {
    ensure(machine8.computed, `[zag-js] No computed object found on machine`);
    const fn = machine8.computed[key];
    return fn({
      context: ctx,
      event: eventRef.current,
      prop,
      refs,
      scope: scope(),
      computed
    });
  };
  const state2 = createBindable(() => ({
    defaultValue: machine8.initialState({ prop }),
    onChange(nextState, prevState) {
      if (prevState) {
        const exitEffects = effects.current.get(prevState);
        exitEffects?.();
        effects.current.delete(prevState);
      }
      if (prevState) {
        action(machine8.states[prevState]?.exit);
      }
      action(transitionRef.current?.actions);
      const cleanup = effect(machine8.states[nextState]?.effects);
      if (cleanup) effects.current.set(nextState, cleanup);
      if (prevState === "__init__") {
        action(machine8.entry);
        const cleanup2 = effect(machine8.effects);
        if (cleanup2) effects.current.set("__init__", cleanup2);
      }
      action(machine8.states[nextState]?.entry);
    }
  }));
  onMount(() => {
    state2.invoke(state2.initial, "__init__");
  });
  onCleanup(() => {
    const fns = effects.current;
    fns.forEach((fn) => fn?.());
    effects.current = /* @__PURE__ */ new Map();
    action(machine8.exit ?? []);
  });
  const send = (event) => {
    previousEventRef.current = eventRef.current;
    eventRef.current = event;
    debug("send", event);
    let currentState = state2.get();
    const transitions = (
      // @ts-ignore
      machine8.states[currentState].on?.[event.type] ?? // @ts-ignore
      machine8.on?.[event.type]
    );
    const transition = choose2(transitions);
    if (!transition) return;
    debug("transition", transition);
    transitionRef.current = transition;
    const target = transition.target ?? currentState;
    const changed = target !== currentState;
    if (changed) {
      state2.set(target);
    } else if (transition.reenter && !changed) {
      state2.invoke(currentState, currentState);
    } else {
      action(transition.actions ?? []);
    }
  };
  machine8.watch?.(getParams());
  return {
    state: getState(),
    send,
    context: ctx,
    prop,
    get scope() {
      return scope();
    },
    refs,
    computed,
    event: getEvent()
  };
}
function flush(fn) {
  fn();
}
function access2(value) {
  return isFunction2(value) ? value() : value;
}
function createProp(value) {
  return function get(key) {
    return value()[key];
  };
}
function mergeProps22(...sources) {
  const target = {};
  for (let i = 0; i < sources.length; i++) {
    let source = sources[i];
    if (typeof source === "function") source = source();
    if (source) {
      const descriptors = Object.getOwnPropertyDescriptors(source);
      for (const key in descriptors) {
        if (key in target) continue;
        Object.defineProperty(target, key, {
          enumerable: true,
          get() {
            let e = {};
            if (key === "style" || key === "class" || key === "className" || key.startsWith("on")) {
              for (let i2 = 0; i2 < sources.length; i2++) {
                let s = sources[i2];
                if (typeof s === "function") s = s();
                e = mergeProps2(e, { [key]: (s || {})[key] });
              }
              return e[key];
            }
            for (let i2 = sources.length - 1; i2 >= 0; i2--) {
              let v, s = sources[i2];
              if (typeof s === "function") s = s();
              v = (s || {})[key];
              if (v !== void 0) return v;
            }
          }
        });
      }
    }
  }
  return target;
}
var eventMap = {
  onFocus: "onFocusIn",
  onBlur: "onFocusOut",
  onDoubleClick: "onDblClick",
  onChange: "onInput",
  defaultChecked: "checked",
  defaultValue: "value",
  htmlFor: "for",
  className: "class"
};
var format = (v) => v.startsWith("--") ? v : hyphenateStyleName(v);
function toSolidProp(prop) {
  return prop in eventMap ? eventMap[prop] : prop;
}
var normalizeProps = createNormalizer((props7) => {
  const normalized = {};
  for (const key in props7) {
    const value = props7[key];
    if (key === "readOnly" && value === false) {
      continue;
    }
    if (key === "style" && isObject3(value)) {
      normalized["style"] = cssify(value);
      continue;
    }
    if (key === "children") {
      if (isString(value)) {
        normalized["textContent"] = value;
      }
      continue;
    }
    normalized[toSolidProp(key)] = value;
  }
  return normalized;
});
function cssify(style2) {
  let css3 = {};
  for (const property in style2) {
    const value = style2[property];
    if (!isString(value) && !isNumber(value)) continue;
    css3[format(property)] = value;
  }
  return css3;
}
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
function toHyphenLower(match2) {
  return "-" + match2.toLowerCase();
}
var cache = {};
function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) return cache[name];
  var hName = name.replace(uppercasePattern, toHyphenLower);
  return cache[name] = msPattern.test(hName) ? "-" + hName : hName;
}

// ../../../node_modules/@ark-ui/solid/dist/chunk/EPLBB4QN.js
var withAsProp = (Component) => {
  const ArkComponent = (props7) => {
    const [localProps, parentProps] = splitProps(props7, ["asChild"]);
    if (localProps.asChild) {
      const propsFn = (userProps) => {
        const [, restProps] = splitProps(parentProps, ["ref"]);
        return mergeProps22(restProps, userProps);
      };
      return localProps.asChild(propsFn);
    }
    return createComponent(Dynamic, mergeProps({
      component: Component
    }, parentProps));
  };
  return ArkComponent;
};
function jsxFactory() {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(withAsProp, {
    apply(_target, _thisArg, argArray) {
      return withAsProp(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache2.has(asElement)) {
        cache2.set(asElement, withAsProp(asElement));
      }
      return cache2.get(asElement);
    }
  });
}
var ark = jsxFactory();

// ../../../node_modules/@ark-ui/solid/dist/chunk/TROPIN4C.js
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext2(options2 = {}) {
  const { strict = true, hookName = "useContext", providerName = "Provider", errorMessage, defaultValue } = options2;
  const Context = createContext(defaultValue);
  function useContext$1() {
    const context = useContext(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error.name = "ContextError";
      Error.captureStackTrace?.(error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// ../../../node_modules/@ark-ui/solid/dist/chunk/6MQ6S5JP.js
var isFunction3 = (value) => typeof value === "function";
var runIfFn2 = (valueOrFn, ...args) => isFunction3(valueOrFn) ? valueOrFn(...args) : valueOrFn;
var [EnvironmentContextProvider, useEnvironmentContext] = createContext2({
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: () => ({
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  })
});
var _tmpl$ = /* @__PURE__ */ template(`<span hidden>`);
var EnvironmentProvider = (props7) => {
  const [spanRef, setSpanRef] = createSignal();
  const getRootNode = () => runIfFn2(props7.value) ?? spanRef()?.ownerDocument ?? document;
  const environment = createMemo(() => ({
    getRootNode,
    getDocument: () => getDocument(getRootNode()),
    getWindow: () => getWindow(getRootNode())
  }));
  return createComponent(EnvironmentContextProvider, {
    value: environment,
    get children() {
      return [createMemo(() => props7.children), createComponent(Show, {
        get when() {
          return !props7.value;
        },
        get children() {
          var _el$ = _tmpl$();
          use(setSpanRef, _el$);
          return _el$;
        }
      })];
    }
  });
};

// ../../../node_modules/@ark-ui/solid/dist/chunk/QEMQBM6W.js
var [LocaleContextProvider, useLocaleContext] = createContext2({
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: () => ({ dir: "ltr", locale: "en-US" })
});

// ../../../node_modules/@ark-ui/solid/dist/chunk/ESLJRKWD.js
var __defProp2 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};

// ../../../node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts9 = []) => ({
  parts: (...values) => {
    if (isEmpty2(parts9)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts9, ...values]),
  rename: (newName) => createAnatomy(newName, parts9),
  keys: () => parts9,
  build: () => [...new Set(parts9)].reduce(
    (prev, part) => Object.assign(prev, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty2 = (v) => v.length === 0;

// ../../../node_modules/@ark-ui/solid/dist/chunk/QFAL6GWC.js
var [RenderStrategyProvider, useRenderStrategyContext] = createContext2({
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyProvider />"
});
var splitRenderStrategyProps = (props7) => createSplitProps()(props7, ["lazyMount", "unmountOnExit"]);

// ../../../node_modules/@zag-js/presence/node_modules/@zag-js/core/dist/index.mjs
function createMachine(config) {
  return config;
}

// ../../../node_modules/@zag-js/presence/dist/index.mjs
function connect(service, _normalize) {
  const { state: state2, send, context } = service;
  const present = state2.matches("mounted", "unmountSuspended");
  return {
    skip: !context.get("initial"),
    present,
    setNode(node) {
      if (!node) return;
      send({ type: "NODE.SET", node });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
var machine = createMachine({
  props({ props: props22 }) {
    return { ...props22, present: !!props22.present };
  },
  initialState({ prop }) {
    return prop("present") ? "mounted" : "unmounted";
  },
  refs() {
    return {
      node: null,
      styles: null
    };
  },
  context({ bindable }) {
    return {
      unmountAnimationName: bindable(() => ({ defaultValue: null })),
      prevAnimationName: bindable(() => ({ defaultValue: null })),
      present: bindable(() => ({ defaultValue: false })),
      initial: bindable(() => ({
        sync: true,
        defaultValue: false
      }))
    };
  },
  exit: ["clearInitial", "cleanupNode"],
  watch({ track, action, prop }) {
    track([() => prop("present")], () => {
      action(["setInitial", "syncPresence"]);
    });
  },
  on: {
    "NODE.SET": {
      actions: ["setNode", "setStyles"]
    }
  },
  states: {
    mounted: {
      on: {
        UNMOUNT: {
          target: "unmounted",
          actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
        },
        "UNMOUNT.SUSPEND": {
          target: "unmountSuspended"
        }
      }
    },
    unmountSuspended: {
      effects: ["trackAnimationEvents"],
      on: {
        MOUNT: {
          target: "mounted",
          actions: ["setPrevAnimationName"]
        },
        UNMOUNT: {
          target: "unmounted",
          actions: ["clearPrevAnimationName", "invokeOnExitComplete"]
        }
      }
    },
    unmounted: {
      on: {
        MOUNT: {
          target: "mounted",
          actions: ["setPrevAnimationName"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setInitial: ({ context }) => {
        if (context.get("initial")) return;
        queueMicrotask(() => {
          context.set("initial", true);
        });
      },
      clearInitial: ({ context }) => {
        context.set("initial", false);
      },
      cleanupNode: ({ refs }) => {
        refs.set("node", null);
        refs.set("styles", null);
      },
      invokeOnExitComplete: ({ prop }) => {
        prop("onExitComplete")?.();
      },
      setNode: ({ refs, event }) => {
        refs.set("node", event.node);
      },
      setStyles: ({ refs, event }) => {
        refs.set("styles", getComputedStyle2(event.node));
      },
      syncPresence: ({ context, refs, send, prop }) => {
        const presentProp = prop("present");
        if (presentProp) {
          return send({ type: "MOUNT", src: "presence.changed" });
        }
        const node = refs.get("node");
        if (!presentProp && node?.ownerDocument.visibilityState === "hidden") {
          return send({ type: "UNMOUNT", src: "visibilitychange" });
        }
        raf(() => {
          const animationName = getAnimationName(refs.get("styles"));
          context.set("unmountAnimationName", animationName);
          if (animationName === "none" || animationName === context.get("prevAnimationName") || refs.get("styles")?.display === "none" || refs.get("styles")?.animationDuration === "0s") {
            send({ type: "UNMOUNT", src: "presence.changed" });
          } else {
            send({ type: "UNMOUNT.SUSPEND" });
          }
        });
      },
      setPrevAnimationName: ({ context, refs }) => {
        raf(() => {
          context.set("prevAnimationName", getAnimationName(refs.get("styles")));
        });
      },
      clearPrevAnimationName: ({ context }) => {
        context.set("prevAnimationName", null);
      }
    },
    effects: {
      trackAnimationEvents: ({ context, refs, send }) => {
        const node = refs.get("node");
        if (!node) return;
        const onStart = (event) => {
          const target = event.composedPath?.()?.[0] ?? event.target;
          if (target === node) {
            context.set("prevAnimationName", getAnimationName(refs.get("styles")));
          }
        };
        const onEnd = (event) => {
          const animationName = getAnimationName(refs.get("styles"));
          const target = getEventTarget(event);
          if (target === node && animationName === context.get("unmountAnimationName")) {
            send({ type: "UNMOUNT", src: "animationend" });
          }
        };
        node.addEventListener("animationstart", onStart);
        node.addEventListener("animationcancel", onEnd);
        node.addEventListener("animationend", onEnd);
        const cleanupStyles = setStyle(node, { animationFillMode: "forwards" });
        return () => {
          node.removeEventListener("animationstart", onStart);
          node.removeEventListener("animationcancel", onEnd);
          node.removeEventListener("animationend", onEnd);
          nextTick(() => cleanupStyles());
        };
      }
    }
  }
});
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
var props = createProps2()(["onExitComplete", "present", "immediate"]);

// ../../../node_modules/@ark-ui/solid/dist/chunk/WRLQ7Y6E.js
var splitPresenceProps = (props7) => createSplitProps()(props7, ["immediate", "lazyMount", "onExitComplete", "present", "unmountOnExit"]);
var usePresence = (props7) => {
  const [renderStrategyProps, context] = splitRenderStrategyProps(props7);
  const [wasEverPresent, setWasEverPresent] = createSignal(false);
  const service = useMachine(machine, props7);
  const api = createMemo(() => connect(service, normalizeProps));
  createEffect(() => {
    const present = api().present;
    if (present) setWasEverPresent(true);
  });
  return createMemo(() => ({
    unmounted: !api().present && !wasEverPresent() && renderStrategyProps.lazyMount || renderStrategyProps.unmountOnExit && !api().present && wasEverPresent(),
    present: api().present,
    presenceProps: {
      ref: api().setNode,
      hidden: !api().present,
      "data-state": context.present ? "open" : "closed"
    }
  }));
};
var [PresenceProvider, usePresenceContext] = createContext2({
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});

// ../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var min2 = Math.min;
var max2 = Math.max;
var round2 = Math.round;
var floor2 = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max2(start, min2(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// ../../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset: reset2
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset2 && resetCount <= 50) {
      resetCount++;
      if (typeof reset2 === "object") {
        if (reset2.placement) {
          statefulPlacement = reset2.placement;
        }
        if (reset2.rects) {
          rects = reset2.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset2.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements: elements2,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements2[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements2.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements2.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: elements2,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options2) => ({
  name: "arrow",
  options: options2,
  async fn(state2) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements: elements2,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options2, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements2.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min2(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min2(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max4 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max4);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max4 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "flip",
    options: options2,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements: elements2
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options2, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex2];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex2,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "hide",
    options: options2,
    async fn(state2) {
      const {
        rects
      } = state2;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options2, state2);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state2, options2) {
  const {
    placement,
    platform: platform2,
    elements: elements2
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options2) {
  if (options2 === void 0) {
    options2 = 0;
  }
  return {
    name: "offset",
    options: options2,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options2);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "shift",
    options: options2,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options2, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min4 = mainAxisCoord + overflow[minSide];
        const max4 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min4, mainAxisCoord, max4);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min4 = crossAxisCoord + overflow[minSide];
        const max4 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min4, crossAxisCoord, max4);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    options: options2,
    fn(state2) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset3 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options2, state2);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset3, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "size",
    options: options2,
    async fn(state2) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements: elements2
      } = state2;
      const {
        apply: apply2 = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options2, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements2.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min2(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min2(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max2(overflow.left, 0);
        const xMax = max2(overflow.right, 0);
        const yMin = max2(overflow.top, 0);
        const yMax = max2(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max2(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max2(overflow.top, overflow.bottom));
        }
      }
      await apply2({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements2.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// ../../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName2(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow2(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow2(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow2(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow2(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow2(value).ShadowRoot;
}
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle3(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css3 = isElement(elementOrCss) ? getComputedStyle3(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css3[value] ? css3[value] !== "none" : false) || (css3.containerType ? css3.containerType !== "normal" : false) || !webkit && (css3.backdropFilter ? css3.backdropFilter !== "none" : false) || !webkit && (css3.filter ? css3.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css3.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css3.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName2(node));
}
function getComputedStyle3(element) {
  return getWindow2(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode2(node) {
  if (getNodeName2(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot2(node) && node.host || // Fallback.
    getDocumentElement2(node)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow2(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css3 = getComputedStyle3(element);
  let width = parseFloat(css3.width) || 0;
  let height = parseFloat(css3.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round2(rect.width) : rect.width) / width;
  let y = ($ ? round2(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow2(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow2(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow2(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow2(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css3 = getComputedStyle3(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css3.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css3.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow2(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement2(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements: elements2,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements2 ? isTopLayer(elements2.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html2 = getDocumentElement2(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle3(body).direction === "rtl") {
    x += max2(html2.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow2(element);
  const html2 = getDocumentElement2(element);
  const visualViewport = win.visualViewport;
  let width = html2.clientWidth;
  let height = html2.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement2(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle3(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle3(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle3(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle3(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle3(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement2(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow2(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle3(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement2,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor2(top);
    const insetRight = floor2(root.clientWidth - (left + width));
    const insetBottom = floor2(root.clientHeight - (top + height));
    const insetLeft = floor2(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max2(0, min2(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries2) {
      const ratio = entries2[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options2) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options2
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../../../node_modules/@zag-js/popper/dist/index.mjs
function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect) return createDOMRect();
  const { x, y, width, height } = anchorRect;
  return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect?.(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow22) => ({
  top: "bottom center",
  "top-start": arrow22 ? `${arrow22.x}px bottom` : "left bottom",
  "top-end": arrow22 ? `${arrow22.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow22 ? `${arrow22.x}px top` : "top left",
  "bottom-end": arrow22 ? `${arrow22.x}px top` : "top right",
  left: "right center",
  "left-start": arrow22 ? `right ${arrow22.y}px` : "right top",
  "left-end": arrow22 ? `right ${arrow22.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow22 ? `left ${arrow22.y}px` : "left top",
  "right-end": arrow22 ? `left ${arrow22.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements: elements2, middlewareData }) {
    const { arrow: arrow22 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow22)[placement];
    const { floating } = elements2;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl) return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow) return {};
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide(placement) {
  return placement.split("-")[0];
}
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement) return;
  return arrow2({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter)) return;
  return offset2(({ placement }) => {
    const arrowOffset = (arrowElement?.clientHeight || 0) / 2;
    const gutter = opts.offset?.mainAxis ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift22 = !hasAlign ? opts.shift : void 0;
    const crossAxis = opts.offset?.crossAxis ?? shift22;
    return compact({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip) return;
  return flip2({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap) return;
  return shift2({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift2()
  });
}
function getSizeMiddleware(opts) {
  return size2({
    padding: opts.overflowPadding,
    apply({ elements: elements2, rects, availableHeight, availableWidth }) {
      const floating = elements2.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function hideWhenDetachedMiddleware(opts) {
  if (!opts.hideWhenDetached) return;
  return hide2({ strategy: "referenceHidden", boundary: opts.boundary?.() ?? "clippingAncestors" });
}
function getAutoUpdateOptions(opts) {
  if (!opts) return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference) return;
  const options2 = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [
    getOffsetMiddleware(arrowEl, options2),
    getFlipMiddleware(options2),
    getShiftMiddleware(options2),
    getArrowMiddleware(arrowEl, options2),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options2),
    hideWhenDetachedMiddleware(options2),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options2;
  const updatePosition = async () => {
    if (!reference || !floating) return;
    const pos = await computePosition2(reference, floating, {
      placement,
      middleware,
      strategy
    });
    onComplete?.(pos);
    onPositioned?.({ placed: true });
    const win = getWindow(floating);
    const x = roundByDpr(win, pos.x);
    const y = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x}px`);
    floating.style.setProperty("--y", `${y}px`);
    if (options2.hideWhenDetached) {
      const isHidden = pos.middlewareData.hide?.referenceHidden;
      if (isHidden) {
        floating.style.setProperty("visibility", "hidden");
        floating.style.setProperty("pointer-events", "none");
      } else {
        floating.style.removeProperty("visibility");
        floating.style.removeProperty("pointer-events");
      }
    }
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const styles = getComputedStyle2(contentEl);
      floating.style.setProperty("--z-index", styles.zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned?.({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options2.listeners);
  const cancelAutoUpdate = options2.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop;
  update();
  return () => {
    cancelAutoUpdate?.();
    onPositioned?.({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options2 } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups2.push(getPlacementImpl(reference, floating, options2));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options2 = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options2;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      // @ts-expect-error - Fix this
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}

// ../../../node_modules/@zag-js/interact-outside/dist/index.mjs
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      for (let i = 0; i < win.frames?.length; i += 1) {
        const frame = win.frames[i];
        if (frame) cb(frame);
      }
    },
    addEventListener(event, listener, options2) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options2);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options2);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options2) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options2);
        } catch {
        }
      });
    }
  };
  return frames;
}
function getParentWindow(win) {
  const parent2 = win.frameElement != null ? win.parent : null;
  return {
    addEventListener: (event, listener, options2) => {
      try {
        parent2?.addEventListener(event, listener, options2);
      } catch {
      }
      return () => {
        try {
          parent2?.removeEventListener(event, listener, options2);
        } catch {
        }
      };
    },
    removeEventListener: (event, listener, options2) => {
      try {
        parent2?.removeEventListener(event, listener, options2);
      } catch {
      }
    }
  };
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node of composedPath) {
    if (isHTMLElement(node) && isFocusable(node)) return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node, event) {
  if (!isPointerEvent(event) || !node) return false;
  const rect = node.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0) return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isPointInRect(rect, point) {
  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;
}
function isEventWithinScrollbar(event, ancestor) {
  if (!ancestor || !isPointerEvent(event)) return false;
  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;
  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;
  const rect = {
    x: ancestor.offsetLeft,
    y: ancestor.offsetTop,
    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),
    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)
  };
  const point = {
    x: event.clientX,
    y: event.clientY
  };
  if (!isPointInRect(rect, point)) return false;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node, options2) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options2;
  if (!node) return;
  const doc = getDocument(node);
  const win = getWindow(node);
  const frames = getWindowFrames(win);
  const parentWin = getParentWindow(win);
  function isEventOutside(event) {
    const target = getEventTarget(event);
    if (!isHTMLElement(target)) return false;
    if (!target.isConnected) return false;
    if (contains(node, target)) return false;
    if (isEventPointWithin(node, event)) return false;
    const triggerEl = doc.querySelector(`[aria-controls="${node.id}"]`);
    if (triggerEl) {
      const triggerAncestor = getNearestOverflowAncestor(triggerEl);
      if (isEventWithinScrollbar(event, triggerAncestor)) return false;
    }
    const nodeAncestor = getNearestOverflowAncestor(node);
    if (isEventWithinScrollbar(event, nodeAncestor)) return false;
    return !exclude?.(target);
  }
  const pointerdownCleanups = /* @__PURE__ */ new Set();
  function onPointerDown(event) {
    function handler() {
      const func = defer ? raf : (v) => v();
      const composedPath = event.composedPath?.() ?? [event.target];
      func(() => {
        if (!node || !isEventOutside(event)) return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll(onPointerDownOutside, onInteractOutside);
          node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: event,
            contextmenu: isContextMenuEvent(event),
            focusable: isComposedPathFocusable(composedPath)
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      pointerdownCleanups.forEach((fn) => fn());
      pointerdownCleanups.add(addDomEvent(doc, "click", handler, { once: true }));
      pointerdownCleanups.add(parentWin.addEventListener("click", handler, { once: true }));
      pointerdownCleanups.add(frames.addEventListener("click", handler, { once: true }));
    } else {
      handler();
    }
  }
  const cleanups2 = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups2.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
    cleanups2.add(parentWin.addEventListener("pointerdown", onPointerDown, true));
    cleanups2.add(frames.addEventListener("pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf : (v) => v();
    func(() => {
      if (!node || !isEventOutside(event)) return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll(onFocusOutside, onInteractOutside);
        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(getEventTarget(event))
        }
      });
    });
  }
  cleanups2.add(addDomEvent(doc, "focusin", onFocusin, true));
  cleanups2.add(parentWin.addEventListener("focusin", onFocusin, true));
  cleanups2.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    pointerdownCleanups.forEach((fn) => fn());
    cleanups2.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options2) {
  const { defer } = options2;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackInteractOutsideImpl(node, options2));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
function fireCustomEvent(el, type, init) {
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}

// ../../../node_modules/@zag-js/dismissable/dist/index.mjs
function trackEscapeKeydown(node, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape") return;
    if (event.isComposing) return;
    fn?.(event);
  };
  return addDomEvent(getDocument(node), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node) {
    const index = this.indexOf(node);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf(this.topMostPointerBlockingLayer()?.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node) {
    const layer = this.layers[this.count() - 1];
    return layer?.node === node;
  },
  getNestedLayers(node) {
    return Array.from(this.layers).slice(this.indexOf(node) + 1);
  },
  isInNestedLayer(node, target) {
    return this.getNestedLayers(node).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node) {
    this.branches.push(node);
  },
  remove(node) {
    const index = this.indexOf(node);
    if (index < 0) return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node.style.removeProperty("--layer-index");
  },
  removeBranch(node) {
    const index = this.branches.indexOf(node);
    if (index >= 0) this.branches.splice(index, 1);
  },
  indexOf(node) {
    return this.layers.findIndex((layer) => layer.node === node);
  },
  dismiss(node) {
    this.layers[this.indexOf(node)]?.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node }) => {
    node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? "none" : "auto";
  });
}
function clearPointerEvent(node) {
  node.style.pointerEvents = "";
}
function disablePointerEventsOutside(node, persistentElements) {
  const doc = getDocument(node);
  const cleanups2 = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (persistentElements) {
    const persistedCleanup = waitForElements(persistentElements, (el) => {
      cleanups2.push(setStyle(el, { pointerEvents: "auto" }));
    });
    cleanups2.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer()) return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0) doc.body.removeAttribute("style");
    });
    cleanups2.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node, options2) {
  const { warnOnMissingNode = true } = options2;
  if (warnOnMissingNode && !node) {
    warn("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  if (!node) {
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options2;
  const layer = { dismiss: onDismiss, node, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node) || layerStack.isInBranch(target)) return;
    options2.onPointerDownOutside?.(event);
    options2.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onFocusOutside(event) {
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target)) return;
    options2.onFocusOutside?.(event);
    options2.onInteractOutside?.(event);
    if (event.defaultPrevented) return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss?.();
  }
  function onEscapeKeyDown(event) {
    if (!layerStack.isTopMost(node)) return;
    options2.onEscapeKeyDown?.(event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    if (!node) return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = options2.persistentElements?.map((fn) => fn()).filter(isHTMLElement);
    if (persistentElements) _containers.push(...persistentElements);
    return _containers.some((node2) => contains(node2, target)) || layerStack.isInNestedLayer(node, target);
  }
  const cleanups2 = [
    pointerBlocking ? disablePointerEventsOutside(node, options2.persistentElements) : void 0,
    trackEscapeKeydown(node, onEscapeKeyDown),
    trackInteractOutside(node, { exclude, onFocusOutside, onPointerDownOutside, defer: options2.defer })
  ];
  return () => {
    layerStack.remove(node);
    assignPointerEventToLayers();
    clearPointerEvent(node);
    cleanups2.forEach((fn) => fn?.());
  };
}
function trackDismissableElement(nodeOrFn, options2) {
  const { defer } = options2;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackDismissableElementImpl(node, options2));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}
function trackDismissableBranch(nodeOrFn, options2 = {}) {
  const { defer } = options2;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = isFunction2(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node) {
        warn("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node);
      cleanups2.push(() => {
        layerStack.removeBranch(node);
      });
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}

// ../../../node_modules/@zag-js/focus-trap/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var activeFocusTraps = {
  activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      const activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap(trapStack, trap) {
    const trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var sharedTrapStack = [];
var FocusTrap = class {
  constructor(elements2, options2) {
    __publicField(this, "trapStack");
    __publicField(this, "config");
    __publicField(this, "doc");
    __publicField(this, "state", {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0,
      recentNavEvent: void 0
    });
    __publicField(this, "listenerCleanups", []);
    __publicField(this, "handleFocus", (event) => {
      const target = getEventTarget(event);
      const targetContained = this.findContainerIndex(target, event) >= 0;
      if (targetContained || isDocument(target)) {
        if (targetContained) {
          this.state.mostRecentlyFocusedNode = target;
        }
      } else {
        event.stopImmediatePropagation();
        let nextNode;
        let navAcrossContainers = true;
        if (this.state.mostRecentlyFocusedNode) {
          if (getTabIndex(this.state.mostRecentlyFocusedNode) > 0) {
            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);
            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];
            if (tabbableNodes.length > 0) {
              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);
              if (mruTabIdx >= 0) {
                if (this.config.isKeyForward(this.state.recentNavEvent)) {
                  if (mruTabIdx + 1 < tabbableNodes.length) {
                    nextNode = tabbableNodes[mruTabIdx + 1];
                    navAcrossContainers = false;
                  }
                } else {
                  if (mruTabIdx - 1 >= 0) {
                    nextNode = tabbableNodes[mruTabIdx - 1];
                    navAcrossContainers = false;
                  }
                }
              }
            }
          } else {
            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => getTabIndex(n) > 0))) {
              navAcrossContainers = false;
            }
          }
        } else {
          navAcrossContainers = false;
        }
        if (navAcrossContainers) {
          nextNode = this.findNextNavNode({
            // move FROM the MRU node, not event-related node (which will be the node that is
            //  outside the trap causing the focus escape we're trying to fix)
            target: this.state.mostRecentlyFocusedNode,
            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)
          });
        }
        if (nextNode) {
          this.tryFocus(nextNode);
        } else {
          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());
        }
      }
      this.state.recentNavEvent = void 0;
    });
    __publicField(this, "handlePointerDown", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
    });
    __publicField(this, "handleClick", (event) => {
      const target = getEventTarget(event);
      if (this.findContainerIndex(target, event) >= 0) {
        return;
      }
      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {
        return;
      }
      if (valueOrHandler(this.config.allowOutsideClick, event)) {
        return;
      }
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    __publicField(this, "handleTabKey", (event) => {
      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {
        this.state.recentNavEvent = event;
        const isBackward = this.config.isKeyBackward(event);
        const destinationNode = this.findNextNavNode({ event, isBackward });
        if (!destinationNode) return;
        if (isTabEvent(event)) {
          event.preventDefault();
        }
        this.tryFocus(destinationNode);
      }
    });
    __publicField(this, "handleEscapeKey", (event) => {
      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {
        event.preventDefault();
        this.deactivate();
      }
    });
    __publicField(this, "_mutationObserver");
    __publicField(this, "setupMutationObserver", () => {
      const win = this.doc.defaultView || window;
      this._mutationObserver = new win.MutationObserver((mutations) => {
        const isFocusedNodeRemoved = mutations.some((mutation) => {
          const removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);
        });
        if (isFocusedNodeRemoved) {
          this.tryFocus(this.getInitialFocusNode());
        }
      });
    });
    __publicField(this, "updateObservedNodes", () => {
      this._mutationObserver?.disconnect();
      if (this.state.active && !this.state.paused) {
        this.state.containers.map((container) => {
          this._mutationObserver?.observe(container, { subtree: true, childList: true });
        });
      }
    });
    __publicField(this, "getInitialFocusNode", () => {
      let node = this.getNodeForOption("initialFocus", { hasFallback: true });
      if (node === false) {
        return false;
      }
      if (node === void 0 || node && !isFocusable(node)) {
        if (this.findContainerIndex(this.doc.activeElement) >= 0) {
          node = this.doc.activeElement;
        } else {
          const firstTabbableGroup = this.state.tabbableGroups[0];
          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || this.getNodeForOption("fallbackFocus");
        }
      } else if (node === null) {
        node = this.getNodeForOption("fallbackFocus");
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      if (!node.isConnected) {
        node = this.getNodeForOption("fallbackFocus");
      }
      return node;
    });
    __publicField(this, "tryFocus", (node) => {
      if (node === false) return;
      if (node === getActiveElement(this.doc)) return;
      if (!node || !node.focus) {
        this.tryFocus(this.getInitialFocusNode());
        return;
      }
      node.focus({ preventScroll: !!this.config.preventScroll });
      this.state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    });
    __publicField(this, "deactivate", (deactivateOptions) => {
      if (!this.state.active) return this;
      const options3 = {
        onDeactivate: this.config.onDeactivate,
        onPostDeactivate: this.config.onPostDeactivate,
        checkCanReturnFocus: this.config.checkCanReturnFocus,
        ...deactivateOptions
      };
      clearTimeout(this.state.delayInitialFocusTimer);
      this.state.delayInitialFocusTimer = void 0;
      this.removeListeners();
      this.state.active = false;
      this.state.paused = false;
      this.updateObservedNodes();
      activeFocusTraps.deactivateTrap(this.trapStack, this);
      const onDeactivate = this.getOption(options3, "onDeactivate");
      const onPostDeactivate = this.getOption(options3, "onPostDeactivate");
      const checkCanReturnFocus = this.getOption(options3, "checkCanReturnFocus");
      const returnFocus = this.getOption(options3, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate?.();
      const finishDeactivation = () => {
        delay2(() => {
          if (returnFocus) {
            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
            this.tryFocus(returnFocusNode);
          }
          onPostDeactivate?.();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);
        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    });
    __publicField(this, "pause", (pauseOptions) => {
      if (this.state.paused || !this.state.active) {
        return this;
      }
      const onPause = this.getOption(pauseOptions, "onPause");
      const onPostPause = this.getOption(pauseOptions, "onPostPause");
      this.state.paused = true;
      onPause?.();
      this.removeListeners();
      this.updateObservedNodes();
      onPostPause?.();
      return this;
    });
    __publicField(this, "unpause", (unpauseOptions) => {
      if (!this.state.paused || !this.state.active) {
        return this;
      }
      const onUnpause = this.getOption(unpauseOptions, "onUnpause");
      const onPostUnpause = this.getOption(unpauseOptions, "onPostUnpause");
      this.state.paused = false;
      onUnpause?.();
      this.updateTabbableNodes();
      this.addListeners();
      this.updateObservedNodes();
      onPostUnpause?.();
      return this;
    });
    __publicField(this, "updateContainerElements", (containerElements) => {
      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);
      if (this.state.active) {
        this.updateTabbableNodes();
      }
      this.updateObservedNodes();
      return this;
    });
    __publicField(this, "getReturnFocusNode", (previousActiveElement) => {
      const node = this.getNodeForOption("setReturnFocus", {
        params: [previousActiveElement]
      });
      return node ? node : node === false ? false : previousActiveElement;
    });
    __publicField(this, "getOption", (configOverrideOptions, optionName, configOptionName) => {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (
        // @ts-expect-error
        this.config[configOptionName || optionName]
      );
    });
    __publicField(this, "getNodeForOption", (optionName, { hasFallback = false, params = [] } = {}) => {
      let optionValue = this.config[optionName];
      if (typeof optionValue === "function") optionValue = optionValue(...params);
      if (optionValue === true) optionValue = void 0;
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error(`\`${optionName}\` was specified but was not a node, or did not return a node`);
      }
      let node = optionValue;
      if (typeof optionValue === "string") {
        try {
          node = this.doc.querySelector(optionValue);
        } catch (err) {
          throw new Error(`\`${optionName}\` appears to be an invalid selector; error="${err.message}"`);
        }
        if (!node) {
          if (!hasFallback) {
            throw new Error(`\`${optionName}\` as selector refers to no known node`);
          }
        }
      }
      return node;
    });
    __publicField(this, "findNextNavNode", (opts) => {
      const { event, isBackward = false } = opts;
      const target = opts.target || getEventTarget(event);
      this.updateTabbableNodes();
      let destinationNode = null;
      if (this.state.tabbableGroups.length > 0) {
        const containerIndex = this.findContainerIndex(target, event);
        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (isBackward) {
            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (isBackward) {
          let startOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ firstTabbableNode }) => target === firstTabbableNode
          );
          if (startOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target, false);
          }
        } else {
          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(
            ({ lastTabbableNode }) => target === lastTabbableNode
          );
          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || isFocusable(target) && !isTabbable(target) && !containerGroup?.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];
            destinationNode = getTabIndex(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;
          } else if (!isTabEvent(event)) {
            destinationNode = containerGroup?.nextTabbableNode(target);
          }
        }
      } else {
        destinationNode = this.getNodeForOption("fallbackFocus");
      }
      return destinationNode;
    });
    this.trapStack = options2.trapStack || sharedTrapStack;
    const config = {
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true,
      isKeyForward(e) {
        return isTabEvent(e) && !e.shiftKey;
      },
      isKeyBackward(e) {
        return isTabEvent(e) && e.shiftKey;
      },
      ...options2
    };
    this.doc = config.document || getDocument(Array.isArray(elements2) ? elements2[0] : elements2);
    this.config = config;
    this.updateContainerElements(elements2);
    this.setupMutationObserver();
  }
  get active() {
    return this.state.active;
  }
  get paused() {
    return this.state.paused;
  }
  findContainerIndex(element, event) {
    const composedPath = typeof event?.composedPath === "function" ? event.composedPath() : void 0;
    return this.state.containerGroups.findIndex(
      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node) => node === element)
    );
  }
  updateTabbableNodes() {
    this.state.containerGroups = this.state.containers.map((container) => {
      const tabbableNodes = getTabbables(container);
      const focusableNodes = getFocusables(container);
      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      const firstDomTabbableNode = focusableNodes.find((node) => isTabbable(node));
      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => isTabbable(node));
      const posTabIndexesFound = !!tabbableNodes.find((node) => getTabIndex(node) > 0);
      function nextTabbableNode(node, forward = true) {
        const nodeIdx = tabbableNodes.indexOf(node);
        if (nodeIdx < 0) {
          if (forward) {
            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => isTabbable(el));
          }
          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => isTabbable(el));
        }
        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
      }
      return {
        container,
        tabbableNodes,
        focusableNodes,
        posTabIndexesFound,
        firstTabbableNode,
        lastTabbableNode,
        firstDomTabbableNode,
        lastDomTabbableNode,
        nextTabbableNode
      };
    });
    this.state.tabbableGroups = this.state.containerGroups.filter((group2) => group2.tabbableNodes.length > 0);
    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption("fallbackFocus")) {
      throw new Error(
        "Your focus-trap must have at least one container with at least one tabbable node in it at all times"
      );
    }
    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {
      throw new Error(
        "At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps."
      );
    }
  }
  addListeners() {
    if (!this.state.active) return;
    activeFocusTraps.activateTrap(this.trapStack, this);
    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay2(() => {
      this.tryFocus(this.getInitialFocusNode());
    }) : this.tryFocus(this.getInitialFocusNode());
    this.listenerCleanups.push(
      addDomEvent(this.doc, "focusin", this.handleFocus, true),
      addDomEvent(this.doc, "mousedown", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "touchstart", this.handlePointerDown, { capture: true, passive: false }),
      addDomEvent(this.doc, "click", this.handleClick, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleTabKey, { capture: true, passive: false }),
      addDomEvent(this.doc, "keydown", this.handleEscapeKey)
    );
    return this;
  }
  removeListeners() {
    if (!this.state.active) return;
    this.listenerCleanups.forEach((cleanup) => cleanup());
    this.listenerCleanups = [];
    return this;
  }
  activate(activateOptions) {
    if (this.state.active) {
      return this;
    }
    const onActivate = this.getOption(activateOptions, "onActivate");
    const onPostActivate = this.getOption(activateOptions, "onPostActivate");
    const checkCanFocusTrap = this.getOption(activateOptions, "checkCanFocusTrap");
    if (!checkCanFocusTrap) {
      this.updateTabbableNodes();
    }
    this.state.active = true;
    this.state.paused = false;
    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;
    onActivate?.();
    const finishActivation = () => {
      if (checkCanFocusTrap) {
        this.updateTabbableNodes();
      }
      this.addListeners();
      this.updateObservedNodes();
      onPostActivate?.();
    };
    if (checkCanFocusTrap) {
      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);
      return this;
    }
    finishActivation();
    return this;
  }
};
var isTabEvent = (event) => event.key === "Tab";
var valueOrHandler = (value, ...params) => typeof value === "function" ? value(...params) : value;
var isEscapeEvent = (event) => !event.isComposing && event.key === "Escape";
var delay2 = (fn) => setTimeout(fn, 0);
var isSelectableInput = (node) => node.localName === "input" && "select" in node && typeof node.select === "function";
function trapFocus(el, options2 = {}) {
  let trap;
  const cleanup = raf(() => {
    const contentEl = typeof el === "function" ? el() : el;
    if (!contentEl) return;
    trap = new FocusTrap(contentEl, {
      escapeDeactivates: false,
      allowOutsideClick: true,
      preventScroll: true,
      returnFocusOnDeactivate: true,
      delayInitialFocus: false,
      fallbackFocus: contentEl,
      ...options2,
      document: getDocument(contentEl)
    });
    try {
      trap.activate();
    } catch {
    }
  });
  return function destroy() {
    trap?.deactivate();
    cleanup();
  };
}

// ../../../node_modules/@ark-ui/solid/dist/chunk/MZD7ZKWI.js
var [FieldsetProvider, useFieldsetContext] = createContext2({
  hookName: "useFieldsetContext",
  providerName: "<FieldsetProvider />",
  strict: false
});
var FieldsetContext = (props7) => props7.children(useFieldsetContext());
var FieldsetErrorText = (props7) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps22(() => fieldset().getErrorTextProps(), props7);
  return createComponent(Show, {
    get when() {
      return fieldset().invalid;
    },
    get children() {
      return createComponent(ark.span, mergedProps);
    }
  });
};
var FieldsetHelperText = (props7) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps22(() => fieldset().getHelperTextProps(), props7);
  return createComponent(ark.span, mergedProps);
};
var FieldsetLegend = (props7) => {
  const fieldset = useFieldsetContext();
  const mergedProps = mergeProps22(() => fieldset().getLegendProps(), props7);
  return createComponent(ark.legend, mergedProps);
};
var fieldsetAnatomy = createAnatomy("fieldset").parts("root", "errorText", "helperText", "legend");
var parts = fieldsetAnatomy.build();
var useFieldset = (props7) => {
  const { disabled = false, invalid = false } = props7;
  let rootRef;
  const id = props7.id ?? createUniqueId();
  const errorTextId = `fieldset::${id}::error-text`;
  const helperTextId = `fieldset::${id}::helper-text`;
  const [hasErrorText, setHasErrorText] = createSignal(false);
  const [hasHelperText, setHasHelperText] = createSignal(false);
  createEffect(() => {
    return;
  });
  const labelIds = [];
  if (hasErrorText() && invalid) labelIds.push(errorTextId);
  if (hasHelperText()) labelIds.push(helperTextId);
  const getRootProps = () => ({
    ...parts.root.attrs,
    disabled,
    "data-disabled": dataAttr2(disabled),
    "data-invalid": dataAttr2(invalid),
    "aria-describedby": labelIds.join(" ") || void 0
  });
  const getLegendProps = () => ({
    ...parts.legend.attrs,
    "data-disabled": dataAttr2(disabled),
    "data-invalid": dataAttr2(invalid)
  });
  const getHelperTextProps = () => ({
    id: helperTextId,
    ...parts.helperText.attrs
  });
  const getErrorTextProps = () => ({
    id: errorTextId,
    ...parts.errorText.attrs,
    "aria-live": "polite"
  });
  return createMemo(() => ({
    refs: {
      rootRef
    },
    disabled,
    invalid,
    getRootProps,
    getLegendProps,
    getHelperTextProps,
    getErrorTextProps
  }));
};
var dataAttr2 = (condition) => condition ? "" : void 0;
var FieldsetRoot = (props7) => {
  const [useFieldsetProps, localProps] = createSplitProps()(props7, ["id", "disabled", "invalid"]);
  const fieldset = useFieldset(useFieldsetProps);
  const mergedProps = mergeProps22(() => fieldset().getRootProps(), localProps);
  return createComponent(FieldsetProvider, {
    value: fieldset,
    get children() {
      return createComponent(ark.fieldset, mergedProps);
    }
  });
};
FieldsetRoot.displayName = "FieldsetRoot";
var FieldsetRootProvider = (props7) => {
  const [{
    value: fieldset
  }, localProps] = createSplitProps()(props7, ["value"]);
  const mergedProps = mergeProps22(() => fieldset().getRootProps(), localProps);
  return createComponent(FieldsetProvider, {
    value: fieldset,
    get children() {
      return createComponent(ark.fieldset, mergedProps);
    }
  });
};
var fieldset_exports = {};
__export2(fieldset_exports, {
  Context: () => FieldsetContext,
  ErrorText: () => FieldsetErrorText,
  HelperText: () => FieldsetHelperText,
  Legend: () => FieldsetLegend,
  Root: () => FieldsetRoot,
  RootProvider: () => FieldsetRootProvider
});

// ../../../node_modules/@ark-ui/solid/dist/chunk/XN6EERRM.js
var isRefFn = (ref) => typeof ref === "function";
function setRef(ref, value) {
  if (isRefFn(ref)) {
    ref(value);
  }
}
function composeRefs(...refs) {
  return (node) => {
    for (const ref of refs) {
      setRef(ref, node);
    }
  };
}

// ../../../node_modules/@zag-js/auto-resize/dist/index.mjs
var autoresizeTextarea = (el) => {
  if (!el) return;
  const style2 = getComputedStyle2(el);
  const win = getWindow(el);
  const doc = getDocument(el);
  const resize = () => {
    requestAnimationFrame(() => {
      el.style.height = "auto";
      let newHeight;
      if (style2.boxSizing === "content-box") {
        newHeight = el.scrollHeight - (parseFloat(style2.paddingTop) + parseFloat(style2.paddingBottom));
      } else {
        newHeight = el.scrollHeight + parseFloat(style2.borderTopWidth) + parseFloat(style2.borderBottomWidth);
      }
      if (style2.maxHeight !== "none" && newHeight > parseFloat(style2.maxHeight)) {
        if (style2.overflowY === "hidden") {
          el.style.overflowY = "scroll";
        }
        newHeight = parseFloat(style2.maxHeight);
      } else if (style2.overflowY !== "hidden") {
        el.style.overflowY = "hidden";
      }
      el.style.height = `${newHeight}px`;
    });
  };
  el.addEventListener("input", resize);
  el.form?.addEventListener("reset", resize);
  const elementPrototype = Object.getPrototypeOf(el);
  const descriptor = Object.getOwnPropertyDescriptor(elementPrototype, "value");
  Object.defineProperty(el, "value", {
    ...descriptor,
    set() {
      descriptor?.set?.apply(this, arguments);
      resize();
    }
  });
  const resizeObserver = new win.ResizeObserver(() => {
    requestAnimationFrame(() => resize());
  });
  resizeObserver.observe(el);
  const attrObserver = new win.MutationObserver(() => resize());
  attrObserver.observe(el, { attributes: true, attributeFilter: ["rows", "placeholder"] });
  doc.fonts?.addEventListener("loadingdone", resize);
  return () => {
    el.removeEventListener("input", resize);
    el.form?.removeEventListener("reset", resize);
    doc.fonts?.removeEventListener("loadingdone", resize);
    resizeObserver.disconnect();
    attrObserver.disconnect();
  };
};

// ../../../node_modules/@ark-ui/solid/dist/chunk/KMFRZGLF.js
var [FieldProvider, useFieldContext] = createContext2({
  hookName: "useFieldContext",
  providerName: "<FieldProvider />",
  strict: false
});
var FieldContext = (props7) => props7.children(useFieldContext());
var FieldErrorText = (props7) => {
  const field = useFieldContext();
  const mergedProps = mergeProps22(() => field().getErrorTextProps(), props7);
  return createComponent(Show, {
    get when() {
      return field?.().invalid;
    },
    get children() {
      return createComponent(ark.span, mergedProps);
    }
  });
};
var FieldHelperText = (props7) => {
  const field = useFieldContext();
  const mergedProps = mergeProps22(() => field().getHelperTextProps(), props7);
  return createComponent(ark.span, mergedProps);
};
var FieldInput = (props7) => {
  const field = useFieldContext();
  const mergedProps = mergeProps22(() => field?.().getInputProps(), props7);
  return createComponent(ark.input, mergedProps);
};
var FieldLabel = (props7) => {
  const field = useFieldContext();
  const mergedProps = mergeProps22(() => field?.().getLabelProps(), props7);
  return createComponent(ark.label, mergedProps);
};
var FieldRequiredIndicator = (props7) => {
  const field = useFieldContext();
  const mergedProps = mergeProps22(() => field().getRequiredIndicatorProps(), props7);
  return createComponent(Show, {
    get when() {
      return field().required;
    },
    get fallback() {
      return props7.fallback;
    },
    get children() {
      return createComponent(ark.span, mergeProps(mergedProps, {
        get children() {
          return props7.children ?? "*";
        }
      }));
    }
  });
};
var fieldAnatomy = createAnatomy("field").parts(
  "root",
  "errorText",
  "helperText",
  "input",
  "label",
  "select",
  "textarea",
  "requiredIndicator"
);
var parts2 = fieldAnatomy.build();
var useField = (props7) => {
  const fieldset = useFieldsetContext();
  const fieldProps = mergeProps(
    { disabled: Boolean(fieldset?.().disabled), required: false, invalid: false, readOnly: false },
    props7
  );
  const [hasErrorText, setHasErrorText] = createSignal(false);
  const [hasHelperText, setHasHelperText] = createSignal(false);
  const id = fieldProps.id ?? createUniqueId();
  const [rootRef, setRootRef] = createSignal(void 0);
  const rootId = fieldProps.ids?.control ?? `field::${id}`;
  const errorTextId = fieldProps.ids?.errorText ?? `field::${id}::error-text`;
  const helperTextId = fieldProps.ids?.helperText ?? `field::${id}::helper-text`;
  const labelId = fieldProps.ids?.label ?? `field::${id}::label`;
  onMount(() => {
    const rootNode = rootRef();
    if (!rootNode) return;
    const win = getWindow(rootNode);
    const doc = win.document;
    const checkTextElements = () => {
      setHasErrorText(!!doc.getElementById(errorTextId));
      setHasHelperText(!!doc.getElementById(helperTextId));
    };
    checkTextElements();
    const observer = new win.MutationObserver(checkTextElements);
    observer.observe(rootNode, { childList: true, subtree: true });
    onCleanup(() => observer.disconnect());
  });
  const getRootProps = () => ({
    ...parts2.root.attrs,
    id: rootId,
    role: "group",
    "data-disabled": dataAttr(fieldProps.disabled),
    "data-invalid": dataAttr(fieldProps.invalid),
    "data-readonly": dataAttr(fieldProps.readOnly)
  });
  const getLabelProps = () => ({
    ...parts2.label.attrs,
    id: labelId,
    "data-disabled": dataAttr(fieldProps.disabled),
    "data-invalid": dataAttr(fieldProps.invalid),
    "data-readonly": dataAttr(fieldProps.readOnly),
    htmlFor: id
  });
  const labelIds = createMemo(() => {
    const ids = [];
    if (hasErrorText() && fieldProps.invalid) ids.push(errorTextId);
    if (hasHelperText()) ids.push(helperTextId);
    return ids;
  });
  const getControlProps = () => ({
    "aria-describedby": labelIds().join(" ") || void 0,
    "aria-invalid": ariaAttr(fieldProps.invalid),
    "data-invalid": dataAttr(fieldProps.invalid),
    "data-required": dataAttr(fieldProps.required),
    "data-readonly": dataAttr(fieldProps.readOnly),
    id,
    required: fieldProps.required,
    disabled: fieldProps.disabled,
    readOnly: fieldProps.readOnly || void 0
  });
  const getInputProps = () => ({
    ...getControlProps(),
    ...parts2.input.attrs
  });
  const getTextareaProps = () => ({
    ...getControlProps(),
    ...parts2.textarea.attrs
  });
  const getSelectProps = () => ({
    ...getControlProps(),
    ...parts2.select.attrs
  });
  const getHelperTextProps = () => ({
    id: helperTextId,
    ...parts2.helperText.attrs,
    "data-disabled": dataAttr(fieldProps.disabled)
  });
  const getErrorTextProps = () => ({
    id: errorTextId,
    ...parts2.errorText.attrs,
    "aria-live": "polite"
  });
  const getRequiredIndicatorProps = () => ({
    "aria-hidden": true,
    ...parts2.requiredIndicator.attrs
  });
  return createMemo(() => ({
    ariaDescribedby: labelIds().join(" "),
    ids: {
      control: id,
      label: labelId,
      errorText: errorTextId,
      helperText: helperTextId
    },
    refs: {
      rootRef: setRootRef
    },
    disabled: fieldProps.disabled,
    invalid: fieldProps.invalid,
    readOnly: fieldProps.readOnly,
    required: fieldProps.required,
    getLabelProps,
    getRootProps,
    getInputProps,
    getTextareaProps,
    getSelectProps,
    getHelperTextProps,
    getErrorTextProps,
    getRequiredIndicatorProps
  }));
};
var FieldRoot = (props7) => {
  const [useFieldProps, localProps] = createSplitProps()(props7, ["id", "ids", "disabled", "invalid", "readOnly", "required"]);
  const field = useField(useFieldProps);
  const mergedProps = mergeProps22(() => field().getRootProps(), localProps);
  return createComponent(FieldProvider, {
    value: field,
    get children() {
      return createComponent(ark.div, mergeProps(mergedProps, {
        ref(r$) {
          var _ref$ = composeRefs(field().refs.rootRef, props7.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }));
    }
  });
};
var FieldRootProvider = (props7) => {
  const [{
    value: field
  }, localProps] = createSplitProps()(props7, ["value"]);
  const mergedProps = mergeProps22(() => field().getRootProps(), localProps);
  return createComponent(FieldProvider, {
    value: field,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var FieldSelect = (props7) => {
  const field = useFieldContext();
  const mergedProps = mergeProps22(() => field?.().getSelectProps(), props7);
  return createComponent(ark.select, mergedProps);
};
var FieldTextarea = (props7) => {
  const field = useFieldContext();
  let textareaRef;
  const {
    autoresize,
    ...textareaProps
  } = props7;
  const mergedProps = mergeProps22(() => field?.().getTextareaProps(), () => ({
    style: {
      resize: autoresize ? "none" : void 0
    }
  }), textareaProps);
  createEffect(() => {
    if (!autoresize) return;
    const cleanup = autoresizeTextarea(textareaRef);
    return cleanup;
  });
  return createComponent(ark.textarea, mergeProps(mergedProps, {
    ref: (el) => {
      textareaRef = el;
    }
  }));
};
var field_exports = {};
__export2(field_exports, {
  Context: () => FieldContext,
  ErrorText: () => FieldErrorText,
  HelperText: () => FieldHelperText,
  Input: () => FieldInput,
  Label: () => FieldLabel,
  RequiredIndicator: () => FieldRequiredIndicator,
  Root: () => FieldRoot,
  RootProvider: () => FieldRootProvider,
  Select: () => FieldSelect,
  Textarea: () => FieldTextarea
});

// ../../../node_modules/@zag-js/toast/node_modules/@zag-js/core/dist/index.mjs
function createGuards() {
  return {
    and: (...guards2) => {
      return function andGuard(params) {
        return guards2.every((str) => params.guard(str));
      };
    },
    or: (...guards2) => {
      return function orGuard(params) {
        return guards2.some((str) => params.guard(str));
      };
    },
    not: (guard) => {
      return function notGuard(params) {
        return !params.guard(guard);
      };
    }
  };
}
function createMachine2(config) {
  return config;
}

// ../../../node_modules/@zag-js/toast/dist/index.mjs
var anatomy = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts3 = anatomy.build();
var getRegionId = (placement) => `toast-group:${placement}`;
var getRegionEl = (ctx, placement) => ctx.getById(`toast-group:${placement}`);
var getRootId = (ctx) => `toast:${ctx.id}`;
var getRootEl = (ctx) => ctx.getById(getRootId(ctx));
var getTitleId = (ctx) => `toast:${ctx.id}:title`;
var getDescriptionId = (ctx) => `toast:${ctx.id}:description`;
var getCloseTriggerId = (ctx) => `toast${ctx.id}:close`;
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;
}
var getOffsets = (offsets) => typeof offsets === "string" ? { left: offsets, right: offsets, bottom: offsets, top: offsets } : offsets;
function getGroupPlacementStyle(service, placement) {
  const { prop, computed, context } = service;
  const { offsets, gap } = prop("store").attrs;
  const heights = context.get("heights");
  const computedOffset = getOffsets(offsets);
  const rtl = prop("dir") === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles = {
    position: "fixed",
    pointerEvents: computed("count") > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${gap}px`,
    "--first-height": `${heights[0]?.height || 0}px`,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  styles.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset3 = computedOffset.top;
    styles.top = `max(env(safe-area-inset-top, 0px), ${offset3})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset3 = computedOffset.bottom;
    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset3})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset3 = computedOffset.right;
    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset3})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset3 = computedOffset.left;
    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset3})`;
  }
  return styles;
}
function getPlacementStyle(service, visible) {
  const { prop, context, computed } = service;
  const parent2 = prop("parent");
  const placement = parent2.computed("placement");
  const { gap } = parent2.prop("store").attrs;
  const [side] = placement.split("-");
  const mounted = context.get("mounted");
  const remainingTime = context.get("remainingTime");
  const height = computed("height");
  const frontmost = computed("frontmost");
  const sibling = !frontmost;
  const overlap = !prop("stacked");
  const stacked = prop("stacked");
  const type = prop("type");
  const duration = type === "loading" ? Number.MAX_SAFE_INTEGER : remainingTime;
  const offset3 = computed("heightIndex") * gap + computed("heightBefore");
  const styles = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${prop("removeDelay")}ms`,
    "--duration": `${duration}ms`,
    "--initial-height": `${height}px`,
    "--offset": `${offset3}px`,
    "--index": prop("index"),
    "--z-index": computed("zIndex"),
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (side === "top") {
    assign2({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign2({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (mounted) {
    assign2({
      "--y": "0",
      "--opacity": "1"
    });
    if (stacked) {
      assign2({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign2({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling && overlap) {
    assign2({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign2({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling && stacked && !visible) {
    assign2({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (frontmost && !visible) {
    assign2({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles;
}
function getGhostBeforeStyle(service, visible) {
  const { computed } = service;
  const styles = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign2 = (overrides) => Object.assign(styles, overrides);
  if (computed("frontmost") && !visible) {
    assign2({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles;
}
function getGhostAfterStyle() {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(service, normalize) {
  const { context, prop, send, refs, computed } = service;
  return {
    getCount() {
      return context.get("toasts").length;
    },
    getToasts() {
      return context.get("toasts");
    },
    getGroupProps(options2 = {}) {
      const { label = "Notifications" } = options2;
      const { hotkey } = prop("store").attrs;
      const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const placement = computed("placement");
      const [side, align = "center"] = placement.split("-");
      return normalize.element({
        ...parts3.group.attrs,
        dir: prop("dir"),
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(service, placement),
        onMouseMove() {
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (refs.get("isFocusWithin") && !contains(event.currentTarget, event.relatedTarget)) {
            queueMicrotask(() => send({ type: "REGION.BLUR" }));
          }
        }
      });
    },
    subscribe(fn) {
      const store = prop("store");
      return store.subscribe(() => fn(context.get("toasts")));
    }
  };
}
var groupMachine = createMachine2({
  props({ props: props7 }) {
    return {
      dir: "ltr",
      id: uuid(),
      ...props7,
      store: props7.store
    };
  },
  initialState({ prop }) {
    return prop("store").attrs.overlap ? "overlap" : "stack";
  },
  refs() {
    return {
      lastFocusedEl: null,
      isFocusWithin: false,
      dismissableCleanup: void 0
    };
  },
  context({ bindable }) {
    return {
      toasts: bindable(() => ({
        defaultValue: [],
        sync: true,
        hash: (toasts) => toasts.map((t) => t.id).join(",")
      })),
      heights: bindable(() => ({
        defaultValue: [],
        sync: true
      }))
    };
  },
  computed: {
    count: ({ context }) => context.get("toasts").length,
    overlap: ({ prop }) => prop("store").attrs.overlap,
    placement: ({ prop }) => prop("store").attrs.placement
  },
  effects: ["subscribeToStore", "trackDocumentVisibility", "trackHotKeyPress"],
  watch({ track, context, action }) {
    track([() => context.hash("toasts")], () => {
      queueMicrotask(() => {
        action(["collapsedIfEmpty", "setDismissableBranch"]);
      });
    });
  },
  exit: ["clearDismissableBranch", "clearLastFocusedEl"],
  on: {
    "DOC.HOTKEY": {
      actions: ["focusRegionEl"]
    },
    "REGION.BLUR": [
      {
        guard: "isOverlapping",
        target: "overlap",
        actions: ["collapseToasts", "resumeToasts", "restoreLastFocusedEl"]
      },
      {
        target: "stack",
        actions: ["resumeToasts", "restoreLastFocusedEl"]
      }
    ],
    "TOAST.REMOVE": {
      actions: ["removeToast", "removeHeight"]
    },
    "TOAST.PAUSE": {
      actions: ["pauseToasts"]
    }
  },
  states: {
    stack: {
      on: {
        "REGION.POINTER_LEAVE": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["resumeToasts", "collapseToasts"]
          },
          {
            actions: ["resumeToasts"]
          }
        ],
        "REGION.OVERLAP": {
          target: "overlap",
          actions: ["collapseToasts"]
        },
        "REGION.FOCUS": {
          actions: ["setLastFocusedEl", "pauseToasts"]
        },
        "REGION.POINTER_ENTER": {
          actions: ["pauseToasts"]
        }
      }
    },
    overlap: {
      on: {
        "REGION.STACK": {
          target: "stack",
          actions: ["expandToasts"]
        },
        "REGION.POINTER_ENTER": {
          target: "stack",
          actions: ["pauseToasts", "expandToasts"]
        },
        "REGION.FOCUS": {
          target: "stack",
          actions: ["setLastFocusedEl", "pauseToasts", "expandToasts"]
        }
      }
    }
  },
  implementations: {
    guards: {
      isOverlapping: ({ computed }) => computed("overlap")
    },
    effects: {
      subscribeToStore({ context, prop }) {
        return prop("store").subscribe((toast) => {
          if (toast.dismiss) {
            context.set("toasts", (prev) => prev.filter((t) => t.id !== toast.id));
            return;
          }
          context.set("toasts", (prev) => {
            const index = prev.findIndex((t) => t.id === toast.id);
            if (index !== -1) {
              return [...prev.slice(0, index), { ...prev[index], ...toast }, ...prev.slice(index + 1)];
            }
            return [toast, ...prev];
          });
        });
      },
      trackHotKeyPress({ prop, send }) {
        const handleKeyDown = (event) => {
          const { hotkey } = prop("store").attrs;
          const isHotkeyPressed = hotkey.every((key) => event[key] || event.code === key);
          if (!isHotkeyPressed) return;
          send({ type: "DOC.HOTKEY" });
        };
        return addDomEvent(document, "keydown", handleKeyDown, { capture: true });
      },
      trackDocumentVisibility({ prop, send, scope }) {
        const { pauseOnPageIdle } = prop("store").attrs;
        if (!pauseOnPageIdle) return;
        const doc = scope.getDoc();
        return addDomEvent(doc, "visibilitychange", () => {
          const isHidden = doc.visibilityState === "hidden";
          send({ type: isHidden ? "PAUSE_ALL" : "RESUME_ALL" });
        });
      }
    },
    actions: {
      setDismissableBranch({ refs, context, computed, scope }) {
        const toasts = context.get("toasts");
        const placement = computed("placement");
        const hasToasts = toasts.length > 0;
        if (!hasToasts) {
          refs.get("dismissableCleanup")?.();
          return;
        }
        if (hasToasts && refs.get("dismissableCleanup")) {
          return;
        }
        const groupEl = () => getRegionEl(scope, placement);
        const cleanup = trackDismissableBranch(groupEl, { defer: true });
        refs.set("dismissableCleanup", cleanup);
      },
      clearDismissableBranch({ refs }) {
        refs.get("dismissableCleanup")?.();
      },
      focusRegionEl({ scope, computed }) {
        queueMicrotask(() => {
          getRegionEl(scope, computed("placement"))?.focus();
        });
      },
      pauseToasts({ prop }) {
        prop("store").pause();
      },
      resumeToasts({ prop }) {
        prop("store").resume();
      },
      expandToasts({ prop }) {
        prop("store").expand();
      },
      collapseToasts({ prop }) {
        prop("store").collapse();
      },
      removeToast({ prop, event }) {
        prop("store").remove(event.id);
      },
      removeHeight({ event, context }) {
        if (event?.id == null) return;
        queueMicrotask(() => {
          context.set("heights", (heights) => heights.filter((height) => height.id !== event.id));
        });
      },
      collapsedIfEmpty({ send, computed }) {
        if (!computed("overlap") || computed("count") > 1) return;
        send({ type: "REGION.OVERLAP" });
      },
      setLastFocusedEl({ refs, event }) {
        if (refs.get("isFocusWithin") || !event.target) return;
        refs.set("isFocusWithin", true);
        refs.set("lastFocusedEl", event.target);
      },
      restoreLastFocusedEl({ refs }) {
        if (!refs.get("lastFocusedEl")) return;
        refs.get("lastFocusedEl")?.focus({ preventScroll: true });
        refs.set("lastFocusedEl", null);
        refs.set("isFocusWithin", false);
      },
      clearLastFocusedEl({ refs }) {
        if (!refs.get("lastFocusedEl")) return;
        refs.get("lastFocusedEl")?.focus({ preventScroll: true });
        refs.set("lastFocusedEl", null);
        refs.set("isFocusWithin", false);
      }
    }
  }
});
function connect2(service, normalize) {
  const { state: state2, send, prop, scope, context, computed } = service;
  const visible = state2.hasTag("visible");
  const paused = state2.hasTag("paused");
  const mounted = context.get("mounted");
  const frontmost = computed("frontmost");
  const placement = prop("parent").computed("placement");
  const type = prop("type");
  const stacked = prop("stacked");
  const title = prop("title");
  const description = prop("description");
  const action = prop("action");
  const [side, align = "center"] = placement.split("-");
  return {
    type,
    title,
    description,
    placement,
    visible,
    paused,
    closable: !!prop("closable"),
    pause() {
      send({ type: "PAUSE" });
    },
    resume() {
      send({ type: "RESUME" });
    },
    dismiss() {
      send({ type: "DISMISS", src: "programmatic" });
    },
    getRootProps() {
      return normalize.element({
        ...parts3.root.attrs,
        dir: prop("dir"),
        id: getRootId(scope),
        "data-state": visible ? "open" : "closed",
        "data-type": type,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr(mounted),
        "data-paused": dataAttr(paused),
        "data-first": dataAttr(frontmost),
        "data-sibling": dataAttr(!frontmost),
        "data-stack": dataAttr(stacked),
        "data-overlap": dataAttr(!stacked),
        role: "status",
        "aria-atomic": "true",
        "aria-describedby": description ? getDescriptionId(scope) : void 0,
        "aria-labelledby": title ? getTitleId(scope) : void 0,
        tabIndex: 0,
        style: getPlacementStyle(service, visible),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (event.key == "Escape") {
            send({ type: "DISMISS", src: "keyboard" });
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(service, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize.element({
        "data-ghost": "after",
        style: getGhostAfterStyle()
      });
    },
    getTitleProps() {
      return normalize.element({
        ...parts3.title.attrs,
        id: getTitleId(scope)
      });
    },
    getDescriptionProps() {
      return normalize.element({
        ...parts3.description.attrs,
        id: getDescriptionId(scope)
      });
    },
    getActionTriggerProps() {
      return normalize.button({
        ...parts3.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          action?.onClick?.();
          send({ type: "DISMISS", src: "user" });
        }
      });
    },
    getCloseTriggerProps() {
      return normalize.button({
        id: getCloseTriggerId(scope),
        ...parts3.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "DISMISS", src: "user" });
        }
      });
    }
  };
}
var { not } = createGuards();
var machine2 = createMachine2({
  props({ props: props7 }) {
    ensureProps(props7, ["id", "type", "parent", "removeDelay"], "toast");
    return {
      closable: true,
      ...props7,
      duration: getToastDuration(props7.duration, props7.type)
    };
  },
  initialState({ prop }) {
    const persist2 = prop("type") === "loading" || prop("duration") === Infinity;
    return persist2 ? "visible:persist" : "visible";
  },
  context({ prop, bindable }) {
    return {
      remainingTime: bindable(() => ({
        defaultValue: getToastDuration(prop("duration"), prop("type"))
      })),
      createdAt: bindable(() => ({
        defaultValue: Date.now()
      })),
      mounted: bindable(() => ({
        defaultValue: false
      })),
      initialHeight: bindable(() => ({
        defaultValue: 0
      }))
    };
  },
  refs() {
    return {
      closeTimerStartTime: Date.now(),
      lastCloseStartTimerStartTime: 0
    };
  },
  computed: {
    zIndex: ({ prop }) => {
      const toasts = prop("parent").context.get("toasts");
      const index = toasts.findIndex((toast) => toast.id === prop("id"));
      return toasts.length - index;
    },
    height: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      const height = heights.find((height2) => height2.id === prop("id"));
      return height?.height ?? 0;
    },
    heightIndex: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      return heights.findIndex((height) => height.id === prop("id"));
    },
    frontmost: ({ prop }) => prop("index") === 0,
    heightBefore: ({ prop }) => {
      const heights = prop("parent").context.get("heights");
      const heightIndex = heights.findIndex((height) => height.id === prop("id"));
      return heights.reduce((prev, curr, reducerIndex) => {
        if (reducerIndex >= heightIndex) return prev;
        return prev + curr.height;
      }, 0);
    },
    shouldPersist: ({ prop }) => prop("type") === "loading" || prop("duration") === Infinity
  },
  watch({ track, prop, send }) {
    track([() => prop("message")], () => {
      const message = prop("message");
      if (message) send({ type: message, src: "programmatic" });
    });
    track([() => prop("type"), () => prop("duration")], () => {
      send({ type: "UPDATE" });
    });
  },
  on: {
    UPDATE: [
      {
        guard: "shouldPersist",
        target: "visible:persist",
        actions: ["resetCloseTimer"]
      },
      {
        target: "visible:updating",
        actions: ["resetCloseTimer"]
      }
    ],
    MEASURE: {
      actions: ["measureHeight"]
    }
  },
  entry: ["setMounted", "measureHeight", "invokeOnVisible"],
  effects: ["trackHeight"],
  states: {
    "visible:updating": {
      tags: ["visible", "updating"],
      effects: ["waitForNextTick"],
      on: {
        SHOW: {
          target: "visible"
        }
      }
    },
    "visible:persist": {
      tags: ["visible", "paused"],
      on: {
        RESUME: {
          guard: not("isLoadingType"),
          target: "visible",
          actions: ["setCloseTimer"]
        },
        DISMISS: {
          target: "dismissing"
        }
      }
    },
    visible: {
      tags: ["visible"],
      effects: ["waitForDuration"],
      on: {
        DISMISS: {
          target: "dismissing"
        },
        PAUSE: {
          target: "visible:persist",
          actions: ["syncRemainingTime"]
        }
      }
    },
    dismissing: {
      entry: ["invokeOnDismiss"],
      effects: ["waitForRemoveDelay"],
      on: {
        REMOVE: {
          target: "unmounted",
          actions: ["notifyParentToRemove"]
        }
      }
    },
    unmounted: {
      entry: ["invokeOnUnmount"]
    }
  },
  implementations: {
    effects: {
      waitForRemoveDelay({ prop, send }) {
        return setRafTimeout(() => {
          send({ type: "REMOVE", src: "timer" });
        }, prop("removeDelay"));
      },
      waitForDuration({ send, context, computed }) {
        if (computed("shouldPersist")) return;
        return setRafTimeout(() => {
          send({ type: "DISMISS", src: "timer" });
        }, context.get("remainingTime"));
      },
      waitForNextTick({ send }) {
        return setRafTimeout(() => {
          send({ type: "SHOW", src: "timer" });
        }, 0);
      },
      trackHeight({ scope, prop }) {
        let cleanup;
        raf(() => {
          const rootEl = getRootEl(scope);
          if (!rootEl) return;
          const syncHeight = () => {
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const height = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            const item = { id: prop("id"), height };
            setHeight(prop("parent"), item);
          };
          const win = scope.getWin();
          const observer = new win.MutationObserver(syncHeight);
          observer.observe(rootEl, {
            childList: true,
            subtree: true,
            characterData: true
          });
          cleanup = () => observer.disconnect();
        });
        return () => cleanup?.();
      }
    },
    guards: {
      isLoadingType: ({ prop }) => prop("type") === "loading",
      shouldPersist: ({ computed }) => computed("shouldPersist")
    },
    actions: {
      setMounted({ context }) {
        raf(() => {
          context.set("mounted", true);
        });
      },
      measureHeight({ scope, prop, context }) {
        queueMicrotask(() => {
          const rootEl = getRootEl(scope);
          if (!rootEl) return;
          const originalHeight = rootEl.style.height;
          rootEl.style.height = "auto";
          const height = rootEl.getBoundingClientRect().height;
          rootEl.style.height = originalHeight;
          context.set("initialHeight", height);
          const item = { id: prop("id"), height };
          setHeight(prop("parent"), item);
        });
      },
      setCloseTimer({ refs }) {
        refs.set("closeTimerStartTime", Date.now());
      },
      resetCloseTimer({ context, refs, prop }) {
        refs.set("closeTimerStartTime", Date.now());
        context.set("remainingTime", getToastDuration(prop("duration"), prop("type")));
      },
      syncRemainingTime({ context, refs }) {
        context.set("remainingTime", (prev) => {
          const closeTimerStartTime = refs.get("closeTimerStartTime");
          const elapsedTime = Date.now() - closeTimerStartTime;
          refs.set("lastCloseStartTimerStartTime", Date.now());
          return prev - elapsedTime;
        });
      },
      notifyParentToRemove({ prop }) {
        const parent2 = prop("parent");
        parent2.send({ type: "TOAST.REMOVE", id: prop("id") });
      },
      invokeOnDismiss({ prop, event }) {
        prop("onStatusChange")?.({ status: "dismissing", src: event.src });
      },
      invokeOnUnmount({ prop }) {
        prop("onStatusChange")?.({ status: "unmounted" });
      },
      invokeOnVisible({ prop }) {
        prop("onStatusChange")?.({ status: "visible" });
      }
    }
  }
});
function setHeight(parent2, item) {
  const { id, height } = item;
  parent2.context.set("heights", (prev) => {
    const alreadyExists = prev.find((i) => i.id === id);
    if (!alreadyExists) {
      return [{ id, height }, ...prev];
    } else {
      return prev.map((i) => i.id === id ? { ...i, height } : i);
    }
  });
}
var withDefaults = (options2, defaults) => {
  return { ...defaults, ...options2 };
};
function createToastStore(props7) {
  const attrs = withDefaults(props7, {
    placement: "bottom",
    overlap: false,
    max: 24,
    gap: 16,
    offsets: "1rem",
    hotkey: ["altKey", "KeyT"],
    removeDelay: 200,
    pauseOnPageIdle: true
  });
  let subscribers = [];
  let toasts = [];
  let dismissedToasts = /* @__PURE__ */ new Set();
  const subscribe = (subscriber) => {
    subscribers.push(subscriber);
    return () => {
      const index = subscribers.indexOf(subscriber);
      subscribers.splice(index, 1);
    };
  };
  const publish = (data) => {
    subscribers.forEach((subscriber) => subscriber(data));
    return data;
  };
  const addToast = (data) => {
    if (toasts.length >= attrs.max) return;
    publish(data);
    toasts.unshift(data);
  };
  const create2 = (data) => {
    const id = data.id ?? `toast:${uuid()}`;
    const exists = toasts.find((toast) => toast.id === id);
    if (dismissedToasts.has(id)) dismissedToasts.delete(id);
    if (exists) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) {
          return publish({ ...toast, ...data, id });
        }
        return toast;
      });
    } else {
      addToast({
        id,
        duration: attrs.duration,
        removeDelay: attrs.removeDelay,
        type: "info",
        ...data,
        stacked: !attrs.overlap,
        gap: attrs.gap
      });
    }
    return id;
  };
  const remove2 = (id) => {
    dismissedToasts.add(id);
    if (!id) {
      toasts.forEach((toast) => {
        subscribers.forEach((subscriber) => subscriber({ id: toast.id, dismiss: true }));
      });
      toasts = [];
    } else {
      subscribers.forEach((subscriber) => subscriber({ id, dismiss: true }));
      toasts = toasts.filter((toast) => toast.id !== id);
    }
    return id;
  };
  const error = (data) => {
    return create2({ ...data, type: "error" });
  };
  const success = (data) => {
    return create2({ ...data, type: "success" });
  };
  const info = (data) => {
    return create2({ ...data, type: "info" });
  };
  const warning = (data) => {
    return create2({ ...data, type: "warning" });
  };
  const loading = (data) => {
    return create2({ ...data, type: "loading" });
  };
  const getVisibleToasts = () => {
    return toasts.filter((toast) => !dismissedToasts.has(toast.id));
  };
  const getCount = () => {
    return toasts.length;
  };
  const promise = (promise2, options2, shared = {}) => {
    if (!options2) return;
    let id = void 0;
    if (options2.loading !== void 0) {
      id = create2({
        ...shared,
        ...options2.loading,
        promise: promise2,
        type: "loading"
      });
    }
    let removable = id !== void 0;
    let result;
    const prom = runIfFn(promise2).then(async (response) => {
      result = ["resolve", response];
      if (isHttpResponse(response) && !response.ok) {
        removable = false;
        const errorOptions = runIfFn(options2.error, `HTTP Error! status: ${response.status}`);
        create2({ ...shared, ...errorOptions, id, type: "error" });
      } else if (options2.success !== void 0) {
        removable = false;
        const successOptions = runIfFn(options2.success, response);
        create2({ ...shared, ...successOptions, id, type: "success" });
      }
    }).catch(async (error2) => {
      result = ["reject", error2];
      if (options2.error !== void 0) {
        removable = false;
        const errorOptions = runIfFn(options2.error, error2);
        create2({ ...shared, ...errorOptions, id, type: "error" });
      }
    }).finally(() => {
      if (removable) {
        remove2(id);
        id = void 0;
      }
      options2.finally?.();
    });
    const unwrap2 = () => new Promise(
      (resolve, reject) => prom.then(() => result[0] === "reject" ? reject(result[1]) : resolve(result[1])).catch(reject)
    );
    return { id, unwrap: unwrap2 };
  };
  const update = (id, data) => {
    return create2({ id, ...data });
  };
  const pause = (id) => {
    if (id != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) return publish({ ...toast, message: "PAUSE" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish({ ...toast, message: "PAUSE" }));
    }
  };
  const resume = (id) => {
    if (id != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) return publish({ ...toast, message: "RESUME" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish({ ...toast, message: "RESUME" }));
    }
  };
  const dismiss = (id) => {
    if (id != null) {
      toasts = toasts.map((toast) => {
        if (toast.id === id) return publish({ ...toast, message: "DISMISS" });
        return toast;
      });
    } else {
      toasts = toasts.map((toast) => publish({ ...toast, message: "DISMISS" }));
    }
  };
  const isVisible = (id) => {
    return !dismissedToasts.has(id) && !!toasts.find((toast) => toast.id === id);
  };
  const isDismissed = (id) => {
    return dismissedToasts.has(id);
  };
  const expand = () => {
    toasts = toasts.map((toast) => publish({ ...toast, stacked: true }));
  };
  const collapse = () => {
    toasts = toasts.map((toast) => publish({ ...toast, stacked: false }));
  };
  return {
    attrs,
    subscribe,
    create: create2,
    update,
    remove: remove2,
    dismiss,
    error,
    success,
    info,
    warning,
    loading,
    getVisibleToasts,
    getCount,
    promise,
    pause,
    resume,
    isVisible,
    isDismissed,
    expand,
    collapse
  };
}
var isHttpResponse = (data) => {
  return data && typeof data === "object" && "ok" in data && typeof data.ok === "boolean" && "status" in data && typeof data.status === "number";
};
var group = {
  connect: groupConnect,
  machine: groupMachine
};

// ../../../node_modules/@ark-ui/solid/dist/chunk/A6LAAZDX.js
var createToaster = (props7) => {
  return createToastStore(props7);
};
var [ToastProvider, useToastContext] = createContext2({
  hookName: "useToastContext",
  providerName: "<ToastProvider />"
});
var ToastActionTrigger = (props7) => {
  const toast3 = useToastContext();
  const mergedProps = mergeProps22(() => toast3().getActionTriggerProps(), props7);
  return createComponent(ark.button, mergedProps);
};
var ToastCloseTrigger = (props7) => {
  const toast3 = useToastContext();
  const mergedProps = mergeProps22(() => toast3().getCloseTriggerProps(), props7);
  return createComponent(ark.button, mergedProps);
};
var ToastContext = (props7) => props7.children(useToastContext());
var ToastDescription = (props7) => {
  const toast3 = useToastContext();
  const mergedProps = mergeProps22(() => toast3().getDescriptionProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var _tmpl$2 = /* @__PURE__ */ template(`<div><div></div><div>`);
var ToastRoot = (props7) => {
  const toast3 = useToastContext();
  const mergedProps = mergeProps22(() => toast3().getRootProps(), props7);
  return (() => {
    var _el$ = _tmpl$2(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    spread(_el$, mergedProps, false, true);
    spread(_el$2, mergeProps(() => toast3().getGhostBeforeProps()), false, false);
    insert(_el$, () => props7.children, _el$3);
    spread(_el$3, mergeProps(() => toast3().getGhostAfterProps()), false, false);
    return _el$;
  })();
};
var ToastTitle = (props7) => {
  const toast3 = useToastContext();
  const mergedProps = mergeProps22(() => toast3().getTitleProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var Toaster = (props7) => {
  const [toasterProps, localProps] = splitProps(props7, ["toaster", "children"]);
  const locale = useLocaleContext();
  const env = useEnvironmentContext();
  const service = useMachine(group.machine, () => ({
    store: toasterProps.toaster,
    id: createUniqueId(),
    dir: locale()?.dir,
    getRootNode: () => env()?.getDocument()
  }));
  const api = createMemo(() => group.connect(service, normalizeProps));
  const toasts = createMemo(() => api().getToasts());
  const mergedProps = mergeProps22(api().getGroupProps(), localProps);
  return createComponent(ark.div, mergeProps(mergedProps, {
    get children() {
      return createComponent(Key, {
        get each() {
          return toasts();
        },
        by: "id",
        children: (toast3, index) => createComponent(ToastActor, {
          value: toast3,
          index,
          parent: service,
          children: (ctx) => toasterProps.children(ctx)
        })
      });
    }
  }));
};
var ToastActor = (props7) => {
  const localProps = createMemo(() => ({
    ...props7.value(),
    parent: props7.parent,
    index: props7.index
  }));
  const service = useMachine(machine2, localProps);
  const api = createMemo(() => connect2(service, normalizeProps));
  return createComponent(ToastProvider, {
    value: api,
    get children() {
      return props7.children(props7.value);
    }
  });
};
var toast_exports = {};
__export2(toast_exports, {
  ActionTrigger: () => ToastActionTrigger,
  CloseTrigger: () => ToastCloseTrigger,
  Context: () => ToastContext,
  Description: () => ToastDescription,
  Root: () => ToastRoot,
  Title: () => ToastTitle
});

// ../../../node_modules/@zag-js/number-input/node_modules/@zag-js/core/dist/index.mjs
function memo(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => !isEqual(deps[index], dep));
    if (!depsChanged) return result;
    deps = newDeps;
    result = fn(...newDeps);
    opts?.onChange?.(result);
    return result;
  };
}
function createGuards2() {
  return {
    and: (...guards2) => {
      return function andGuard(params) {
        return guards2.every((str) => params.guard(str));
      };
    },
    or: (...guards2) => {
      return function orGuard(params) {
        return guards2.some((str) => params.guard(str));
      };
    },
    not: (guard) => {
      return function notGuard(params) {
        return !params.guard(guard);
      };
    }
  };
}
function createMachine3(config) {
  return config;
}
function setup() {
  return {
    guards: createGuards2(),
    createMachine: (config) => {
      return createMachine3(config);
    },
    choose: (transitions) => {
      return function chooseFn({ choose: choose2 }) {
        return choose2(transitions)?.actions;
      };
    }
  };
}

// ../../../node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "\xB0",
      "ja-JP": " \u5EA6",
      "zh-TW": "\u5EA6",
      "sl-SI": " \xB0"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} \u2013 ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " \u2013 ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options2 = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options2 = {
      ...options2,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options2 = {
      ...options2,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options2;
  }
  constructor(locale, options2 = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options2);
    this.options = options2;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options2 = {}) {
  let { numberingSystem } = options2;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options2.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options2;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options2 = {
      ...options2,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options2 ? Object.entries(options2).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options2);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// ../../../node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options2 = {}) {
    this.locale = locale;
    this.options = options2;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options2, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options2);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser2 = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options2);
      if (parser2.isValidPartialNumber(value)) return parser2;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options2) {
  let cacheKey = locale + (options2 ? Object.entries(options2).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  let parser2 = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser2) {
    parser2 = new $6c7bd7858deea686$var$NumberParserImpl(locale, options2);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser2);
  }
  return parser2;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1) index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options2 = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options2).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options2).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR") value = $6c7bd7858deea686$var$replaceAll(value, ".", String.fromCharCode(8239));
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options2 = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options2);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options2);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group2 = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a, b) => b.length - a.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group: group2,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
  if (str.replaceAll) return str.replaceAll(find, replace);
  return str.split(find).join(replace);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// ../../../node_modules/@zag-js/number-input/dist/index.mjs
var anatomy2 = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "valueText",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts4 = anatomy2.build();
var getRootId2 = (ctx) => ctx.ids?.root ?? `number-input:${ctx.id}`;
var getInputId = (ctx) => ctx.ids?.input ?? `number-input:${ctx.id}:input`;
var getIncrementTriggerId = (ctx) => ctx.ids?.incrementTrigger ?? `number-input:${ctx.id}:inc`;
var getDecrementTriggerId = (ctx) => ctx.ids?.decrementTrigger ?? `number-input:${ctx.id}:dec`;
var getScrubberId = (ctx) => ctx.ids?.scrubber ?? `number-input:${ctx.id}:scrubber`;
var getCursorId = (ctx) => `number-input:${ctx.id}:cursor`;
var getLabelId = (ctx) => ctx.ids?.label ?? `number-input:${ctx.id}:label`;
var getInputEl = (ctx) => ctx.getById(getInputId(ctx));
var getIncrementTriggerEl = (ctx) => ctx.getById(getIncrementTriggerId(ctx));
var getDecrementTriggerEl = (ctx) => ctx.getById(getDecrementTriggerId(ctx));
var getCursorEl = (ctx) => ctx.getDoc().getElementById(getCursorId(ctx));
var getPressedTriggerEl = (ctx, hint) => {
  let btnEl = null;
  if (hint === "increment") {
    btnEl = getIncrementTriggerEl(ctx);
  }
  if (hint === "decrement") {
    btnEl = getDecrementTriggerEl(ctx);
  }
  return btnEl;
};
var setupVirtualCursor = (ctx, point) => {
  if (isSafari()) return;
  createVirtualCursor(ctx, point);
  return () => {
    getCursorEl(ctx)?.remove();
  };
};
var preventTextSelection = (ctx) => {
  const doc = ctx.getDoc();
  const html2 = doc.documentElement;
  const body = doc.body;
  body.style.pointerEvents = "none";
  html2.style.userSelect = "none";
  html2.style.cursor = "ew-resize";
  return () => {
    body.style.pointerEvents = "";
    html2.style.userSelect = "";
    html2.style.cursor = "";
    if (!html2.style.length) {
      html2.removeAttribute("style");
    }
    if (!body.style.length) {
      body.removeAttribute("style");
    }
  };
};
var getMousemoveValue = (ctx, opts) => {
  const { point, isRtl, event } = opts;
  const win = ctx.getWin();
  const x = roundToDpr(event.movementX, win.devicePixelRatio);
  const y = roundToDpr(event.movementY, win.devicePixelRatio);
  let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
  if (isRtl && hint === "increment") hint = "decrement";
  if (isRtl && hint === "decrement") hint = "increment";
  const newPoint = { x: point.x + x, y: point.y + y };
  const width = win.innerWidth;
  const half = roundToDpr(7.5, win.devicePixelRatio);
  newPoint.x = wrap(newPoint.x + half, width) - half;
  return { hint, point: newPoint };
};
var createVirtualCursor = (ctx, point) => {
  const doc = ctx.getDoc();
  const el = doc.createElement("div");
  el.className = "scrubber--cursor";
  el.id = getCursorId(ctx);
  Object.assign(el.style, {
    width: "15px",
    height: "15px",
    position: "fixed",
    pointerEvents: "none",
    left: "0px",
    top: "0px",
    zIndex: MAX_Z_INDEX,
    transform: point ? `translate3d(${point.x}px, ${point.y}px, 0px)` : void 0,
    willChange: "transform"
  });
  el.innerHTML = `
      <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
        <g transform="translate(2 3)">
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
          <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
        </g>
      </svg>`;
  doc.body.appendChild(el);
};
function connect3(service, normalize) {
  const { state: state2, send, prop, scope, computed } = service;
  const focused = state2.hasTag("focus");
  const disabled = computed("isDisabled");
  const readOnly = prop("readOnly");
  const empty = computed("isValueEmpty");
  const invalid = computed("isOutOfRange") || !!prop("invalid");
  const isIncrementDisabled = disabled || !computed("canIncrement") || readOnly;
  const isDecrementDisabled = disabled || !computed("canDecrement") || readOnly;
  const translations = prop("translations");
  return {
    focused,
    invalid,
    empty,
    value: computed("formattedValue"),
    valueAsNumber: computed("valueAsNumber"),
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    increment() {
      send({ type: "VALUE.INCREMENT" });
    },
    decrement() {
      send({ type: "VALUE.DECREMENT" });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: prop("max") });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: prop("min") });
    },
    focus() {
      getInputEl(scope)?.focus();
    },
    getRootProps() {
      return normalize.element({
        id: getRootId2(scope),
        ...parts4.root.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts4.label.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        id: getLabelId(scope),
        htmlFor: getInputId(scope)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts4.control.attrs,
        dir: prop("dir"),
        role: "group",
        "aria-disabled": disabled,
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(invalid)
      });
    },
    getValueTextProps() {
      return normalize.element({
        ...parts4.valueText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize.input({
        ...parts4.input.attrs,
        dir: prop("dir"),
        name: prop("name"),
        form: prop("form"),
        id: getInputId(scope),
        role: "spinbutton",
        defaultValue: computed("formattedValue"),
        pattern: prop("pattern"),
        inputMode: prop("inputMode"),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly,
        required: prop("required"),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": prop("min"),
        "aria-valuemax": prop("max"),
        "aria-valuenow": Number.isNaN(computed("valueAsNumber")) ? void 0 : computed("valueAsNumber"),
        "aria-valuetext": computed("valueText"),
        onFocus() {
          send({ type: "INPUT.FOCUS" });
        },
        onBlur() {
          send({ type: "INPUT.BLUR" });
        },
        onInput(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = computed("parser").isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (readOnly) return;
          if (isComposingEvent(event)) return;
          const step = getEventStep(event) * prop("step");
          const keyMap2 = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              if (isModifierKey(event)) return;
              send({ type: "INPUT.HOME" });
              event.preventDefault();
            },
            End() {
              if (isModifierKey(event)) return;
              send({ type: "INPUT.END" });
              event.preventDefault();
            },
            Enter() {
              send({ type: "INPUT.ENTER" });
            }
          };
          const exec = keyMap2[event.key];
          exec?.(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize.button({
        ...parts4.decrementTrigger.attrs,
        dir: prop("dir"),
        id: getDecrementTriggerId(scope),
        disabled: isDecrementDisabled,
        "data-disabled": dataAttr(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": getInputId(scope),
        onPointerDown(event) {
          if (isDecrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            event.currentTarget?.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled) return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize.button({
        ...parts4.incrementTrigger.attrs,
        dir: prop("dir"),
        id: getIncrementTriggerId(scope),
        disabled: isIncrementDisabled,
        "data-disabled": dataAttr(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": getInputId(scope),
        onPointerDown(event) {
          if (isIncrementDisabled || !isLeftClick(event)) return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            event.currentTarget?.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize.element({
        ...parts4.scrubber.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(disabled),
        id: getScrubberId(scope),
        role: "presentation",
        onMouseDown(event) {
          if (disabled) return;
          const point = getEventPoint(event);
          const win = getWindow(event.currentTarget);
          const dpr = win.devicePixelRatio;
          point.x = point.x - roundToDpr(7.5, dpr);
          point.y = point.y - roundToDpr(7.5, dpr);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}
function recordCursor(inputEl) {
  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (!inputEl || inputEl.ownerDocument.activeElement !== inputEl) return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options2 = {}) => {
  return new Intl.NumberFormat(locale, options2);
};
var createParser = (locale, options2 = {}) => {
  return new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options2);
};
var parseValue = (value, params) => {
  const { prop, computed } = params;
  if (!prop("formatOptions")) return parseFloat(value);
  return computed("parser").parse(String(value));
};
var formatValue = (value, params) => {
  const { prop, computed } = params;
  if (Number.isNaN(value)) return "";
  if (!prop("formatOptions")) return value.toString();
  return computed("formatter").format(value);
};
var { choose, guards, createMachine: createMachine4 } = setup();
var { not: not2, and } = guards;
var machine3 = createMachine4({
  props({ props: props22 }) {
    return {
      dir: "ltr",
      locale: "en-US",
      focusInputOnChange: true,
      clampValueOnBlur: !props22.allowOverflow,
      allowOverflow: false,
      inputMode: "decimal",
      pattern: "[0-9]*(.[0-9]+)?",
      defaultValue: "",
      step: 1,
      min: Number.MIN_SAFE_INTEGER,
      max: Number.MAX_SAFE_INTEGER,
      spinOnPress: true,
      ...props22,
      translations: {
        incrementLabel: "increment value",
        decrementLabel: "decrease value",
        ...props22.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  context({ prop, bindable, getComputed }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          const computed = getComputed();
          prop("onValueChange")?.({ value, valueAsNumber: computed("valueAsNumber") });
        }
      })),
      hint: bindable(() => ({ defaultValue: null })),
      scrubberCursorPoint: bindable(() => ({
        defaultValue: null,
        hash(value) {
          return value ? `x:${value.x}, y:${value.y}` : "";
        }
      })),
      fieldsetDisabled: bindable(() => ({ defaultValue: false }))
    };
  },
  computed: {
    isRtl: ({ prop }) => prop("dir") === "rtl",
    valueAsNumber: ({ context, computed, prop }) => parseValue(context.get("value"), { computed, prop }),
    formattedValue: ({ computed, prop }) => formatValue(computed("valueAsNumber"), { computed, prop }),
    isAtMin: ({ computed, prop }) => isValueAtMin(computed("valueAsNumber"), prop("min")),
    isAtMax: ({ computed, prop }) => isValueAtMax(computed("valueAsNumber"), prop("max")),
    isOutOfRange: ({ computed, prop }) => !isValueWithinRange(computed("valueAsNumber"), prop("min"), prop("max")),
    isValueEmpty: ({ context }) => context.get("value") === "",
    isDisabled: ({ prop, context }) => !!prop("disabled") || context.get("fieldsetDisabled"),
    canIncrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMax"),
    canDecrement: ({ prop, computed }) => prop("allowOverflow") || !computed("isAtMin"),
    valueText: ({ prop, context }) => prop("translations").valueText?.(context.get("value")),
    formatter: memo(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => createFormatter(locale, formatOptions)
    ),
    parser: memo(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => createParser(locale, formatOptions)
    )
  },
  watch({ track, action, context, computed, prop }) {
    track([() => context.get("value"), () => prop("locale")], () => {
      action(["syncInputElement"]);
    });
    track([() => computed("isOutOfRange")], () => {
      action(["invokeOnInvalid"]);
    });
    track([() => context.hash("scrubberCursorPoint")], () => {
      action(["setVirtualCursorPosition"]);
    });
  },
  effects: ["trackFormControl"],
  on: {
    "VALUE.SET": {
      actions: ["setRawValue"]
    },
    "VALUE.CLEAR": {
      actions: ["clearValue"]
    },
    "VALUE.INCREMENT": {
      actions: ["increment"]
    },
    "VALUE.DECREMENT": {
      actions: ["decrement"]
    }
  },
  states: {
    idle: {
      on: {
        "TRIGGER.PRESS_DOWN": [
          { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
          {
            target: "before:spin",
            actions: ["focusInput", "invokeOnFocus", "setHint"]
          }
        ],
        "SCRUBBER.PRESS_DOWN": {
          target: "scrubbing",
          actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
        },
        "INPUT.FOCUS": {
          target: "focused",
          actions: ["focusInput", "invokeOnFocus"]
        }
      }
    },
    focused: {
      tags: ["focus"],
      effects: ["attachWheelListener"],
      on: {
        "TRIGGER.PRESS_DOWN": [
          { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
          { target: "before:spin", actions: ["focusInput", "setHint"] }
        ],
        "SCRUBBER.PRESS_DOWN": {
          target: "scrubbing",
          actions: ["focusInput", "setHint", "setCursorPoint"]
        },
        "INPUT.ARROW_UP": {
          actions: ["increment"]
        },
        "INPUT.ARROW_DOWN": {
          actions: ["decrement"]
        },
        "INPUT.HOME": {
          actions: ["decrementToMin"]
        },
        "INPUT.END": {
          actions: ["incrementToMax"]
        },
        "INPUT.CHANGE": {
          actions: ["setValue", "setHint"]
        },
        "INPUT.BLUR": [
          {
            guard: and("clampValueOnBlur", not2("isInRange")),
            target: "idle",
            actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
          },
          {
            guard: not2("isInRange"),
            target: "idle",
            actions: ["setFormattedValue", "clearHint", "invokeOnBlur", "invokeOnInvalid"]
          },
          {
            target: "idle",
            actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
          }
        ],
        "INPUT.ENTER": {
          actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
        }
      }
    },
    "before:spin": {
      tags: ["focus"],
      effects: ["trackButtonDisabled", "waitForChangeDelay"],
      entry: choose([
        { guard: "isIncrementHint", actions: ["increment"] },
        { guard: "isDecrementHint", actions: ["decrement"] }
      ]),
      on: {
        CHANGE_DELAY: {
          target: "spinning",
          guard: and("isInRange", "spinOnPress")
        },
        "TRIGGER.PRESS_UP": [
          { guard: "isTouchPointer", target: "focused", actions: ["clearHint"] },
          { target: "focused", actions: ["focusInput", "clearHint"] }
        ]
      }
    },
    spinning: {
      tags: ["focus"],
      effects: ["trackButtonDisabled", "spinValue"],
      on: {
        SPIN: [
          {
            guard: "isIncrementHint",
            actions: ["increment"]
          },
          {
            guard: "isDecrementHint",
            actions: ["decrement"]
          }
        ],
        "TRIGGER.PRESS_UP": {
          target: "focused",
          actions: ["focusInput", "clearHint"]
        }
      }
    },
    scrubbing: {
      tags: ["focus"],
      effects: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
      on: {
        "SCRUBBER.POINTER_UP": {
          target: "focused",
          actions: ["focusInput", "clearCursorPoint"]
        },
        "SCRUBBER.POINTER_MOVE": [
          {
            guard: "isIncrementHint",
            actions: ["increment", "setCursorPoint"]
          },
          {
            guard: "isDecrementHint",
            actions: ["decrement", "setCursorPoint"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      clampValueOnBlur: ({ prop }) => prop("clampValueOnBlur"),
      spinOnPress: ({ prop }) => !!prop("spinOnPress"),
      isInRange: ({ computed }) => !computed("isOutOfRange"),
      isDecrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "decrement",
      isIncrementHint: ({ context, event }) => (event.hint ?? context.get("hint")) === "increment",
      isTouchPointer: ({ event }) => event.pointerType === "touch"
    },
    effects: {
      waitForChangeDelay({ send }) {
        const id = setTimeout(() => {
          send({ type: "CHANGE_DELAY" });
        }, 300);
        return () => clearTimeout(id);
      },
      spinValue({ send }) {
        const id = setInterval(() => {
          send({ type: "SPIN" });
        }, 50);
        return () => clearInterval(id);
      },
      trackFormControl({ context, scope }) {
        const inputEl = getInputEl(scope);
        return trackFormControl(inputEl, {
          onFieldsetDisabledChange(disabled) {
            context.set("fieldsetDisabled", disabled);
          },
          onFormReset() {
            context.set("value", context.initial("value"));
          }
        });
      },
      setupVirtualCursor({ context, scope }) {
        const point = context.get("scrubberCursorPoint");
        return setupVirtualCursor(scope, point);
      },
      preventTextSelection({ scope }) {
        return preventTextSelection(scope);
      },
      trackButtonDisabled({ context, scope, send }) {
        const hint = context.get("hint");
        const btn = getPressedTriggerEl(scope, hint);
        return observeAttributes(btn, {
          attributes: ["disabled"],
          callback() {
            send({ type: "TRIGGER.PRESS_UP", src: "attr" });
          }
        });
      },
      attachWheelListener({ scope, send, prop }) {
        const inputEl = getInputEl(scope);
        if (!inputEl || !scope.isActiveElement(inputEl) || !prop("allowMouseWheel")) return;
        function onWheel(event) {
          event.preventDefault();
          const dir = Math.sign(event.deltaY) * -1;
          if (dir === 1) {
            send({ type: "VALUE.INCREMENT" });
          } else if (dir === -1) {
            send({ type: "VALUE.DECREMENT" });
          }
        }
        return addDomEvent(inputEl, "wheel", onWheel, { passive: false });
      },
      activatePointerLock({ scope }) {
        if (isSafari()) return;
        return requestPointerLock(scope.getDoc());
      },
      trackMousemove({ scope, send, context, computed }) {
        const doc = scope.getDoc();
        function onMousemove(event) {
          const point = context.get("scrubberCursorPoint");
          const isRtl = computed("isRtl");
          const value = getMousemoveValue(scope, { point, isRtl, event });
          if (!value.hint) return;
          send({
            type: "SCRUBBER.POINTER_MOVE",
            hint: value.hint,
            point: value.point
          });
        }
        function onMouseup() {
          send({ type: "SCRUBBER.POINTER_UP" });
        }
        return callAll(addDomEvent(doc, "mousemove", onMousemove, false), addDomEvent(doc, "mouseup", onMouseup, false));
      }
    },
    actions: {
      focusInput({ scope, prop }) {
        if (!prop("focusInputOnChange")) return;
        const inputEl = getInputEl(scope);
        if (scope.isActiveElement(inputEl)) return;
        raf(() => inputEl?.focus({ preventScroll: true }));
      },
      increment({ context, event, prop, computed }) {
        let nextValue = incrementValue(computed("valueAsNumber"), event.step ?? prop("step"));
        if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      decrement({ context, event, prop, computed }) {
        let nextValue = decrementValue(computed("valueAsNumber"), event.step ?? prop("step"));
        if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setClampedValue({ context, prop, computed }) {
        const nextValue = clampValue(computed("valueAsNumber"), prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setRawValue({ context, event, prop, computed }) {
        let nextValue = parseValue(event.value, { computed, prop });
        if (!prop("allowOverflow")) nextValue = clampValue(nextValue, prop("min"), prop("max"));
        context.set("value", formatValue(nextValue, { computed, prop }));
      },
      setValue({ context, event }) {
        const value = event.target?.value ?? event.value;
        context.set("value", value);
      },
      clearValue({ context }) {
        context.set("value", "");
      },
      incrementToMax({ context, prop, computed }) {
        const value = formatValue(prop("max"), { computed, prop });
        context.set("value", value);
      },
      decrementToMin({ context, prop, computed }) {
        const value = formatValue(prop("min"), { computed, prop });
        context.set("value", value);
      },
      setHint({ context, event }) {
        context.set("hint", event.hint);
      },
      clearHint({ context }) {
        context.set("hint", null);
      },
      invokeOnFocus({ computed, prop }) {
        prop("onFocusChange")?.({
          focused: true,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      invokeOnBlur({ computed, prop }) {
        prop("onFocusChange")?.({
          focused: false,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      invokeOnInvalid({ computed, prop, event }) {
        if (event.type === "INPUT.CHANGE") return;
        const reason = computed("valueAsNumber") > prop("max") ? "rangeOverflow" : "rangeUnderflow";
        prop("onValueInvalid")?.({
          reason,
          value: computed("formattedValue"),
          valueAsNumber: computed("valueAsNumber")
        });
      },
      syncInputElement({ context, event, computed, scope }) {
        const value = event.type.endsWith("CHANGE") ? context.get("value") : computed("formattedValue");
        const inputEl = getInputEl(scope);
        const sel = recordCursor(inputEl);
        raf(() => {
          setElementValue(inputEl, value);
          restoreCursor(inputEl, sel);
        });
      },
      setFormattedValue({ context, computed }) {
        context.set("value", computed("formattedValue"));
      },
      setCursorPoint({ context, event }) {
        context.set("scrubberCursorPoint", event.point);
      },
      clearCursorPoint({ context }) {
        context.set("scrubberCursorPoint", null);
      },
      setVirtualCursorPosition({ context, scope }) {
        const cursorEl = getCursorEl(scope);
        const point = context.get("scrubberCursorPoint");
        if (!cursorEl || !point) return;
        cursorEl.style.transform = `translate3d(${point.x}px, ${point.y}px, 0px)`;
      }
    }
  }
});
var props2 = createProps2()([
  "allowMouseWheel",
  "allowOverflow",
  "clampValueOnBlur",
  "dir",
  "disabled",
  "focusInputOnChange",
  "form",
  "formatOptions",
  "getRootNode",
  "id",
  "ids",
  "inputMode",
  "invalid",
  "locale",
  "max",
  "min",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueInvalid",
  "pattern",
  "required",
  "readOnly",
  "spinOnPress",
  "step",
  "translations",
  "value",
  "defaultValue"
]);
var splitProps3 = createSplitProps2(props2);

// ../../../node_modules/@ark-ui/solid/dist/chunk/SRPSYZUL.js
var [NumberInputProvider, useNumberInputContext] = createContext2({
  hookName: "useNumberInputContext",
  providerName: "<NumberInputProvider />"
});
var NumberInputContext = (props7) => props7.children(useNumberInputContext());
var NumberInputControl = (props7) => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps22(() => api().getControlProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var NumberInputDecrementTrigger = (props7) => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps22(() => api().getDecrementTriggerProps(), props7);
  return createComponent(ark.button, mergedProps);
};
var NumberInputIncrementTrigger = (props7) => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps22(() => api().getIncrementTriggerProps(), props7);
  return createComponent(ark.button, mergedProps);
};
var NumberInputInput = (props7) => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps22(() => api().getInputProps(), props7);
  const field = useFieldContext();
  return createComponent(ark.input, mergeProps({
    get ["aria-describedby"]() {
      return field?.().ariaDescribedby;
    }
  }, mergedProps));
};
var NumberInputLabel = (props7) => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps22(() => api().getLabelProps(), props7);
  return createComponent(ark.label, mergedProps);
};
var useNumberInput = (props7 = {}) => {
  const id = createUniqueId();
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const field = useFieldContext();
  const machineProps = createMemo(() => ({
    id,
    ids: {
      label: field?.().ids.label,
      input: field?.().ids.control
    },
    disabled: field?.().disabled,
    readOnly: field?.().readOnly,
    required: field?.().required,
    invalid: field?.().invalid,
    dir: locale().dir,
    locale: locale().locale,
    getRootNode: environment().getRootNode,
    ...props7
  }));
  const service = useMachine(machine3, machineProps);
  return createMemo(() => connect3(service, normalizeProps));
};
var NumberInputRoot = (props7) => {
  const [useNumberInputProps, localProps] = createSplitProps()(props7, ["allowMouseWheel", "allowOverflow", "clampValueOnBlur", "defaultValue", "disabled", "focusInputOnChange", "form", "formatOptions", "id", "ids", "inputMode", "invalid", "locale", "max", "min", "name", "onFocusChange", "onValueChange", "onValueInvalid", "pattern", "readOnly", "required", "spinOnPress", "step", "translations", "value"]);
  const api = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps22(() => api().getRootProps(), localProps);
  return createComponent(NumberInputProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var NumberInputRootProvider = (props7) => {
  const [{
    value: numberInput2
  }, localProps] = createSplitProps()(props7, ["value"]);
  const mergedProps = mergeProps22(() => numberInput2().getRootProps(), localProps);
  return createComponent(NumberInputProvider, {
    value: numberInput2,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var NumberInputScrubber = (props7) => {
  const api = useNumberInputContext();
  const mergedProps = mergeProps22(() => api().getScrubberProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var NumberInputValueText = (props7) => {
  const numberInput2 = useNumberInputContext();
  const mergedProps = mergeProps22(() => numberInput2().getValueTextProps(), props7);
  return createComponent(ark.span, mergedProps);
};
var number_input_exports = {};
__export2(number_input_exports, {
  Context: () => NumberInputContext,
  Control: () => NumberInputControl,
  DecrementTrigger: () => NumberInputDecrementTrigger,
  IncrementTrigger: () => NumberInputIncrementTrigger,
  Input: () => NumberInputInput,
  Label: () => NumberInputLabel,
  Root: () => NumberInputRoot,
  RootProvider: () => NumberInputRootProvider,
  Scrubber: () => NumberInputScrubber,
  ValueText: () => NumberInputValueText
});

// ../../../node_modules/@zag-js/menu/node_modules/@zag-js/core/dist/index.mjs
var clsx2 = (...args) => args.map((str) => str?.trim?.()).filter(Boolean).join(" ");
var CSS_REGEX2 = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize2 = (style2) => {
  const res = {};
  let match2;
  while (match2 = CSS_REGEX2.exec(style2)) {
    res[match2[1]] = match2[2];
  }
  return res;
};
var css2 = (a, b) => {
  if (isString(a)) {
    if (isString(b)) return `${a};${b}`;
    a = serialize2(a);
  } else if (isString(b)) {
    b = serialize2(b);
  }
  return Object.assign({}, a ?? {}, b ?? {});
};
function mergeProps3(...args) {
  let result = {};
  for (let props7 of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props7[key] === "function") {
        result[key] = callAll(props7[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx2(result[key], props7[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css2(result[key], props7[key]);
        continue;
      }
      result[key] = props7[key] !== void 0 ? props7[key] : result[key];
    }
    for (let key in props7) {
      if (result[key] === void 0) {
        result[key] = props7[key];
      }
    }
  }
  return result;
}
function createGuards3() {
  return {
    and: (...guards2) => {
      return function andGuard(params) {
        return guards2.every((str) => params.guard(str));
      };
    },
    or: (...guards2) => {
      return function orGuard(params) {
        return guards2.some((str) => params.guard(str));
      };
    },
    not: (guard) => {
      return function notGuard(params) {
        return !params.guard(guard);
      };
    }
  };
}
function createMachine5(config) {
  return config;
}

// ../../../node_modules/@zag-js/rect-utils/dist/index.mjs
var createPoint = (x, y) => ({ x, y });
function createRect(r2) {
  const { x, y, width, height } = r2;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function getRectCorners(v) {
  const top = createPoint(v.minX, v.minY);
  const right = createPoint(v.maxX, v.minY);
  const bottom = createPoint(v.maxX, v.maxY);
  const left = createPoint(v.minX, v.maxY);
  return { top, right, bottom, left };
}
var { min: min3, max: max3 } = Math;
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point) {
  const { x, y } = point;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
var { sign: sign2, abs: abs2, min: min22 } = Math;

// ../../../node_modules/@zag-js/menu/dist/index.mjs
var anatomy3 = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts5 = anatomy3.build();
var getTriggerId = (ctx) => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`;
var getContextTriggerId = (ctx) => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`;
var getContentId = (ctx) => ctx.ids?.content ?? `menu:${ctx.id}:content`;
var getArrowId = (ctx) => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`;
var getPositionerId = (ctx) => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`;
var getGroupId = (ctx, id) => ctx.ids?.group?.(id) ?? `menu:${ctx.id}:group:${id}`;
var getGroupLabelId = (ctx, id) => ctx.ids?.groupLabel?.(id) ?? `menu:${ctx.id}:group-label:${id}`;
var getContentEl = (ctx) => ctx.getById(getContentId(ctx));
var getPositionerEl = (ctx) => ctx.getById(getPositionerId(ctx));
var getTriggerEl = (ctx) => ctx.getById(getTriggerId(ctx));
var getItemEl = (ctx, value) => value ? ctx.getById(value) : null;
var getContextTriggerEl = (ctx) => ctx.getById(getContextTriggerId(ctx));
var getElements = (ctx) => {
  const ownerId = CSS.escape(getContentId(ctx));
  const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
  return queryAll(getContentEl(ctx), selector);
};
var getFirstEl = (ctx) => first(getElements(ctx));
var getLastEl = (ctx) => last(getElements(ctx));
var getNextEl = (ctx, opts) => nextById(getElements(ctx), opts.value, opts.loop ?? opts.loopFocus);
var getPrevEl = (ctx, opts) => prevById(getElements(ctx), opts.value, opts.loop ?? opts.loopFocus);
var getElemByKey = (ctx, opts) => getByTypeahead(getElements(ctx), {
  state: opts.typeaheadState,
  key: opts.key,
  activeId: opts.value
});
var isTargetDisabled = (v) => {
  return isHTMLElement(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
};
var isTriggerItem = (el) => {
  return !!el?.getAttribute("role")?.startsWith("menuitem") && !!el?.hasAttribute("aria-controls");
};
function connect4(service, normalize) {
  const { context, send, state: state2, computed, prop, scope } = service;
  const open2 = state2.hasTag("open");
  const isSubmenu = computed("isSubmenu");
  const isTypingAhead = computed("isTypingAhead");
  const composite = prop("composite");
  const currentPlacement = context.get("currentPlacement");
  const anchorPoint = context.get("anchorPoint");
  const highlightedValue = context.get("highlightedValue");
  const popperStyles = getPlacementStyles({
    ...prop("positioning"),
    placement: anchorPoint ? "bottom" : currentPlacement
  });
  function getItemState(props22) {
    return {
      disabled: !!props22.disabled,
      highlighted: highlightedValue === props22.value
    };
  }
  function getOptionItemProps(props22) {
    const valueText = props22.valueText ?? props22.value;
    return { ...props22, id: props22.value, valueText };
  }
  function getOptionItemState(props22) {
    const itemState = getItemState(getOptionItemProps(props22));
    return {
      ...itemState,
      checked: !!props22.checked
    };
  }
  function getItemProps(props22) {
    const { value: id, closeOnSelect, valueText } = props22;
    const itemState = getItemState(props22);
    return normalize.element({
      ...parts5.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": itemState.disabled,
      "data-disabled": dataAttr(itemState.disabled),
      "data-ownedby": getContentId(scope),
      "data-highlighted": dataAttr(itemState.highlighted),
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink) event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const target = event.currentTarget;
        if (itemState.highlighted) return;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerLeave(event) {
        if (itemState.disabled) return;
        if (event.pointerType !== "mouse") return;
        const pointerMoved = service.event.previous()?.type.includes("POINTER");
        if (!pointerMoved) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onClick(event) {
        if (isDownloadingEvent(event)) return;
        if (isOpeningInNewTab(event)) return;
        if (itemState.disabled) return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", target, id, closeOnSelect });
      }
    });
  }
  return {
    highlightedValue,
    open: open2,
    setOpen(nextOpen) {
      if (nextOpen === open2) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", id: value });
    },
    setParent(parent2) {
      send({ type: "PARENT.SET", value: parent2, id: parent2.prop("id") });
    },
    setChild(child) {
      send({ type: "CHILD.SET", value: child, id: child.prop("id") });
    },
    reposition(options2 = {}) {
      send({ type: "POSITIONING.SET", options: options2 });
    },
    getContextTriggerProps() {
      return normalize.element({
        ...parts5.contextTrigger.attrs,
        dir: prop("dir"),
        id: getContextTriggerId(scope),
        onPointerDown(event) {
          if (event.pointerType === "mouse") return;
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse") return;
          send({ type: "CONTEXT_MENU_CANCEL" });
        },
        onContextMenu(event) {
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          WebkitUserSelect: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      return mergeProps3(
        getItemProps({ value: childApi.getTriggerProps().id }),
        childApi.getTriggerProps()
      );
    },
    getTriggerProps() {
      return normalize.button({
        ...isSubmenu ? parts5.triggerItem.attrs : parts5.trigger.attrs,
        "data-placement": context.get("currentPlacement"),
        type: "button",
        dir: prop("dir"),
        id: getTriggerId(scope),
        "data-uid": prop("id"),
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": getContentId(scope),
        "aria-expanded": open2 || void 0,
        "data-state": open2 ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse") return;
          const disabled = isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu) return;
          const point = getEventPoint(event);
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget, point });
        },
        onPointerLeave(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if (event.pointerType !== "mouse") return;
          if (!isSubmenu) return;
          const point = getEventPoint(event);
          send({
            type: "TRIGGER_POINTERLEAVE",
            target: event.currentTarget,
            point
          });
        },
        onPointerDown(event) {
          if (isTargetDisabled(event.currentTarget)) return;
          if (isContextMenuEvent(event)) return;
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented) return;
          if (isTargetDisabled(event.currentTarget)) return;
          send({ type: "TRIGGER_CLICK", target: event.currentTarget });
        },
        onBlur() {
          send({ type: "TRIGGER_BLUR" });
        },
        onFocus() {
          send({ type: "TRIGGER_FOCUS" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = getEventKey(event, {
            orientation: "vertical",
            dir: prop("dir")
          });
          const exec = keyMap2[key];
          if (exec) {
            event.preventDefault();
            exec(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts5.indicator.attrs,
        dir: prop("dir"),
        "data-state": open2 ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts5.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId(scope),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize.element({
        id: getArrowId(scope),
        ...parts5.arrow.attrs,
        dir: prop("dir"),
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize.element({
        ...parts5.arrowTip.attrs,
        dir: prop("dir"),
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts5.content.attrs,
        id: getContentId(scope),
        "aria-label": prop("aria-label"),
        hidden: !open2,
        "data-state": open2 ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: prop("dir"),
        "aria-activedescendant": highlightedValue ?? void 0,
        "aria-labelledby": getTriggerId(scope),
        "data-placement": currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse") return;
          send({ type: "MENU_POINTERENTER" });
        },
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          if (!isSelfTarget(event)) return;
          const target = getEventTarget(event);
          const sameMenu = target?.closest("[role=menu]") === event.currentTarget || target === event.currentTarget;
          if (!sameMenu) return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const item = getItemEl(scope, highlightedValue);
          const keyMap2 = {
            ArrowDown() {
              send({ type: "ARROW_DOWN" });
            },
            ArrowUp() {
              send({ type: "ARROW_UP" });
            },
            ArrowLeft() {
              send({ type: "ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT" });
            },
            Enter() {
              send({ type: "ENTER" });
              if (isAnchorElement(item)) {
                prop("navigate")?.({ value: highlightedValue, node: item });
              }
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                keyMap2.Enter?.(event2);
              }
            },
            Home() {
              send({ type: "HOME" });
            },
            End() {
              send({ type: "END" });
            }
          };
          const key = getEventKey(event, { dir: prop("dir") });
          const exec = keyMap2[key];
          if (exec) {
            exec(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!prop("typeahead")) return;
          if (!isPrintableKey(event)) return;
          if (isModifierKey(event)) return;
          if (isEditableElement(target)) return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize.element({
        ...parts5.separator.attrs,
        role: "separator",
        dir: prop("dir"),
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props22) {
      const { type, disabled, onCheckedChange, closeOnSelect } = props22;
      const option = getOptionItemProps(props22);
      const itemState = getOptionItemState(props22);
      return {
        ...getItemProps(option),
        ...normalize.element({
          "data-type": type,
          ...parts5.item.attrs,
          dir: prop("dir"),
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onClick(event) {
            if (disabled) return;
            if (isDownloadingEvent(event)) return;
            if (isOpeningInNewTab(event)) return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", target, option, closeOnSelect });
            onCheckedChange?.(!itemState.checked);
          }
        })
      };
    },
    getItemIndicatorProps(props22) {
      const itemState = getOptionItemState(props22);
      return normalize.element({
        ...parts5.itemIndicator.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked",
        hidden: !itemState.checked
      });
    },
    getItemTextProps(props22) {
      const itemState = getOptionItemState(props22);
      return normalize.element({
        ...parts5.itemText.attrs,
        dir: prop("dir"),
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked"
      });
    },
    getItemGroupLabelProps(props22) {
      return normalize.element({
        id: getGroupLabelId(scope, props22.htmlFor),
        dir: prop("dir"),
        ...parts5.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(props22) {
      return normalize.element({
        id: getGroupId(scope, props22.id),
        ...parts5.itemGroup.attrs,
        dir: prop("dir"),
        "aria-labelledby": getGroupLabelId(scope, props22.id),
        role: "group"
      });
    }
  };
}
var { not: not3, and: and2, or } = createGuards3();
var machine4 = createMachine5({
  props({ props: props22 }) {
    return {
      closeOnSelect: true,
      typeahead: true,
      composite: true,
      loopFocus: false,
      navigate(details) {
        clickIfLink(details.node);
      },
      ...props22,
      positioning: {
        placement: "bottom-start",
        gutter: 8,
        ...props22.positioning
      }
    };
  },
  initialState({ prop }) {
    const open2 = prop("open") || prop("defaultOpen");
    return open2 ? "open" : "idle";
  },
  context({ bindable, prop }) {
    return {
      suspendPointer: bindable(() => ({
        defaultValue: false
      })),
      highlightedValue: bindable(() => ({
        defaultValue: prop("defaultHighlightedValue") || null,
        value: prop("highlightedValue"),
        onChange(value) {
          prop("onHighlightChange")?.({ highlightedValue: value });
        }
      })),
      lastHighlightedValue: bindable(() => ({
        defaultValue: null
      })),
      currentPlacement: bindable(() => ({
        defaultValue: void 0
      })),
      intentPolygon: bindable(() => ({
        defaultValue: null
      })),
      anchorPoint: bindable(() => ({
        defaultValue: null,
        hash(value) {
          return `x: ${value?.x}, y: ${value?.y}`;
        }
      }))
    };
  },
  refs() {
    return {
      parent: null,
      children: {},
      typeaheadState: { ...getByTypeahead.defaultOptions },
      positioningOverride: {}
    };
  },
  computed: {
    isSubmenu: ({ refs }) => refs.get("parent") != null,
    isRtl: ({ prop }) => prop("dir") === "rtl",
    isTypingAhead: ({ refs }) => refs.get("typeaheadState").keysSoFar !== ""
  },
  watch({ track, action, context, computed, prop }) {
    track([() => computed("isSubmenu")], () => {
      action(["setSubmenuPlacement"]);
    });
    track([() => context.hash("anchorPoint")], () => {
      action(["reposition"]);
    });
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  on: {
    "PARENT.SET": {
      actions: ["setParentMenu"]
    },
    "CHILD.SET": {
      actions: ["setChildMenu"]
    },
    OPEN: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        target: "open",
        actions: ["invokeOnOpen"]
      }
    ],
    OPEN_AUTOFOCUS: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnOpen"]
      },
      {
        // internal: true,
        target: "open",
        actions: ["highlightFirstItem", "invokeOnOpen"]
      }
    ],
    CLOSE: [
      {
        guard: "isOpenControlled",
        actions: ["invokeOnClose"]
      },
      {
        target: "closed",
        actions: ["invokeOnClose"]
      }
    ],
    "HIGHLIGHTED.RESTORE": {
      actions: ["restoreHighlightedItem"]
    },
    "HIGHLIGHTED.SET": {
      actions: ["setHighlightedItem"]
    }
  },
  states: {
    idle: {
      tags: ["closed"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_FOCUS: {
          guard: not3("isSubmenu"),
          target: "closed"
        },
        TRIGGER_POINTERMOVE: {
          guard: "isSubmenu",
          target: "opening"
        }
      }
    },
    "opening:contextmenu": {
      tags: ["closed"],
      effects: ["waitForLongPress"],
      on: {
        "CONTROLLED.OPEN": { target: "open" },
        "CONTROLLED.CLOSE": { target: "closed" },
        CONTEXT_MENU_CANCEL: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "LONG_PRESS.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    opening: {
      tags: ["closed"],
      effects: ["waitForOpenDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        BLUR: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TRIGGER_POINTERLEAVE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        "DELAY.OPEN": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    },
    closing: {
      tags: ["open"],
      effects: ["trackPointerMove", "trackInteractOutside", "waitForCloseDelay"],
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        "CONTROLLED.CLOSE": {
          target: "closed",
          actions: ["focusParentMenu", "restoreParentHighlightedItem"]
        },
        // don't invoke on open here since the menu is still open (we're only keeping it open)
        MENU_POINTERENTER: {
          target: "open",
          actions: ["clearIntentPolygon"]
        },
        POINTER_MOVED_AWAY_FROM_SUBMENU: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem"]
          }
        ],
        "DELAY.CLOSE": [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["focusParentMenu", "restoreParentHighlightedItem", "invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      tags: ["closed"],
      entry: ["clearHighlightedItem", "focusTrigger", "resumePointer"],
      on: {
        "CONTROLLED.OPEN": [
          {
            guard: or("isOpenAutoFocusEvent", "isArrowDownEvent"),
            target: "open",
            actions: ["highlightFirstItem"]
          },
          {
            guard: "isArrowUpEvent",
            target: "open",
            actions: ["highlightLastItem"]
          },
          {
            target: "open"
          }
        ],
        CONTEXT_MENU_START: {
          target: "opening:contextmenu",
          actions: ["setAnchorPoint"]
        },
        CONTEXT_MENU: [
          {
            guard: "isOpenControlled",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["setAnchorPoint", "invokeOnOpen"]
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          target: "opening"
        },
        TRIGGER_BLUR: { target: "idle" },
        ARROW_DOWN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        ARROW_UP: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["highlightLastItem", "invokeOnOpen"]
          }
        ]
      }
    },
    open: {
      tags: ["open"],
      effects: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
      entry: ["focusMenu", "resumePointer"],
      on: {
        "CONTROLLED.CLOSE": [
          {
            target: "closed",
            guard: "isArrowLeftEvent",
            actions: ["focusParentMenu"]
          },
          {
            target: "closed"
          }
        ],
        TRIGGER_CLICK: [
          {
            guard: and2(not3("isTriggerItem"), "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: not3("isTriggerItem"),
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        CONTEXT_MENU: {
          actions: ["setAnchorPoint", "focusMenu"]
        },
        ARROW_UP: {
          actions: ["highlightPrevItem", "focusMenu"]
        },
        ARROW_DOWN: {
          actions: ["highlightNextItem", "focusMenu"]
        },
        ARROW_LEFT: [
          {
            guard: and2("isSubmenu", "isOpenControlled"),
            actions: ["invokeOnClose"]
          },
          {
            guard: "isSubmenu",
            target: "closed",
            actions: ["focusParentMenu", "invokeOnClose"]
          }
        ],
        HOME: {
          actions: ["highlightFirstItem", "focusMenu"]
        },
        END: {
          actions: ["highlightLastItem", "focusMenu"]
        },
        ARROW_RIGHT: {
          guard: "isTriggerItemHighlighted",
          actions: ["openSubmenu"]
        },
        ENTER: [
          {
            guard: "isTriggerItemHighlighted",
            actions: ["openSubmenu"]
          },
          {
            actions: ["clickHighlightedItem"]
          }
        ],
        ITEM_POINTERMOVE: [
          {
            guard: not3("isPointerSuspended"),
            actions: ["setHighlightedItem", "focusMenu"]
          },
          {
            actions: ["setLastHighlightedItem"]
          }
        ],
        ITEM_POINTERLEAVE: {
          guard: and2(not3("isPointerSuspended"), not3("isTriggerItem")),
          actions: ["clearHighlightedItem"]
        },
        ITEM_CLICK: [
          // == grouped ==
          {
            guard: and2(
              not3("isTriggerItemHighlighted"),
              not3("isHighlightedItemEditable"),
              "closeOnSelect",
              "isOpenControlled"
            ),
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          {
            guard: and2(not3("isTriggerItemHighlighted"), not3("isHighlightedItemEditable"), "closeOnSelect"),
            target: "closed",
            actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
          },
          //
          {
            guard: and2(not3("isTriggerItemHighlighted"), not3("isHighlightedItemEditable")),
            actions: ["invokeOnSelect", "setOptionState"]
          },
          { actions: ["setHighlightedItem"] }
        ],
        TRIGGER_POINTERMOVE: {
          guard: "isTriggerItem",
          actions: ["setIntentPolygon"]
        },
        TRIGGER_POINTERLEAVE: {
          target: "closing"
        },
        ITEM_POINTERDOWN: {
          actions: ["setHighlightedItem"]
        },
        TYPEAHEAD: {
          actions: ["highlightMatchedItem"]
        },
        FOCUS_MENU: {
          actions: ["focusMenu"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      }
    }
  },
  implementations: {
    guards: {
      closeOnSelect: ({ prop, event }) => !!(event?.closeOnSelect ?? prop("closeOnSelect")),
      // whether the trigger is also a menu item
      isTriggerItem: ({ event }) => isTriggerItem(event.target),
      // whether the trigger item is the active item
      isTriggerItemHighlighted: ({ event, scope, context }) => {
        const target = event.target ?? getItemEl(scope, context.get("highlightedValue"));
        return !!target?.hasAttribute("aria-controls");
      },
      isSubmenu: ({ computed }) => computed("isSubmenu"),
      isPointerSuspended: ({ context }) => context.get("suspendPointer"),
      isHighlightedItemEditable: ({ context, scope }) => isEditableElement(getItemEl(scope, context.get("highlightedValue"))),
      // guard assertions (for controlled mode)
      isOpenControlled: ({ prop }) => prop("open") !== void 0,
      isArrowLeftEvent: ({ event }) => event.previousEvent?.type === "ARROW_LEFT",
      isArrowUpEvent: ({ event }) => event.previousEvent?.type === "ARROW_UP",
      isArrowDownEvent: ({ event }) => event.previousEvent?.type === "ARROW_DOWN",
      isOpenAutoFocusEvent: ({ event }) => event.previousEvent?.type === "OPEN_AUTOFOCUS"
    },
    effects: {
      waitForOpenDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.OPEN" });
        }, 100);
        return () => clearTimeout(timer);
      },
      waitForCloseDelay({ send }) {
        const timer = setTimeout(() => {
          send({ type: "DELAY.CLOSE" });
        }, 300);
        return () => clearTimeout(timer);
      },
      waitForLongPress({ send }) {
        const timer = setTimeout(() => {
          send({ type: "LONG_PRESS.OPEN" });
        }, 700);
        return () => clearTimeout(timer);
      },
      trackPositioning({ context, prop, scope, refs }) {
        if (!!getContextTriggerEl(scope)) return;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        context.set("currentPlacement", positioning.placement);
        const getPositionerEl22 = () => getPositionerEl(scope);
        return getPlacement(getTriggerEl(scope), getPositionerEl22, {
          ...positioning,
          defer: true,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      trackInteractOutside({ refs, scope, prop, computed, send }) {
        const getContentEl22 = () => getContentEl(scope);
        let restoreFocus = true;
        return trackDismissableElement(getContentEl22, {
          defer: true,
          exclude: [getTriggerEl(scope)],
          onInteractOutside: prop("onInteractOutside"),
          onFocusOutside: prop("onFocusOutside"),
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (computed("isSubmenu")) event.preventDefault();
            closeRootMenu({ parent: refs.get("parent") });
          },
          onPointerDownOutside(event) {
            const target = getEventTarget(event.detail.originalEvent);
            const isWithinContextTrigger = contains(getContextTriggerEl(scope), target);
            if (isWithinContextTrigger && event.detail.contextmenu) {
              event.preventDefault();
              return;
            }
            restoreFocus = !event.detail.focusable;
            prop("onPointerDownOutside")?.(event);
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside", restoreFocus });
          }
        });
      },
      trackPointerMove({ context, scope, send, refs, flush: flush2 }) {
        const parent2 = refs.get("parent");
        flush2(() => {
          parent2.context.set("suspendPointer", true);
        });
        const doc = scope.getDoc();
        return addDomEvent(doc, "pointermove", (e) => {
          const isMovingToSubmenu = isWithinPolygon(context.get("intentPolygon"), {
            x: e.clientX,
            y: e.clientY
          });
          if (!isMovingToSubmenu) {
            send({ type: "POINTER_MOVED_AWAY_FROM_SUBMENU" });
            parent2.context.set("suspendPointer", false);
          }
        });
      },
      scrollToHighlightedItem({ event, scope, context }) {
        const exec = () => {
          if (event.type.startsWith("ITEM_POINTER")) return;
          const itemEl = getItemEl(scope, context.get("highlightedValue"));
          const contentEl2 = getContentEl(scope);
          scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
        };
        raf(() => exec());
        const contentEl = () => getContentEl(scope);
        return observeAttributes(contentEl, {
          defer: true,
          attributes: ["aria-activedescendant"],
          callback: exec
        });
      }
    },
    actions: {
      setAnchorPoint({ context, event }) {
        context.set("anchorPoint", event.point);
      },
      setSubmenuPlacement({ computed, refs }) {
        if (!computed("isSubmenu")) return;
        const placement = computed("isRtl") ? "left-start" : "right-start";
        refs.set("positioningOverride", { placement, gutter: 0 });
      },
      reposition({ context, scope, prop, event, refs }) {
        const getPositionerEl22 = () => getPositionerEl(scope);
        const anchorPoint = context.get("anchorPoint");
        const getAnchorRect = anchorPoint ? () => ({ width: 0, height: 0, ...anchorPoint }) : void 0;
        const positioning = {
          ...prop("positioning"),
          ...refs.get("positioningOverride")
        };
        getPlacement(getTriggerEl(scope), getPositionerEl22, {
          ...positioning,
          defer: true,
          getAnchorRect,
          ...event.options ?? {},
          listeners: false,
          onComplete(data) {
            context.set("currentPlacement", data.placement);
          }
        });
      },
      setOptionState({ event }) {
        if (!event.option) return;
        const { checked, onCheckedChange, type } = event.option;
        if (type === "radio") {
          onCheckedChange?.(true);
        } else if (type === "checkbox") {
          onCheckedChange?.(!checked);
        }
      },
      clickHighlightedItem({ scope, context }) {
        const itemEl = getItemEl(scope, context.get("highlightedValue"));
        if (!itemEl || itemEl.dataset.disabled) return;
        queueMicrotask(() => itemEl.click());
      },
      setIntentPolygon({ context, scope, event }) {
        const menu = getContentEl(scope);
        const placement = context.get("currentPlacement");
        if (!menu || !placement) return;
        const rect = menu.getBoundingClientRect();
        const polygon = getElementPolygon(rect, placement);
        if (!polygon) return;
        const rightSide = getPlacementSide(placement) === "right";
        const bleed = rightSide ? -5 : 5;
        context.set("intentPolygon", [{ ...event.point, x: event.point.x + bleed }, ...polygon]);
      },
      clearIntentPolygon({ context }) {
        context.set("intentPolygon", null);
      },
      resumePointer({ refs, flush: flush2 }) {
        const parent2 = refs.get("parent");
        if (!parent2) return;
        flush2(() => {
          parent2.context.set("suspendPointer", false);
        });
      },
      setHighlightedItem({ context, event }) {
        context.set("highlightedValue", event.id);
      },
      clearHighlightedItem({ context }) {
        context.set("highlightedValue", null);
      },
      focusMenu({ scope }) {
        raf(() => {
          const contentEl = getContentEl(scope);
          const initialFocusEl = getInitialFocus({
            root: contentEl,
            enabled: !contains(contentEl, scope.getActiveElement()),
            filter(node) {
              return !node.role?.startsWith("menuitem");
            }
          });
          initialFocusEl?.focus({ preventScroll: true });
        });
      },
      highlightFirstItem({ context, scope }) {
        const fn = getContentEl(scope) ? queueMicrotask : raf;
        fn(() => {
          const first2 = getFirstEl(scope);
          if (!first2) return;
          context.set("highlightedValue", first2.id);
        });
      },
      highlightLastItem({ context, scope }) {
        const fn = getContentEl(scope) ? queueMicrotask : raf;
        fn(() => {
          const last2 = getLastEl(scope);
          if (!last2) return;
          context.set("highlightedValue", last2.id);
        });
      },
      highlightNextItem({ context, scope, event, prop }) {
        const next = getNextEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", next.id ?? null);
      },
      highlightPrevItem({ context, scope, event, prop }) {
        const prev = getPrevEl(scope, {
          loop: event.loop,
          value: context.get("highlightedValue"),
          loopFocus: prop("loopFocus")
        });
        context.set("highlightedValue", prev?.id ?? null);
      },
      invokeOnSelect({ context, prop }) {
        const value = context.get("highlightedValue");
        if (value == null) return;
        prop("onSelect")?.({ value });
      },
      focusTrigger({ scope, context, event, computed }) {
        if (computed("isSubmenu") || context.get("anchorPoint") || event.restoreFocus === false) return;
        queueMicrotask(() => getTriggerEl(scope)?.focus({ preventScroll: true }));
      },
      highlightMatchedItem({ scope, context, event, refs }) {
        const node = getElemByKey(scope, {
          key: event.key,
          value: context.get("highlightedValue"),
          typeaheadState: refs.get("typeaheadState")
        });
        if (!node) return;
        context.set("highlightedValue", node.id);
      },
      setParentMenu({ refs, event }) {
        refs.set("parent", event.value);
      },
      setChildMenu({ refs, event }) {
        const children2 = refs.get("children");
        children2[event.id] = event.value;
        refs.set("children", children2);
      },
      closeRootMenu({ refs }) {
        closeRootMenu({ parent: refs.get("parent") });
      },
      openSubmenu({ refs, scope, context }) {
        const item = getItemEl(scope, context.get("highlightedValue"));
        const id = item?.getAttribute("data-uid");
        const children2 = refs.get("children");
        const child = id ? children2[id] : null;
        child?.send({ type: "OPEN_AUTOFOCUS" });
      },
      focusParentMenu({ refs }) {
        refs.get("parent")?.send({ type: "FOCUS_MENU" });
      },
      setLastHighlightedItem({ context, event }) {
        context.set("lastHighlightedValue", event.id);
      },
      restoreHighlightedItem({ context }) {
        if (!context.get("lastHighlightedValue")) return;
        context.set("highlightedValue", context.get("lastHighlightedValue"));
        context.set("lastHighlightedValue", null);
      },
      restoreParentHighlightedItem({ refs }) {
        refs.get("parent")?.send({ type: "HIGHLIGHTED.RESTORE" });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      toggleVisibility({ prop, event, send }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
function closeRootMenu(ctx) {
  let parent2 = ctx.parent;
  while (parent2 && parent2.computed("isSubmenu")) {
    parent2 = parent2.refs.get("parent");
  }
  parent2?.send({ type: "CLOSE" });
}
function isWithinPolygon(polygon, point) {
  if (!polygon) return false;
  return isPointInPolygon(polygon, point);
}
var props3 = createProps2()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "composite",
  "defaultHighlightedValue",
  "defaultOpen",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "navigate",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onSelect",
  "open",
  "positioning",
  "typeahead"
]);
var splitProps4 = createSplitProps2(props3);
var itemProps = createProps2()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps = createSplitProps2(itemProps);
var itemGroupLabelProps = createProps2()(["htmlFor"]);
var splitItemGroupLabelProps = createSplitProps2(itemGroupLabelProps);
var itemGroupProps = createProps2()(["id"]);
var splitItemGroupProps = createSplitProps2(itemGroupProps);
var optionItemProps = createProps2()([
  "checked",
  "closeOnSelect",
  "disabled",
  "onCheckedChange",
  "type",
  "value",
  "valueText"
]);
var splitOptionItemProps = createSplitProps2(optionItemProps);

// ../../../node_modules/@ark-ui/solid/dist/chunk/4E5OPUFZ.js
var [MenuProvider, useMenuContext] = createContext2({
  hookName: "useMenuContext",
  providerName: "<MenuProvider />",
  strict: false
});
var MenuArrow = (props7) => {
  const context = useMenuContext();
  const mergedProps = mergeProps22(() => context().getArrowProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var MenuArrowTip = (props7) => {
  const context = useMenuContext();
  const mergedProps = mergeProps22(() => context().getArrowTipProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var [MenuItemProvider, useMenuItemContext] = createContext2({
  hookName: "useMenuItemContext",
  providerName: "<MenuItemProvider />"
});
var [MenuOptionItemPropsProvider, useMenuOptionItemPropsContext] = createContext2({
  hookName: "useMenuOptionItemPropsContext",
  providerName: "<MenuOptionItemPropsProvider />"
});
var MenuCheckboxItem = (props7) => {
  const [partialOptionItemProps, localProps] = createSplitProps()(props7, ["checked", "closeOnSelect", "disabled", "onCheckedChange", "value", "valueText"]);
  const optionItemProps2 = mergeProps22(partialOptionItemProps, {
    type: "checkbox"
  });
  const context = useMenuContext();
  const mergedProps = mergeProps22(() => context().getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = createMemo(() => context().getItemState(optionItemProps2));
  return createComponent(MenuOptionItemPropsProvider, {
    value: optionItemProps2,
    get children() {
      return createComponent(MenuItemProvider, {
        value: optionItemState,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};
var MenuContent = (props7) => {
  const context = useMenuContext();
  const presenceContext = usePresenceContext();
  const mergedProps = mergeProps22(() => context().getContentProps(), () => presenceContext().presenceProps, props7);
  return createComponent(Show, {
    get when() {
      return !presenceContext().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var MenuContext = (props7) => props7.children(useMenuContext());
var MenuContextTrigger = (props7) => {
  const context = useMenuContext();
  const mergedProps = mergeProps22(() => context().getContextTriggerProps(), props7);
  return createComponent(ark.button, mergedProps);
};
var MenuIndicator = (props7) => {
  const context = useMenuContext();
  const mergedProps = mergeProps22(() => context().getIndicatorProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var MenuItem = (props7) => {
  const [itemProps3, localProps] = createSplitProps()(props7, ["closeOnSelect", "disabled", "value", "valueText"]);
  const context = useMenuContext();
  const mergedProps = mergeProps22(() => context().getItemProps(itemProps3), localProps);
  const itemState = createMemo(() => context().getItemState(itemProps3));
  return createComponent(MenuItemProvider, {
    value: itemState,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var MenuItemContext = (props7) => props7.children(useMenuItemContext());
var [MenuItemGroupProvider, useMenuItemGroupContext] = createContext2({
  hookName: "useMenuItemGroupContext",
  providerName: "<MenuItemGroupProvider />"
});
var MenuItemGroup = (props7) => {
  const [optionalItemGroupProps, localProps] = createSplitProps()(props7, ["id"]);
  const itemGroupProps2 = mergeProps22({
    id: createUniqueId()
  }, optionalItemGroupProps);
  const menu2 = useMenuContext();
  const mergedProps = mergeProps22(() => menu2().getItemGroupProps(itemGroupProps2), localProps);
  return createComponent(MenuItemGroupProvider, {
    value: itemGroupProps2,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var MenuItemGroupLabel = (props7) => {
  const context = useMenuContext();
  const itemGroupContext = useMenuItemGroupContext();
  const mergedProps = mergeProps22(context().getItemGroupLabelProps({
    htmlFor: itemGroupContext.id
  }), props7);
  return createComponent(ark.div, mergedProps);
};
var MenuItemIndicator = (props7) => {
  const context = useMenuContext();
  const optionItemProps2 = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps22(() => context().getItemIndicatorProps(optionItemProps2), props7);
  return createComponent(ark.div, mergedProps);
};
var MenuItemText = (props7) => {
  const context = useMenuContext();
  const optionItemProps2 = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps22(() => context().getItemTextProps(optionItemProps2), props7);
  return createComponent(ark.div, mergedProps);
};
var MenuPositioner = (props7) => {
  const context = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps22(() => context().getPositionerProps(), props7);
  return createComponent(Show, {
    get when() {
      return !presence().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var MenuRadioItem = (props7) => {
  const [partialItemProps, localProps] = createSplitProps()(props7, ["closeOnSelect", "disabled", "value", "valueText"]);
  const context = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps2 = mergeProps22(partialItemProps, () => ({
    type: "radio",
    checked: itemGroup.value === partialItemProps.value,
    onCheckedChange: () => itemGroup.onValueChange?.({
      value: partialItemProps.value
    })
  }));
  const mergedProps = mergeProps22(() => context().getOptionItemProps(optionItemProps2), localProps);
  const optionItemState = createMemo(() => context().getOptionItemState(optionItemProps2));
  return createComponent(MenuOptionItemPropsProvider, {
    value: optionItemProps2,
    get children() {
      return createComponent(MenuItemProvider, {
        value: optionItemState,
        get children() {
          return createComponent(ark.div, mergedProps);
        }
      });
    }
  });
};
var MenuRadioItemGroup = (props7) => {
  const [optionalItemGroupProps, localProps] = createSplitProps()(props7, ["id", "onValueChange", "value"]);
  const context = useMenuContext();
  const itemGroupProps2 = mergeProps22({
    id: createUniqueId()
  }, optionalItemGroupProps);
  const mergedProps = mergeProps22(() => context().getItemGroupProps(itemGroupProps2), localProps);
  return createComponent(MenuItemGroupProvider, {
    value: itemGroupProps2,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var useMenu = (props7 = {}) => {
  const id = createUniqueId();
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const machineProps = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props7
  }));
  const service = useMachine(machine4, machineProps);
  const api = createMemo(() => connect4(service, normalizeProps));
  return {
    api,
    service
  };
};
var [MenuMachineProvider, useMenuMachineContext] = createContext2({
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});
var [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext2({
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});
var MenuRoot = (props7) => {
  const [presenceProps, menuProps] = splitPresenceProps(props7);
  const [useMenuProps, localProps] = createSplitProps()(menuProps, ["anchorPoint", "aria-label", "closeOnSelect", "composite", "defaultHighlightedValue", "defaultOpen", "highlightedValue", "id", "ids", "loopFocus", "navigate", "onEscapeKeyDown", "onFocusOutside", "onHighlightChange", "onInteractOutside", "onOpenChange", "onPointerDownOutside", "onSelect", "open", "positioning", "typeahead"]);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const menu2 = useMenu(useMenuProps);
  const presenceApi = usePresence(mergeProps22(presenceProps, () => ({
    present: menu2.api().open
  })));
  onMount(() => {
    if (!parentMachine) return;
    parentApi?.().setChild(menu2.service);
    menu2.api().setParent(parentMachine);
  });
  const triggerItemContext = () => parentApi?.().getTriggerItemProps(menu2.api());
  return createComponent(MenuTriggerItemProvider, {
    value: triggerItemContext,
    get children() {
      return createComponent(MenuMachineProvider, {
        get value() {
          return menu2.service;
        },
        get children() {
          return createComponent(MenuProvider, {
            get value() {
              return menu2.api;
            },
            get children() {
              return createComponent(PresenceProvider, {
                value: presenceApi,
                get children() {
                  return localProps.children;
                }
              });
            }
          });
        }
      });
    }
  });
};
var MenuRootProvider = (props7) => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, menuProps] = splitPresenceProps(props7);
  const presenceApi = usePresence(mergeProps22(presenceProps, () => ({
    present: menuProps.value.api().open
  })));
  createEffect(() => {
    if (!parentMachine) return;
    parentApi?.().setChild(menuProps.value.service);
    menuProps.value.api().setParent(parentMachine);
  });
  const triggerItemContext = () => parentApi?.().getTriggerItemProps(menuProps.value.api());
  return createComponent(MenuTriggerItemProvider, {
    value: triggerItemContext,
    get children() {
      return createComponent(MenuMachineProvider, {
        get value() {
          return menuProps.value.service;
        },
        get children() {
          return createComponent(MenuProvider, {
            get value() {
              return menuProps.value.api;
            },
            get children() {
              return createComponent(PresenceProvider, {
                value: presenceApi,
                get children() {
                  return menuProps.children;
                }
              });
            }
          });
        }
      });
    }
  });
};
var MenuSeparator = (props7) => {
  const menu2 = useMenuContext();
  const mergedProps = mergeProps22(() => menu2().getSeparatorProps(), props7);
  return createComponent(ark.hr, mergedProps);
};
var MenuTrigger = (props7) => {
  const api = useMenuContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps22(() => api().getTriggerProps(), () => ({
    "aria-controls": presenceApi().unmounted && null
  }), props7);
  return createComponent(ark.button, mergedProps);
};
var MenuTriggerItem = (props7) => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = mergeProps22(() => getTriggerItemProps?.(), props7);
  return createComponent(ark.div, mergedProps);
};
var menu_exports = {};
__export2(menu_exports, {
  Arrow: () => MenuArrow,
  ArrowTip: () => MenuArrowTip,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => MenuContent,
  Context: () => MenuContext,
  ContextTrigger: () => MenuContextTrigger,
  Indicator: () => MenuIndicator,
  Item: () => MenuItem,
  ItemContext: () => MenuItemContext,
  ItemGroup: () => MenuItemGroup,
  ItemGroupLabel: () => MenuItemGroupLabel,
  ItemIndicator: () => MenuItemIndicator,
  ItemText: () => MenuItemText,
  Positioner: () => MenuPositioner,
  RadioItem: () => MenuRadioItem,
  RadioItemGroup: () => MenuRadioItemGroup,
  Root: () => MenuRoot,
  RootProvider: () => MenuRootProvider,
  Separator: () => MenuSeparator,
  Trigger: () => MenuTrigger,
  TriggerItem: () => MenuTriggerItem
});

// ../../../node_modules/@zag-js/aria-hidden/dist/index.mjs
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
var correctTargets = (parent2, targets) => targets.map((target) => {
  if (parent2.contains(target)) return target;
  const correctedTarget = unwrapHost(target);
  if (correctedTarget && parent2.contains(correctedTarget)) {
    return correctedTarget;
  }
  console.error("[zag-js > ariaHidden] target", target, "in not contained inside", parent2, ". Doing nothing");
  return null;
}).filter((x) => Boolean(x));
var isIgnoredNode = (node) => {
  if (node.localName === "next-route-announcer") return true;
  if (node.localName === "script") return true;
  if (node.hasAttribute("aria-live")) return true;
  return node.matches("[data-live-announcer]");
};
var walkTreeOutside = (originalTarget, props7) => {
  const { parentNode, markerName, controlAttribute } = props7;
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  markerMap[markerName] || (markerMap[markerName] = /* @__PURE__ */ new WeakMap());
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el) => {
    if (!el || elementsToKeep.has(el)) return;
    elementsToKeep.add(el);
    keep(el.parentNode);
  };
  targets.forEach(keep);
  const deep = (parent2) => {
    if (!parent2 || elementsToStop.has(parent2)) {
      return;
    }
    Array.prototype.forEach.call(parent2.children, (node) => {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          if (isIgnoredNode(node)) return;
          const attr = node.getAttribute(controlAttribute);
          const alreadyHidden = attr === "true";
          const counterValue = (counterMap.get(node) || 0) + 1;
          const markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e) {
          console.error("[zag-js > ariaHidden] cannot operate on ", node, e);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return () => {
    hiddenNodes.forEach((node) => {
      const counterValue = counterMap.get(node) - 1;
      const markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var getParentNode3 = (originalTarget) => {
  const target = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return target.ownerDocument.body;
};
var hideOthers = (originalTarget, parentNode = getParentNode3(originalTarget), markerName = "data-aria-hidden") => {
  if (!parentNode) return;
  return walkTreeOutside(originalTarget, {
    parentNode,
    markerName,
    controlAttribute: "aria-hidden"
  });
};
var raf2 = (fn) => {
  const frameId = requestAnimationFrame(() => fn());
  return () => cancelAnimationFrame(frameId);
};
function ariaHidden(targetsOrFn, options2 = {}) {
  const { defer = true } = options2;
  const func = defer ? raf2 : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      const elements2 = targets.filter(Boolean);
      if (elements2.length === 0) return;
      cleanups2.push(hideOthers(elements2));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn?.());
  };
}

// ../../../node_modules/@zag-js/remove-scroll/dist/index.mjs
var LOCK_CLASSNAME = "data-scroll-lock";
function assignStyle(el, style2) {
  if (!el) return;
  const previousStyle = Object.keys(style2).reduce(
    (acc, key) => {
      acc[key] = el.style.getPropertyValue(key);
      return acc;
    },
    {}
  );
  Object.assign(el.style, style2);
  return () => {
    Object.assign(el.style, previousStyle);
  };
}
function setCSSProperty(el, property, value) {
  if (!el) return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked) return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setStyle2 = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = visualViewport?.offsetLeft ?? 0;
    const offsetTop = visualViewport?.offsetTop ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle?.();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups2 = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle2()];
  return () => {
    cleanups2.forEach((fn) => fn?.());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// ../../../node_modules/@zag-js/progress/node_modules/@zag-js/core/dist/index.mjs
function memo2(getDeps, fn, opts) {
  let deps = [];
  let result;
  return (depArgs) => {
    const newDeps = getDeps(depArgs);
    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => !isEqual(deps[index], dep));
    if (!depsChanged) return result;
    deps = newDeps;
    result = fn(...newDeps);
    opts?.onChange?.(result);
    return result;
  };
}
function createMachine6(config) {
  return config;
}

// ../../../node_modules/@zag-js/progress/dist/index.mjs
var anatomy4 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts6 = anatomy4.build();
var getRootId3 = (ctx) => ctx.ids?.root ?? `progress-${ctx.id}`;
var getTrackId = (ctx) => ctx.ids?.track ?? `progress-${ctx.id}-track`;
var getLabelId2 = (ctx) => ctx.ids?.label ?? `progress-${ctx.id}-label`;
var getCircleId = (ctx) => ctx.ids?.circle ?? `progress-${ctx.id}-circle`;
function connect5(service, normalize) {
  const { context, computed, prop, send, scope } = service;
  const percent = computed("percent");
  const percentAsString = computed("isIndeterminate") ? "" : computed("formatter").format(computed("percent") / 100);
  const max4 = prop("max");
  const min4 = prop("min");
  const orientation = prop("orientation");
  const translations = prop("translations");
  const indeterminate = computed("isIndeterminate");
  const value = context.get("value");
  const valueAsString = translations?.value({ value, max: max4, percent, min: min4 }) ?? "";
  const progressState = getProgressState(value, max4);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max4,
    "aria-valuemin": min4,
    "aria-valuemax": max4,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps = getCircleProps(service);
  return {
    value,
    valueAsString,
    min: min4,
    max: max4,
    percent,
    percentAsString,
    indeterminate,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max4 });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: min4 });
    },
    getRootProps() {
      return normalize.element({
        dir: prop("dir"),
        ...parts6.root.attrs,
        id: getRootId3(scope),
        "data-max": max4,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        dir: prop("dir"),
        id: getLabelId2(scope),
        ...parts6.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize.element({
        dir: prop("dir"),
        "aria-live": "polite",
        ...parts6.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize.element({
        dir: prop("dir"),
        id: getTrackId(scope),
        ...parts6.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize.element({
        dir: prop("dir"),
        ...parts6.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [computed("isHorizontal") ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize.element({
        dir: prop("dir"),
        id: getCircleId(scope),
        ...parts6.circle.attrs,
        ...progressbarProps,
        ...circleProps.root
      });
    },
    getCircleTrackProps() {
      return normalize.element({
        dir: prop("dir"),
        "data-orientation": orientation,
        ...parts6.circleTrack.attrs,
        ...circleProps.track
      });
    },
    getCircleRangeProps() {
      return normalize.element({
        dir: prop("dir"),
        ...parts6.circleRange.attrs,
        ...circleProps.range,
        "data-state": progressState
      });
    },
    getViewProps(props22) {
      return normalize.element({
        dir: prop("dir"),
        ...parts6.view.attrs,
        "data-state": props22.state,
        hidden: props22.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function getCircleProps(service) {
  const { context, computed } = service;
  const circleProps = {
    style: {
      "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
      cx: "calc(var(--size) / 2)",
      cy: "calc(var(--size) / 2)",
      r: "var(--radius)",
      fill: "transparent",
      strokeWidth: "var(--thickness)"
    }
  };
  return {
    root: {
      style: {
        width: "var(--size)",
        height: "var(--size)"
      }
    },
    track: circleProps,
    range: {
      opacity: context.get("value") === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": computed("percent"),
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100)`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: computed("isIndeterminate") ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
var machine5 = createMachine6({
  props({ props: props22 }) {
    const min4 = props22.min ?? 0;
    const max4 = props22.max ?? 100;
    return {
      ...props22,
      max: max4,
      min: min4,
      defaultValue: props22.defaultValue ?? midValue(min4, max4),
      orientation: "horizontal",
      formatOptions: {
        style: "percent",
        ...props22.formatOptions
      },
      translations: {
        value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
        ...props22.translations
      }
    };
  },
  initialState() {
    return "idle";
  },
  entry: ["validateContext"],
  context({ bindable, prop }) {
    return {
      value: bindable(() => ({
        defaultValue: prop("defaultValue"),
        value: prop("value"),
        onChange(value) {
          prop("onValueChange")?.({ value });
        }
      }))
    };
  },
  computed: {
    isIndeterminate: ({ context }) => context.get("value") === null,
    percent({ context, prop }) {
      const value = context.get("value");
      if (!isNumber(value)) return -1;
      return getValuePercent(value, prop("min"), prop("max")) * 100;
    },
    formatter: memo2(
      ({ prop }) => [prop("locale"), prop("formatOptions")],
      (locale, formatOptions) => new Intl.NumberFormat(locale, formatOptions)
    ),
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal"
  },
  states: {
    idle: {
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      }
    }
  },
  implementations: {
    actions: {
      setValue: ({ context, event, prop }) => {
        const value = event.value === null ? null : Math.max(0, Math.min(event.value, prop("max")));
        context.set("value", value);
      },
      validateContext: ({ context, prop }) => {
        const max4 = prop("max");
        const min4 = prop("min");
        const value = context.get("value");
        if (value == null) return;
        if (!isValidNumber(max4)) {
          throw new Error(`[progress] The max value passed \`${max4}\` is not a valid number`);
        }
        if (!isValidMax(value, max4)) {
          throw new Error(`[progress] The value passed \`${value}\` exceeds the max value \`${max4}\``);
        }
        if (!isValidMin(value, min4)) {
          throw new Error(`[progress] The value passed \`${value}\` exceeds the min value \`${min4}\``);
        }
      }
    }
  }
});
var isValidNumber = (max4) => isNumber(max4) && !isNaN(max4);
var isValidMax = (value, max4) => isValidNumber(value) && value <= max4;
var isValidMin = (value, min4) => isValidNumber(value) && value >= min4;
var midValue = (min4, max4) => min4 + (max4 - min4) / 2;
var props4 = createProps2()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value",
  "onValueChange",
  "defaultValue",
  "formatOptions",
  "locale"
]);
var splitProps5 = createSplitProps2(props4);

// ../../../node_modules/@ark-ui/solid/dist/chunk/OIGKROX4.js
var [ProgressProvider, useProgressContext] = createContext2({
  hookName: "useProgressContext",
  providerName: "<ProgressProvider />"
});
var ProgressCircle = (props7) => {
  const api = useProgressContext();
  const mergedProps = mergeProps22(() => api().getCircleProps(), props7);
  return createComponent(ark.svg, mergedProps);
};
var ProgressCircleRange = (props7) => {
  const api = useProgressContext();
  const mergedProps = mergeProps22(() => api().getCircleRangeProps(), props7);
  return createComponent(ark.circle, mergedProps);
};
var ProgressCircleTrack = (props7) => {
  const api = useProgressContext();
  const mergedProps = mergeProps22(() => api().getCircleTrackProps(), props7);
  return createComponent(ark.circle, mergedProps);
};
var ProgressContext = (props7) => props7.children(useProgressContext());
var ProgressLabel = (props7) => {
  const api = useProgressContext();
  const mergedProps = mergeProps22(() => api().getLabelProps(), props7);
  return createComponent(ark.label, mergedProps);
};
var ProgressRange = (props7) => {
  const api = useProgressContext();
  const mergedProps = mergeProps22(() => api().getRangeProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var useProgress = (props7 = {}) => {
  const id = createUniqueId();
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const machineProps = createMemo(() => ({
    id,
    dir: locale().dir,
    locale: locale().locale,
    getRootNode: environment().getRootNode,
    ...props7
  }));
  const service = useMachine(machine5, machineProps);
  return createMemo(() => connect5(service, normalizeProps));
};
var ProgressRoot = (props7) => {
  const [progressProps, localProps] = createSplitProps()(props7, ["defaultValue", "formatOptions", "id", "ids", "locale", "max", "min", "onValueChange", "orientation", "translations", "value"]);
  const api = useProgress(progressProps);
  const mergedProps = mergeProps22(() => api().getRootProps(), localProps);
  return createComponent(ProgressProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var ProgressRootProvider = (props7) => {
  const [{
    value: progress2
  }, localProps] = createSplitProps()(props7, ["value"]);
  const mergedProps = mergeProps22(() => progress2().getRootProps(), localProps);
  return createComponent(ProgressProvider, {
    value: progress2,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var ProgressTrack = (props7) => {
  const api = useProgressContext();
  const mergedProps = mergeProps22(() => api().getTrackProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var ProgressValueText = (props7) => {
  const api = useProgressContext();
  const mergedProps = mergeProps22(() => api().getValueTextProps(), props7);
  return createComponent(ark.span, mergeProps(mergedProps, {
    get children() {
      return props7.children || api().percentAsString;
    }
  }));
};
var ProgressView = (props7) => {
  const [state2, localProps] = createSplitProps()(props7, ["state"]);
  const api = useProgressContext();
  const mergedProps = mergeProps22(() => api().getViewProps(state2), localProps);
  return createComponent(ark.span, mergedProps);
};
var progress_exports = {};
__export2(progress_exports, {
  Circle: () => ProgressCircle,
  CircleRange: () => ProgressCircleRange,
  CircleTrack: () => ProgressCircleTrack,
  Context: () => ProgressContext,
  Label: () => ProgressLabel,
  Range: () => ProgressRange,
  Root: () => ProgressRoot,
  RootProvider: () => ProgressRootProvider,
  Track: () => ProgressTrack,
  ValueText: () => ProgressValueText,
  View: () => ProgressView
});

// ../../../node_modules/@zag-js/carousel/node_modules/@zag-js/core/dist/index.mjs
function createMachine7(config) {
  return config;
}

// ../../../node_modules/@zag-js/scroll-snap/dist/index.mjs
function getScrollPadding(element) {
  const style2 = getComputedStyle2(element);
  const rect = element.getBoundingClientRect();
  let xBeforeRaw = style2.getPropertyValue("scroll-padding-left").replace("auto", "0px");
  let yBeforeRaw = style2.getPropertyValue("scroll-padding-top").replace("auto", "0px");
  let xAfterRaw = style2.getPropertyValue("scroll-padding-right").replace("auto", "0px");
  let yAfterRaw = style2.getPropertyValue("scroll-padding-bottom").replace("auto", "0px");
  function convert(raw, size3) {
    let n = parseFloat(raw);
    if (/%/.test(raw)) {
      n /= 100;
      n *= size3;
    }
    return Number.isNaN(n) ? 0 : n;
  }
  let xBefore = convert(xBeforeRaw, rect.width);
  let yBefore = convert(yBeforeRaw, rect.height);
  let xAfter = convert(xAfterRaw, rect.width);
  let yAfter = convert(yAfterRaw, rect.height);
  return {
    x: { before: xBefore, after: xAfter },
    y: { before: yBefore, after: yAfter }
  };
}
function isRectIntersecting(a, b, axis = "both") {
  return axis === "x" && a.right >= b.left && a.left <= b.right || axis === "y" && a.bottom >= b.top && a.top <= b.bottom || axis === "both" && a.right >= b.left && a.left <= b.right && a.bottom >= b.top && a.top <= b.bottom;
}
function getDescendants(parent2) {
  let children2 = [];
  for (const child of parent2.children) {
    children2 = children2.concat(child, getDescendants(child));
  }
  return children2;
}
function getSnapPositions(parent2, subtree = false) {
  const parentRect = parent2.getBoundingClientRect();
  const positions = {
    x: { start: [], center: [], end: [] },
    y: { start: [], center: [], end: [] }
  };
  const children2 = subtree ? getDescendants(parent2) : parent2.children;
  for (const axis of ["x", "y"]) {
    const orthogonalAxis = axis === "x" ? "y" : "x";
    const axisStart = axis === "x" ? "left" : "top";
    const axisSize = axis === "x" ? "width" : "height";
    const axisScroll = axis === "x" ? "scrollLeft" : "scrollTop";
    for (const child of children2) {
      const childRect = child.getBoundingClientRect();
      if (!isRectIntersecting(parentRect, childRect, orthogonalAxis)) {
        continue;
      }
      const childStyle = getComputedStyle2(child);
      let [childAlignY, childAlignX] = childStyle.getPropertyValue("scroll-snap-align").split(" ");
      if (typeof childAlignX === "undefined") {
        childAlignX = childAlignY;
      }
      const childAlign = axis === "x" ? childAlignX : childAlignY;
      const childOffsetStart = childRect[axisStart] - parentRect[axisStart] + parent2[axisScroll];
      switch (childAlign) {
        case "none":
          break;
        case "start":
          positions[axis].start.push({ node: child, position: childOffsetStart });
          break;
        case "center":
          positions[axis].center.push({ node: child, position: childOffsetStart + childRect[axisSize] / 2 });
          break;
        case "end":
          positions[axis].end.push({ node: child, position: childOffsetStart + childRect[axisSize] });
          break;
      }
    }
  }
  return positions;
}
function getScrollSnapPositions(element) {
  const rect = element.getBoundingClientRect();
  const scrollPadding = getScrollPadding(element);
  const snapPositions = getSnapPositions(element);
  const maxScroll = {
    x: element.scrollWidth - element.offsetWidth,
    y: element.scrollHeight - element.offsetHeight
  };
  return {
    x: uniq2(
      [
        ...snapPositions.x.start.map((v) => v.position - scrollPadding.x.before),
        ...snapPositions.x.center.map((v) => v.position - rect.width / 2),
        ...snapPositions.x.end.map((v) => v.position - rect.width + scrollPadding.x.after)
      ].map(clamp2(0, maxScroll.x))
    ),
    y: uniq2(
      [
        ...snapPositions.y.start.map((v) => v.position - scrollPadding.y.before),
        ...snapPositions.y.center.map((v) => v.position - rect.height / 2),
        ...snapPositions.y.end.map((v) => v.position - rect.height + scrollPadding.y.after)
      ].map(clamp2(0, maxScroll.y))
    )
  };
}
function findSnapPoint(parent2, axis, predicate) {
  const snapPositions = getSnapPositions(parent2);
  const items = [...snapPositions[axis].start, ...snapPositions[axis].center, ...snapPositions[axis].end];
  for (const item of items) {
    if (predicate(item.node)) {
      return item.position;
    }
  }
}
var uniq2 = (arr) => [...new Set(arr)];
var clamp2 = (min4, max4) => (value) => Math.max(min4, Math.min(max4, value));

// ../../../node_modules/@zag-js/carousel/dist/index.mjs
var anatomy5 = createAnatomy("carousel").parts(
  "root",
  "itemGroup",
  "item",
  "control",
  "nextTrigger",
  "prevTrigger",
  "indicatorGroup",
  "indicator",
  "autoplayTrigger"
);
var parts7 = anatomy5.build();
var getRootId4 = (ctx) => ctx.ids?.root ?? `carousel:${ctx.id}`;
var getItemId = (ctx, index) => ctx.ids?.item?.(index) ?? `carousel:${ctx.id}:item:${index}`;
var getItemGroupId = (ctx) => ctx.ids?.itemGroup ?? `carousel:${ctx.id}:item-group`;
var getNextTriggerId = (ctx) => ctx.ids?.nextTrigger ?? `carousel:${ctx.id}:next-trigger`;
var getPrevTriggerId = (ctx) => ctx.ids?.prevTrigger ?? `carousel:${ctx.id}:prev-trigger`;
var getIndicatorGroupId = (ctx) => ctx.ids?.indicatorGroup ?? `carousel:${ctx.id}:indicator-group`;
var getIndicatorId = (ctx, index) => ctx.ids?.indicator?.(index) ?? `carousel:${ctx.id}:indicator:${index}`;
var getItemGroupEl = (ctx) => ctx.getById(getItemGroupId(ctx));
var getItemEls = (ctx) => queryAll(getItemGroupEl(ctx), `[data-part=item]`);
var getIndicatorEl = (ctx, page) => ctx.getById(getIndicatorId(ctx, page));
var syncTabIndex = (ctx) => {
  const el = getItemGroupEl(ctx);
  if (!el) return;
  const tabbables = getTabbables(el);
  if (tabbables.length > 0) {
    el.removeAttribute("tabindex");
  } else {
    el.setAttribute("tabindex", "0");
  }
};
function connect6(service, normalize) {
  const { state: state2, context, computed, send, scope, prop } = service;
  const isPlaying = state2.matches("autoplay");
  const isDragging = state2.matches("dragging");
  const canScrollNext = computed("canScrollNext");
  const canScrollPrev = computed("canScrollPrev");
  const horizontal = computed("isHorizontal");
  const pageSnapPoints = Array.from(context.get("pageSnapPoints"));
  const page = context.get("page");
  const slidesPerPage = prop("slidesPerPage");
  const padding = prop("padding");
  const translations = prop("translations");
  return {
    isPlaying,
    isDragging,
    page,
    pageSnapPoints,
    canScrollNext,
    canScrollPrev,
    getProgress() {
      return page / pageSnapPoints.length;
    },
    scrollToIndex(index, instant) {
      send({ type: "INDEX.SET", index, instant });
    },
    scrollTo(index, instant) {
      send({ type: "PAGE.SET", index, instant });
    },
    scrollNext(instant) {
      send({ type: "PAGE.NEXT", instant });
    },
    scrollPrev(instant) {
      send({ type: "PAGE.PREV", instant });
    },
    play() {
      send({ type: "AUTOPLAY.START" });
    },
    pause() {
      send({ type: "AUTOPLAY.PAUSE" });
    },
    isInView(index) {
      return Array.from(context.get("slidesInView")).includes(index);
    },
    refresh() {
      send({ type: "SNAP.REFRESH" });
    },
    getRootProps() {
      return normalize.element({
        ...parts7.root.attrs,
        id: getRootId4(scope),
        role: "region",
        "aria-roledescription": "carousel",
        "data-orientation": prop("orientation"),
        dir: prop("dir"),
        style: {
          "--slides-per-page": slidesPerPage,
          "--slide-spacing": prop("spacing"),
          "--slide-item-size": "calc(100% / var(--slides-per-page) - var(--slide-spacing) * (var(--slides-per-page) - 1) / var(--slides-per-page))"
        }
      });
    },
    getItemGroupProps() {
      return normalize.element({
        ...parts7.itemGroup.attrs,
        id: getItemGroupId(scope),
        "data-orientation": prop("orientation"),
        "data-dragging": dataAttr(isDragging),
        dir: prop("dir"),
        "aria-live": isPlaying ? "off" : "polite",
        onMouseDown(event) {
          if (!prop("allowMouseDrag")) return;
          if (event.button !== 0) return;
          if (event.defaultPrevented) return;
          const target = getEventTarget(event);
          if (isFocusable(target) && target !== event.currentTarget) return;
          event.preventDefault();
          send({ type: "DRAGGING.START" });
        },
        onWheel: throttle(() => {
          send({ type: "USER.SCROLL" });
        }, 150),
        onTouchStart() {
          send({ type: "USER.SCROLL" });
        },
        style: {
          display: "grid",
          gap: "var(--slide-spacing)",
          scrollSnapType: [horizontal ? "x" : "y", prop("snapType")].join(" "),
          gridAutoFlow: horizontal ? "column" : "row",
          scrollbarWidth: "none",
          overscrollBehavior: "contain",
          [horizontal ? "gridAutoColumns" : "gridAutoRows"]: "var(--slide-item-size)",
          [horizontal ? "scrollPaddingInline" : "scrollPaddingBlock"]: padding,
          [horizontal ? "paddingInline" : "paddingBlock"]: padding,
          [horizontal ? "overflowX" : "overflowY"]: "auto"
        }
      });
    },
    getItemProps(props22) {
      const isInView = context.get("slidesInView").includes(props22.index);
      return normalize.element({
        ...parts7.item.attrs,
        id: getItemId(scope, props22.index),
        dir: prop("dir"),
        role: "group",
        "data-index": props22.index,
        "data-inview": dataAttr(isInView),
        "aria-roledescription": "slide",
        "data-orientation": prop("orientation"),
        "aria-label": translations.item(props22.index, prop("slideCount")),
        "aria-hidden": ariaAttr(!isInView),
        style: {
          scrollSnapAlign: (() => {
            const snapAlign = props22.snapAlign ?? "start";
            const slidesPerMove = prop("slidesPerMove");
            const perMove = slidesPerMove === "auto" ? Math.floor(prop("slidesPerPage")) : slidesPerMove;
            const shouldSnap = (props22.index + perMove) % perMove === 0;
            return shouldSnap ? snapAlign : void 0;
          })()
        }
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts7.control.attrs,
        "data-orientation": prop("orientation")
      });
    },
    getPrevTriggerProps() {
      return normalize.button({
        ...parts7.prevTrigger.attrs,
        id: getPrevTriggerId(scope),
        type: "button",
        disabled: !canScrollPrev,
        dir: prop("dir"),
        "aria-label": translations.prevTrigger,
        "data-orientation": prop("orientation"),
        "aria-controls": getItemGroupId(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.PREV", src: "trigger" });
        }
      });
    },
    getNextTriggerProps() {
      return normalize.button({
        ...parts7.nextTrigger.attrs,
        dir: prop("dir"),
        id: getNextTriggerId(scope),
        type: "button",
        "aria-label": translations.nextTrigger,
        "data-orientation": prop("orientation"),
        "aria-controls": getItemGroupId(scope),
        disabled: !canScrollNext,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "PAGE.NEXT", src: "trigger" });
        }
      });
    },
    getIndicatorGroupProps() {
      return normalize.element({
        ...parts7.indicatorGroup.attrs,
        dir: prop("dir"),
        id: getIndicatorGroupId(scope),
        "data-orientation": prop("orientation"),
        onKeyDown(event) {
          if (event.defaultPrevented) return;
          const src = "indicator";
          const keyMap2 = {
            ArrowDown(event2) {
              if (horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowUp(event2) {
              if (horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            ArrowRight(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.NEXT", src });
              event2.preventDefault();
            },
            ArrowLeft(event2) {
              if (!horizontal) return;
              send({ type: "PAGE.PREV", src });
              event2.preventDefault();
            },
            Home(event2) {
              send({ type: "PAGE.SET", index: 0, src });
              event2.preventDefault();
            },
            End(event2) {
              send({ type: "PAGE.SET", index: pageSnapPoints.length - 1, src });
              event2.preventDefault();
            }
          };
          const key = getEventKey(event, {
            dir: prop("dir"),
            orientation: prop("orientation")
          });
          const exec = keyMap2[key];
          exec?.(event);
        }
      });
    },
    getIndicatorProps(props22) {
      return normalize.button({
        ...parts7.indicator.attrs,
        dir: prop("dir"),
        id: getIndicatorId(scope, props22.index),
        type: "button",
        "data-orientation": prop("orientation"),
        "data-index": props22.index,
        "data-readonly": dataAttr(props22.readOnly),
        "data-current": dataAttr(props22.index === page),
        "aria-label": translations.indicator(props22.index),
        onClick(event) {
          if (event.defaultPrevented) return;
          if (props22.readOnly) return;
          send({ type: "PAGE.SET", index: props22.index, src: "indicator" });
        }
      });
    },
    getAutoplayTriggerProps() {
      return normalize.button({
        ...parts7.autoplayTrigger.attrs,
        type: "button",
        "data-orientation": prop("orientation"),
        "data-pressed": dataAttr(isPlaying),
        "aria-label": isPlaying ? translations.autoplayStop : translations.autoplayStart,
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: isPlaying ? "AUTOPLAY.PAUSE" : "AUTOPLAY.START" });
        }
      });
    }
  };
}
var machine6 = createMachine7({
  props({ props: props22 }) {
    ensureProps(props22, ["slideCount"], "carousel");
    return {
      dir: "ltr",
      defaultPage: 0,
      orientation: "horizontal",
      snapType: "mandatory",
      loop: !!props22.autoplay,
      slidesPerPage: 1,
      slidesPerMove: "auto",
      spacing: "0px",
      autoplay: false,
      allowMouseDrag: false,
      inViewThreshold: 0.6,
      ...props22,
      translations: {
        nextTrigger: "Next slide",
        prevTrigger: "Previous slide",
        indicator: (index) => `Go to slide ${index + 1}`,
        item: (index, count) => `${index + 1} of ${count}`,
        autoplayStart: "Start slide rotation",
        autoplayStop: "Stop slide rotation",
        ...props22.translations
      }
    };
  },
  refs() {
    return {
      timeoutRef: void 0
    };
  },
  initialState({ prop }) {
    return prop("autoplay") ? "autoplay" : "idle";
  },
  context({ prop, bindable, getContext }) {
    return {
      page: bindable(() => ({
        defaultValue: prop("defaultPage"),
        value: prop("page"),
        onChange(page) {
          const ctx = getContext();
          const pageSnapPoints = ctx.get("pageSnapPoints");
          prop("onPageChange")?.({ page, pageSnapPoint: pageSnapPoints[page] });
        }
      })),
      pageSnapPoints: bindable(() => {
        return {
          defaultValue: getPageSnapPoints(prop("slideCount"), prop("slidesPerMove"), prop("slidesPerPage"))
        };
      }),
      slidesInView: bindable(() => ({
        defaultValue: []
      }))
    };
  },
  computed: {
    isRtl: ({ prop }) => prop("dir") === "rtl",
    isHorizontal: ({ prop }) => prop("orientation") === "horizontal",
    canScrollNext: ({ prop, context }) => prop("loop") || context.get("page") < context.get("pageSnapPoints").length - 1,
    canScrollPrev: ({ prop, context }) => prop("loop") || context.get("page") > 0,
    autoplayInterval: ({ prop }) => {
      const autoplay = prop("autoplay");
      return isObject3(autoplay) ? autoplay.delay : 4e3;
    }
  },
  watch({ track, action, context, prop }) {
    track([() => prop("slidesPerPage"), () => prop("slidesPerMove")], () => {
      action(["setSnapPoints"]);
    });
    track([() => context.get("page")], () => {
      action(["scrollToPage", "focusIndicatorEl"]);
    });
    track([() => prop("orientation")], () => {
      action(["setSnapPoints", "scrollToPage"]);
    });
  },
  on: {
    "PAGE.NEXT": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setNextPage"]
    },
    "PAGE.PREV": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setPrevPage"]
    },
    "PAGE.SET": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setPage"]
    },
    "INDEX.SET": {
      target: "idle",
      actions: ["clearScrollEndTimer", "setMatchingPage"]
    },
    "SNAP.REFRESH": {
      actions: ["setSnapPoints", "clampPage"]
    },
    "PAGE.SCROLL": {
      actions: ["scrollToPage"]
    }
  },
  effects: ["trackSlideMutation", "trackSlideIntersections", "trackSlideResize"],
  entry: ["setSnapPoints", "setPage"],
  exit: ["clearScrollEndTimer"],
  states: {
    idle: {
      on: {
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "AUTOPLAY.START": {
          target: "autoplay",
          actions: ["invokeAutoplayStart"]
        },
        "USER.SCROLL": {
          target: "userScroll"
        }
      }
    },
    dragging: {
      effects: ["trackPointerMove"],
      entry: ["disableScrollSnap"],
      on: {
        DRAGGING: {
          actions: ["scrollSlides", "invokeDragging"]
        },
        "DRAGGING.END": {
          target: "idle",
          actions: ["endDragging", "invokeDraggingEnd"]
        }
      }
    },
    userScroll: {
      effects: ["trackScroll"],
      on: {
        "SCROLL.END": {
          target: "idle",
          actions: ["setClosestPage"]
        }
      }
    },
    autoplay: {
      effects: ["trackDocumentVisibility", "trackScroll", "autoUpdateSlide"],
      exit: ["invokeAutoplayEnd"],
      on: {
        "AUTOPLAY.TICK": {
          actions: ["setNextPage", "invokeAutoplay"]
        },
        "DRAGGING.START": {
          target: "dragging",
          actions: ["invokeDragStart"]
        },
        "AUTOPLAY.PAUSE": {
          target: "idle"
        }
      }
    }
  },
  implementations: {
    effects: {
      autoUpdateSlide({ computed, send }) {
        const id = setInterval(() => {
          send({ type: "AUTOPLAY.TICK", src: "autoplay.interval" });
        }, computed("autoplayInterval"));
        return () => clearInterval(id);
      },
      trackSlideMutation({ scope, send }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const win = scope.getWin();
        const observer = new win.MutationObserver(() => {
          send({ type: "SNAP.REFRESH", src: "slide.mutation" });
          syncTabIndex(scope);
        });
        syncTabIndex(scope);
        observer.observe(el, { childList: true, subtree: true });
        return () => observer.disconnect();
      },
      trackSlideResize({ scope, send }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const win = scope.getWin();
        const exec = () => {
          send({ type: "SNAP.REFRESH", src: "slide.resize" });
        };
        raf(() => {
          exec();
          raf(() => {
            send({ type: "PAGE.SCROLL", instant: true });
          });
        });
        const observer = new win.ResizeObserver(exec);
        getItemEls(scope).forEach((slide) => observer.observe(slide));
        return () => observer.disconnect();
      },
      trackSlideIntersections({ scope, prop, context }) {
        const el = getItemGroupEl(scope);
        const win = scope.getWin();
        const observer = new win.IntersectionObserver(
          (entries2) => {
            const slidesInView = entries2.reduce((acc, entry) => {
              const target = entry.target;
              const index = Number(target.dataset.index ?? "-1");
              if (index == null || Number.isNaN(index) || index === -1) return acc;
              return entry.isIntersecting ? add(acc, index) : remove(acc, index);
            }, context.get("slidesInView"));
            context.set("slidesInView", uniq(slidesInView));
          },
          {
            root: el,
            threshold: prop("inViewThreshold")
          }
        );
        getItemEls(scope).forEach((slide) => observer.observe(slide));
        return () => observer.disconnect();
      },
      trackScroll({ send, refs, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const onScroll = () => {
          clearTimeout(refs.get("timeoutRef"));
          refs.set("timeoutRef", void 0);
          refs.set(
            "timeoutRef",
            setTimeout(() => {
              send({ type: "SCROLL.END" });
            }, 150)
          );
        };
        return addDomEvent(el, "scroll", onScroll, { passive: true });
      },
      trackDocumentVisibility({ scope, send }) {
        const doc = scope.getDoc();
        const onVisibilityChange = () => {
          if (doc.visibilityState === "visible") return;
          send({ type: "AUTOPLAY.PAUSE", src: "doc.hidden" });
        };
        return addDomEvent(doc, "visibilitychange", onVisibilityChange);
      },
      trackPointerMove({ scope, send }) {
        const doc = scope.getDoc();
        return trackPointerMove(doc, {
          onPointerMove({ event }) {
            send({ type: "DRAGGING", left: -event.movementX, top: -event.movementY });
          },
          onPointerUp() {
            send({ type: "DRAGGING.END" });
          }
        });
      }
    },
    actions: {
      clearScrollEndTimer({ refs }) {
        if (refs.get("timeoutRef") == null) return;
        clearTimeout(refs.get("timeoutRef"));
        refs.set("timeoutRef", void 0);
      },
      scrollToPage({ context, event, scope, computed }) {
        const behavior = event.instant ? "instant" : "smooth";
        const index = clampValue(event.index ?? context.get("page"), 0, context.get("pageSnapPoints").length - 1);
        const el = getItemGroupEl(scope);
        if (!el) return;
        const axis = computed("isHorizontal") ? "left" : "top";
        el.scrollTo({ [axis]: context.get("pageSnapPoints")[index], behavior });
      },
      setClosestPage({ context, scope, computed }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const scrollPosition = computed("isHorizontal") ? el.scrollLeft : el.scrollTop;
        const page = context.get("pageSnapPoints").findIndex((point) => Math.abs(point - scrollPosition) < 1);
        if (page === -1) return;
        context.set("page", page);
      },
      setNextPage({ context, prop, state: state2 }) {
        const loop = state2.matches("autoplay") || prop("loop");
        const page = nextIndex(context.get("pageSnapPoints"), context.get("page"), { loop });
        context.set("page", page);
      },
      setPrevPage({ context, prop, state: state2 }) {
        const loop = state2.matches("autoplay") || prop("loop");
        const page = prevIndex(context.get("pageSnapPoints"), context.get("page"), { loop });
        context.set("page", page);
      },
      setMatchingPage({ context, event, computed, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const snapPoint = findSnapPoint(
          el,
          computed("isHorizontal") ? "x" : "y",
          (node) => node.dataset.index === event.index.toString()
        );
        if (snapPoint == null) return;
        const page = context.get("pageSnapPoints").findIndex((point) => Math.abs(point - snapPoint) < 1);
        context.set("page", page);
      },
      setPage({ context, event }) {
        const page = event.index ?? context.get("page");
        context.set("page", page);
      },
      clampPage({ context }) {
        const index = clampValue(context.get("page"), 0, context.get("pageSnapPoints").length - 1);
        context.set("page", index);
      },
      setSnapPoints({ context, computed, scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const scrollSnapPoints = getScrollSnapPositions(el);
        context.set("pageSnapPoints", computed("isHorizontal") ? scrollSnapPoints.x : scrollSnapPoints.y);
      },
      disableScrollSnap({ scope }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const styles = getComputedStyle(el);
        el.dataset.scrollSnapType = styles.getPropertyValue("scroll-snap-type");
        el.style.setProperty("scroll-snap-type", "none");
      },
      scrollSlides({ scope, event }) {
        const el = getItemGroupEl(scope);
        el?.scrollBy({ left: event.left, top: event.top, behavior: "instant" });
      },
      endDragging({ scope, context, computed }) {
        const el = getItemGroupEl(scope);
        if (!el) return;
        const startX = el.scrollLeft;
        const startY = el.scrollTop;
        const snapPositions = getScrollSnapPositions(el);
        const closestX = snapPositions.x.reduce((closest, curr) => {
          return Math.abs(curr - startX) < Math.abs(closest - startX) ? curr : closest;
        }, snapPositions.x[0]);
        const closestY = snapPositions.y.reduce((closest, curr) => {
          return Math.abs(curr - startY) < Math.abs(closest - startY) ? curr : closest;
        }, snapPositions.y[0]);
        raf(() => {
          el.scrollTo({ left: closestX, top: closestY, behavior: "smooth" });
          const closest = computed("isHorizontal") ? closestX : closestY;
          context.set("page", context.get("pageSnapPoints").indexOf(closest));
          const scrollSnapType = el.dataset.scrollSnapType;
          if (scrollSnapType) {
            el.style.removeProperty("scroll-snap-type");
            delete el.dataset.scrollSnapType;
          }
        });
      },
      focusIndicatorEl({ context, event, scope }) {
        if (event.src !== "indicator") return;
        const el = getIndicatorEl(scope, context.get("page"));
        if (!el) return;
        raf(() => el.focus({ preventScroll: true }));
      },
      invokeDragStart({ context, prop }) {
        prop("onDragStatusChange")?.({ type: "dragging.start", isDragging: true, page: context.get("page") });
      },
      invokeDragging({ context, prop }) {
        prop("onDragStatusChange")?.({ type: "dragging", isDragging: true, page: context.get("page") });
      },
      invokeDraggingEnd({ context, prop }) {
        prop("onDragStatusChange")?.({ type: "dragging.end", isDragging: false, page: context.get("page") });
      },
      invokeAutoplay({ context, prop }) {
        prop("onAutoplayStatusChange")?.({ type: "autoplay", isPlaying: true, page: context.get("page") });
      },
      invokeAutoplayStart({ context, prop }) {
        prop("onAutoplayStatusChange")?.({ type: "autoplay.start", isPlaying: true, page: context.get("page") });
      },
      invokeAutoplayEnd({ context, prop }) {
        prop("onAutoplayStatusChange")?.({ type: "autoplay.stop", isPlaying: false, page: context.get("page") });
      }
    }
  }
});
function getPageSnapPoints(totalSlides, slidesPerMove, slidesPerPage) {
  if (totalSlides == null) return [];
  const snapPoints = [];
  const perMove = slidesPerMove === "auto" ? Math.floor(slidesPerPage) : slidesPerMove;
  for (let i = 0; i < totalSlides - 1; i += perMove) snapPoints.push(i);
  return snapPoints;
}
var props5 = createProps2()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loop",
  "page",
  "defaultPage",
  "onPageChange",
  "orientation",
  "slideCount",
  "slidesPerPage",
  "slidesPerMove",
  "spacing",
  "padding",
  "autoplay",
  "allowMouseDrag",
  "inViewThreshold",
  "translations",
  "snapType",
  "onDragStatusChange",
  "onAutoplayStatusChange"
]);
var splitProps6 = createSplitProps2(props5);
var indicatorProps = createProps2()(["index", "readOnly"]);
var splitIndicatorProps = createSplitProps2(indicatorProps);
var itemProps2 = createProps2()(["index", "snapAlign"]);
var splitItemProps2 = createSplitProps2(itemProps2);

// ../../../node_modules/@ark-ui/solid/dist/chunk/NNZQ2FQW.js
var [CarouselProvider, useCarouselContext] = createContext2({
  hookName: "useCarouselContext",
  providerName: "<CarouselProvider />"
});
var CarouselAutoplayTrigger = (props7) => {
  const api = useCarouselContext();
  const mergedProps = mergeProps22(() => api().getAutoplayTriggerProps(), props7);
  return createComponent(ark.button, mergedProps);
};
var CarouselContext = (props7) => props7.children(useCarouselContext());
var CarouselControl = (props7) => {
  const api = useCarouselContext();
  const mergedProps = mergeProps22(() => api().getControlProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var CarouselIndicator = (props7) => {
  const [indicatorProps2, localProps] = createSplitProps()(props7, ["index", "readOnly"]);
  const api = useCarouselContext();
  const mergedProps = mergeProps22(() => api().getIndicatorProps(indicatorProps2), localProps);
  return createComponent(ark.button, mergedProps);
};
var CarouselIndicatorGroup = (props7) => {
  const api = useCarouselContext();
  const mergedProps = mergeProps22(() => api().getIndicatorGroupProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var CarouselItem = (props7) => {
  const [itemProps3, localProps] = createSplitProps()(props7, ["index", "snapAlign"]);
  const api = useCarouselContext();
  const mergedProps = mergeProps22(() => api().getItemProps(itemProps3), localProps);
  return createComponent(ark.div, mergedProps);
};
var CarouselItemGroup = (props7) => {
  const api = useCarouselContext();
  const mergedProps = mergeProps22(() => api().getItemGroupProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var CarouselNextTrigger = (props7) => {
  const api = useCarouselContext();
  const mergedProps = mergeProps22(() => api().getNextTriggerProps(), props7);
  return createComponent(ark.button, mergedProps);
};
var CarouselPrevTrigger = (props7) => {
  const api = useCarouselContext();
  const mergedProps = mergeProps22(() => api().getPrevTriggerProps(), props7);
  return createComponent(ark.button, mergedProps);
};
var useCarousel = (props7) => {
  const id = createUniqueId();
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const machineProps = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props7
  }));
  const service = useMachine(machine6, machineProps);
  return createMemo(() => connect6(service, normalizeProps));
};
var CarouselRoot = (props7) => {
  const [useCarouselProps, localProps] = createSplitProps()(props7, ["allowMouseDrag", "autoplay", "defaultPage", "id", "ids", "inViewThreshold", "loop", "onAutoplayStatusChange", "onDragStatusChange", "onPageChange", "orientation", "padding", "page", "slideCount", "slidesPerMove", "slidesPerPage", "snapType", "spacing", "translations"]);
  const api = useCarousel(useCarouselProps);
  const mergedProps = mergeProps22(() => api().getRootProps(), localProps);
  return createComponent(CarouselProvider, {
    value: api,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var CarouselRootProvider = (props7) => {
  const [{
    value: carousel2
  }, localProps] = createSplitProps()(props7, ["value"]);
  const mergedProps = mergeProps22(() => carousel2().getRootProps(), localProps);
  return createComponent(CarouselProvider, {
    value: carousel2,
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var carousel_exports = {};
__export2(carousel_exports, {
  AutoplayTrigger: () => CarouselAutoplayTrigger,
  Context: () => CarouselContext,
  Control: () => CarouselControl,
  Indicator: () => CarouselIndicator,
  IndicatorGroup: () => CarouselIndicatorGroup,
  Item: () => CarouselItem,
  ItemGroup: () => CarouselItemGroup,
  NextTrigger: () => CarouselNextTrigger,
  PrevTrigger: () => CarouselPrevTrigger,
  Root: () => CarouselRoot,
  RootProvider: () => CarouselRootProvider
});

// ../../../node_modules/@zag-js/dialog/node_modules/@zag-js/core/dist/index.mjs
function createMachine8(config) {
  return config;
}

// ../../../node_modules/@zag-js/dialog/dist/index.mjs
var anatomy6 = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts8 = anatomy6.build();
var getPositionerId2 = (ctx) => ctx.ids?.positioner ?? `dialog:${ctx.id}:positioner`;
var getBackdropId = (ctx) => ctx.ids?.backdrop ?? `dialog:${ctx.id}:backdrop`;
var getContentId2 = (ctx) => ctx.ids?.content ?? `dialog:${ctx.id}:content`;
var getTriggerId2 = (ctx) => ctx.ids?.trigger ?? `dialog:${ctx.id}:trigger`;
var getTitleId2 = (ctx) => ctx.ids?.title ?? `dialog:${ctx.id}:title`;
var getDescriptionId2 = (ctx) => ctx.ids?.description ?? `dialog:${ctx.id}:description`;
var getCloseTriggerId2 = (ctx) => ctx.ids?.closeTrigger ?? `dialog:${ctx.id}:close`;
var getContentEl2 = (ctx) => ctx.getById(getContentId2(ctx));
var getPositionerEl2 = (ctx) => ctx.getById(getPositionerId2(ctx));
var getBackdropEl = (ctx) => ctx.getById(getBackdropId(ctx));
var getTriggerEl2 = (ctx) => ctx.getById(getTriggerId2(ctx));
var getTitleEl = (ctx) => ctx.getById(getTitleId2(ctx));
var getDescriptionEl = (ctx) => ctx.getById(getDescriptionId2(ctx));
var getCloseTriggerEl = (ctx) => ctx.getById(getCloseTriggerId2(ctx));
function connect7(service, normalize) {
  const { state: state2, send, context, prop, scope } = service;
  const ariaLabel = prop("aria-label");
  const open2 = state2.matches("open");
  return {
    open: open2,
    setOpen(nextOpen) {
      if (nextOpen === open2) return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts8.trigger.attrs,
        dir: prop("dir"),
        id: getTriggerId2(scope),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open2,
        "data-state": open2 ? "open" : "closed",
        "aria-controls": getContentId2(scope),
        onClick(event) {
          if (event.defaultPrevented) return;
          send({ type: "TOGGLE" });
        }
      });
    },
    getBackdropProps() {
      return normalize.element({
        ...parts8.backdrop.attrs,
        dir: prop("dir"),
        hidden: !open2,
        id: getBackdropId(scope),
        "data-state": open2 ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts8.positioner.attrs,
        dir: prop("dir"),
        id: getPositionerId2(scope),
        style: {
          pointerEvents: open2 ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      const rendered = context.get("rendered");
      return normalize.element({
        ...parts8.content.attrs,
        dir: prop("dir"),
        role: prop("role"),
        hidden: !open2,
        id: getContentId2(scope),
        tabIndex: -1,
        "data-state": open2 ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : getTitleId2(scope),
        "aria-describedby": rendered.description ? getDescriptionId2(scope) : void 0
      });
    },
    getTitleProps() {
      return normalize.element({
        ...parts8.title.attrs,
        dir: prop("dir"),
        id: getTitleId2(scope)
      });
    },
    getDescriptionProps() {
      return normalize.element({
        ...parts8.description.attrs,
        dir: prop("dir"),
        id: getDescriptionId2(scope)
      });
    },
    getCloseTriggerProps() {
      return normalize.button({
        ...parts8.closeTrigger.attrs,
        dir: prop("dir"),
        id: getCloseTriggerId2(scope),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented) return;
          event.stopPropagation();
          send({ type: "CLOSE" });
        }
      });
    }
  };
}
var machine7 = createMachine8({
  props({ props: props22, scope }) {
    const alertDialog = props22.role === "alertdialog";
    const initialFocusEl = alertDialog ? () => getCloseTriggerEl(scope) : void 0;
    return {
      role: "dialog",
      modal: true,
      trapFocus: true,
      preventScroll: true,
      closeOnInteractOutside: !alertDialog,
      closeOnEscape: true,
      restoreFocus: true,
      initialFocusEl,
      ...props22
    };
  },
  initialState({ prop }) {
    const open2 = prop("open") || prop("defaultOpen");
    return open2 ? "open" : "closed";
  },
  context({ bindable }) {
    return {
      rendered: bindable(() => ({
        defaultValue: { title: true, description: true }
      }))
    };
  },
  watch({ track, action, prop }) {
    track([() => prop("open")], () => {
      action(["toggleVisibility"]);
    });
  },
  states: {
    open: {
      entry: ["checkRenderedElements", "syncZIndex"],
      effects: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
      on: {
        "CONTROLLED.CLOSE": {
          target: "closed"
        },
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnClose"]
          },
          {
            target: "closed",
            actions: ["invokeOnClose"]
          }
        ]
      }
    },
    closed: {
      on: {
        "CONTROLLED.OPEN": {
          target: "open"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ],
        TOGGLE: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            target: "open",
            actions: ["invokeOnOpen"]
          }
        ]
      }
    }
  },
  implementations: {
    guards: {
      isOpenControlled: ({ prop }) => prop("open") != void 0
    },
    effects: {
      trackDismissableElement({ scope, send, prop }) {
        const getContentEl22 = () => getContentEl2(scope);
        return trackDismissableElement(getContentEl22, {
          defer: true,
          pointerBlocking: prop("modal"),
          exclude: [getTriggerEl2(scope)],
          onInteractOutside(event) {
            prop("onInteractOutside")?.(event);
            if (!prop("closeOnInteractOutside")) {
              event.preventDefault();
            }
          },
          persistentElements: prop("persistentElements"),
          onFocusOutside: prop("onFocusOutside"),
          onPointerDownOutside: prop("onPointerDownOutside"),
          onEscapeKeyDown(event) {
            prop("onEscapeKeyDown")?.(event);
            if (!prop("closeOnEscape")) {
              event.preventDefault();
            }
          },
          onDismiss() {
            send({ type: "CLOSE", src: "interact-outside" });
          }
        });
      },
      preventScroll({ scope, prop }) {
        if (!prop("preventScroll")) return;
        return preventBodyScroll(scope.getDoc());
      },
      trapFocus({ scope, prop }) {
        if (!prop("trapFocus") || !prop("modal")) return;
        const contentEl = () => getContentEl2(scope);
        return trapFocus(contentEl, {
          preventScroll: true,
          returnFocusOnDeactivate: !!prop("restoreFocus"),
          initialFocus: prop("initialFocusEl"),
          setReturnFocus: (el) => prop("finalFocusEl")?.() ?? el
        });
      },
      hideContentBelow({ scope, prop }) {
        if (!prop("modal")) return;
        const getElements2 = () => [getContentEl2(scope)];
        return ariaHidden(getElements2, { defer: true });
      }
    },
    actions: {
      checkRenderedElements({ context, scope }) {
        raf(() => {
          context.set("rendered", {
            title: !!getTitleEl(scope),
            description: !!getDescriptionEl(scope)
          });
        });
      },
      syncZIndex({ scope }) {
        raf(() => {
          const contentEl = getContentEl2(scope);
          if (!contentEl) return;
          const styles = getComputedStyle2(contentEl);
          const elems = [getPositionerEl2(scope), getBackdropEl(scope)];
          elems.forEach((node) => {
            node?.style.setProperty("--z-index", styles.zIndex);
          });
        });
      },
      invokeOnClose({ prop }) {
        prop("onOpenChange")?.({ open: false });
      },
      invokeOnOpen({ prop }) {
        prop("onOpenChange")?.({ open: true });
      },
      toggleVisibility({ prop, send, event }) {
        send({
          type: prop("open") ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE",
          previousEvent: event
        });
      }
    }
  }
});
var props6 = createProps2()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "defaultOpen",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps7 = createSplitProps2(props6);

// ../../../node_modules/@ark-ui/solid/dist/chunk/O62NKGT4.js
var [DialogProvider, useDialogContext] = createContext2({
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});
var DialogBackdrop = (props7) => {
  const api = useDialogContext();
  const renderStrategyProps = useRenderStrategyContext();
  const presenceApi = usePresence(mergeProps22(renderStrategyProps, () => ({
    present: api().open
  })));
  const mergedProps = mergeProps22(() => api().getBackdropProps(), () => presenceApi().presenceProps, props7);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var DialogCloseTrigger = (props7) => {
  const dialog2 = useDialogContext();
  const mergedProps = mergeProps22(() => dialog2().getCloseTriggerProps(), props7);
  return createComponent(ark.button, mergedProps);
};
var DialogContent = (props7) => {
  const api = useDialogContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps22(() => api().getContentProps(), () => presenceApi().presenceProps, props7);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var DialogContext = (props7) => props7.children(useDialogContext());
var DialogDescription = (props7) => {
  const dialog2 = useDialogContext();
  const mergedProps = mergeProps22(() => dialog2().getDescriptionProps(), props7);
  return createComponent(ark.div, mergedProps);
};
var DialogPositioner = (props7) => {
  const api = useDialogContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps22(() => api().getPositionerProps(), props7);
  return createComponent(Show, {
    get when() {
      return !presenceApi().unmounted;
    },
    get children() {
      return createComponent(ark.div, mergedProps);
    }
  });
};
var useDialog = (props7 = {}) => {
  const id = createUniqueId();
  const locale = useLocaleContext();
  const environment = useEnvironmentContext();
  const machineProps = createMemo(() => ({
    id,
    dir: locale().dir,
    getRootNode: environment().getRootNode,
    ...props7
  }));
  const service = useMachine(machine7, machineProps);
  return createMemo(() => connect7(service, normalizeProps));
};
var DialogRoot = (props7) => {
  const [presenceProps, dialogProps] = splitPresenceProps(props7);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const [useDialogProps, localProps] = createSplitProps()(dialogProps, ["aria-label", "closeOnEscape", "closeOnInteractOutside", "defaultOpen", "finalFocusEl", "id", "ids", "initialFocusEl", "modal", "onEscapeKeyDown", "onFocusOutside", "onInteractOutside", "onOpenChange", "onPointerDownOutside", "open", "persistentElements", "preventScroll", "restoreFocus", "role", "trapFocus"]);
  const api = useDialog(useDialogProps);
  const apiPresence = usePresence(mergeProps22(presenceProps, () => ({
    present: api().open
  })));
  return createComponent(DialogProvider, {
    value: api,
    get children() {
      return createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return createComponent(PresenceProvider, {
            value: apiPresence,
            get children() {
              return localProps.children;
            }
          });
        }
      });
    }
  });
};
var DialogRootProvider = (props7) => {
  const [presenceProps, dialogProps] = splitPresenceProps(props7);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const apiPresence = usePresence(mergeProps22(presenceProps, () => ({
    present: dialogProps.value().open
  })));
  return createComponent(DialogProvider, {
    get value() {
      return dialogProps.value;
    },
    get children() {
      return createComponent(RenderStrategyProvider, {
        value: renderStrategyProps,
        get children() {
          return createComponent(PresenceProvider, {
            value: apiPresence,
            get children() {
              return dialogProps.children;
            }
          });
        }
      });
    }
  });
};
var DialogTitle = (props7) => {
  const dialog2 = useDialogContext();
  const mergedProps = mergeProps22(() => dialog2().getTitleProps(), props7);
  return createComponent(ark.h2, mergedProps);
};
var DialogTrigger = (props7) => {
  const api = useDialogContext();
  const presenceApi = usePresenceContext();
  const mergedProps = mergeProps22(() => api().getTriggerProps(), () => ({
    "aria-controls": presenceApi().unmounted && null
  }), props7);
  return createComponent(ark.button, mergedProps);
};
var dialog_exports = {};
__export2(dialog_exports, {
  Backdrop: () => DialogBackdrop,
  CloseTrigger: () => DialogCloseTrigger,
  Content: () => DialogContent,
  Context: () => DialogContext,
  Description: () => DialogDescription,
  Positioner: () => DialogPositioner,
  Root: () => DialogRoot,
  RootProvider: () => DialogRootProvider,
  Title: () => DialogTitle,
  Trigger: () => DialogTrigger
});

// src/utils/toaster.ts
var toaster = createToaster({
  placement: "bottom-end",
  gap: 24
});

// ../../schemas/src/helpers/isTypebotVersionAtLeastV6.ts
var isTypebotVersionAtLeastV6 = (version) => Number(version) >= 6;

// ../../ui/src/colors.css
var colors_default = ":root,\n.light {\n  --blue-1: 252 253 254;\n  --blue-2: 246 249 255;\n  --blue-3: 235 242 255;\n  --blue-4: 221 234 255;\n  --blue-5: 204 223 255;\n  --blue-6: 183 210 255;\n  --blue-7: 160 191 255;\n  --blue-8: 127 165 253;\n  --blue-9: 53 102 252;\n  --blue-10: 47 91 225;\n  --blue-11: 44 87 221;\n  --blue-12: 23 44 101;\n\n  --orange-1: 254 252 251;\n  --orange-2: 255 244 240;\n  --orange-3: 255 232 222;\n  --orange-4: 255 214 199;\n  --orange-5: 255 200 181;\n  --orange-6: 255 184 160;\n  --orange-7: 255 162 134;\n  --orange-8: 249 136 104;\n  --orange-9: 255 89 36;\n  --orange-10: 242 73 5;\n  --orange-11: 220 59 0;\n  --orange-12: 91 42 28;\n\n  --purple-1: 252 252 255;\n  --purple-2: 249 248 255;\n  --purple-3: 242 240 255;\n  --purple-4: 231 228 255;\n  --purple-5: 221 216 255;\n  --purple-6: 208 201 255;\n  --purple-7: 189 179 255;\n  --purple-8: 165 149 255;\n  --purple-9: 128 85 253;\n  --purple-10: 116 71 236;\n  --purple-11: 104 65 211;\n  --purple-12: 50 30 108;\n\n  --red-1: 255 252 252;\n  --red-2: 255 247 246;\n  --red-3: 255 235 233;\n  --red-4: 255 218 214;\n  --red-5: 255 203 198;\n  --red-6: 255 186 181;\n  --red-7: 252 165 160;\n  --red-8: 244 137 132;\n  --red-9: 248 59 69;\n  --red-10: 234 38 56;\n  --red-11: 216 6 42;\n  --red-12: 106 13 20;\n\n  --gray-1: 255 255 255;\n  --gray-2: 241 241 241;\n  --gray-3: 240 240 240;\n  --gray-4: 232 232 232;\n  --gray-5: 224 224 224;\n  --gray-6: 223 223 223;\n  --gray-7: 206 206 206;\n  --gray-8: 187 187 187;\n  --gray-9: 141 141 141;\n  --gray-10: 131 131 131;\n  --gray-11: 70 70 70;\n  --gray-12: 32 32 32;\n}\n\n.dark {\n  --blue-1: 7 13 26;\n  --blue-2: 15 22 39;\n  --blue-3: 18 35 78;\n  --blue-4: 22 44 106;\n  --blue-5: 29 55 126;\n  --blue-6: 37 66 143;\n  --blue-7: 46 78 164;\n  --blue-8: 54 91 193;\n  --blue-9: 53 102 252;\n  --blue-10: 42 87 236;\n  --blue-11: 141 180 255;\n  --blue-12: 209 226 255;\n\n  --orange-1: 18 11 9;\n  --orange-2: 31 20 17;\n  --orange-3: 55 24 16;\n  --orange-4: 78 22 6;\n  --orange-5: 94 30 11;\n  --orange-6: 110 44 24;\n  --orange-7: 135 60 38;\n  --orange-8: 173 77 49;\n  --orange-9: 255 89 36;\n  --orange-10: 241 75 15;\n  --orange-11: 255 151 118;\n  --orange-12: 255 215 202;\n\n  --purple-1: 13 10 27;\n  --purple-2: 23 19 42;\n  --purple-3: 38 27 79;\n  --purple-4: 50 30 108;\n  --purple-5: 59 37 124;\n  --purple-6: 70 49 139;\n  --purple-7: 84 62 162;\n  --purple-8: 104 76 199;\n  --purple-9: 128 85 253;\n  --purple-10: 116 70 238;\n  --purple-11: 180 166 255;\n  --purple-12: 224 220 255;\n\n  --red-1: 19 10 10;\n  --red-2: 32 18 17;\n  --red-3: 62 14 15;\n  --red-4: 85 5 12;\n  --red-5: 103 11 19;\n  --red-6: 121 27 31;\n  --red-7: 147 43 45;\n  --red-8: 190 58 60;\n  --red-9: 248 59 69;\n  --red-10: 233 41 57;\n  --red-11: 255 143 137;\n  --red-12: 255 208 203;\n\n  --gray-1: 13 13 13;\n  --gray-2: 23 23 23;\n  --gray-3: 34 34 34;\n  --gray-4: 42 42 42;\n  --gray-5: 49 49 49;\n  --gray-6: 58 58 58;\n  --gray-7: 72 72 72;\n  --gray-8: 96 96 96;\n  --gray-9: 110 110 110;\n  --gray-10: 123 123 123;\n  --gray-11: 180 180 180;\n  --gray-12: 238 238 238;\n}\n";

// ../../../node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx3() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}

// ../../../node_modules/class-variance-authority/dist/index.mjs
var falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
var cx = clsx3;
var cva = (base, config) => (props7) => {
  var _config_compoundVariants;
  if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props7 === null || props7 === void 0 ? void 0 : props7.class, props7 === null || props7 === void 0 ? void 0 : props7.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props7 === null || props7 === void 0 ? void 0 : props7[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props7 && Object.entries(props7).reduce((acc, param) => {
    let [key, value] = param;
    if (value === void 0) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props7 === null || props7 === void 0 ? void 0 : props7.class, props7 === null || props7 === void 0 ? void 0 : props7.className);
};

// ../../../node_modules/tailwind-merge/dist/bundle-mjs.mjs
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className2) => {
    const classParts = className2.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className2);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
var getGroupRecursive = (classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
};
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = (className2) => {
  if (arbitraryPropertyRegex.test(className2)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className2)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
var createClassMap = (config) => {
  const {
    theme,
    classGroups
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const classGroupId in classGroups) {
    processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);
  }
  return classMap;
};
var processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
var getPart = (classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
var isThemeGetter = (func) => func.isThemeGetter;
var createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache2 = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache2.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache2;
      cache2 = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache2.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache2.has(key)) {
        cache2.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
var IMPORTANT_MODIFIER = "!";
var MODIFIER_SEPARATOR = ":";
var MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length;
var createParseClassName = (config) => {
  const {
    prefix,
    experimentalParseClassName
  } = config;
  let parseClassName = (className2) => {
    const modifiers = [];
    let bracketDepth = 0;
    let parenDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0; index < className2.length; index++) {
      let currentCharacter = className2[index];
      if (bracketDepth === 0 && parenDepth === 0) {
        if (currentCharacter === MODIFIER_SEPARATOR) {
          modifiers.push(className2.slice(modifierStart, index));
          modifierStart = index + MODIFIER_SEPARATOR_LENGTH;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      } else if (currentCharacter === "(") {
        parenDepth++;
      } else if (currentCharacter === ")") {
        parenDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className2 : className2.substring(modifierStart);
    const baseClassName = stripImportantModifier(baseClassNameWithImportantModifier);
    const hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (prefix) {
    const fullPrefix = prefix + MODIFIER_SEPARATOR;
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className2) => className2.startsWith(fullPrefix) ? parseClassNameOriginal(className2.substring(fullPrefix.length)) : {
      isExternal: true,
      modifiers: [],
      hasImportantModifier: false,
      baseClassName: className2,
      maybePostfixModifierPosition: void 0
    };
  }
  if (experimentalParseClassName) {
    const parseClassNameOriginal = parseClassName;
    parseClassName = (className2) => experimentalParseClassName({
      className: className2,
      parseClassName: parseClassNameOriginal
    });
  }
  return parseClassName;
};
var stripImportantModifier = (baseClassName) => {
  if (baseClassName.endsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(0, baseClassName.length - 1);
  }
  if (baseClassName.startsWith(IMPORTANT_MODIFIER)) {
    return baseClassName.substring(1);
  }
  return baseClassName;
};
var createSortModifiers = (config) => {
  const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier) => [modifier, true]));
  const sortModifiers = (modifiers) => {
    if (modifiers.length <= 1) {
      return modifiers;
    }
    const sortedModifiers = [];
    let unsortedModifiers = [];
    modifiers.forEach((modifier) => {
      const isPositionSensitive = modifier[0] === "[" || orderSensitiveModifiers[modifier];
      if (isPositionSensitive) {
        sortedModifiers.push(...unsortedModifiers.sort(), modifier);
        unsortedModifiers = [];
      } else {
        unsortedModifiers.push(modifier);
      }
    });
    sortedModifiers.push(...unsortedModifiers.sort());
    return sortedModifiers;
  };
  return sortModifiers;
};
var createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  sortModifiers: createSortModifiers(config),
  ...createClassGroupUtils(config)
});
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = (classList2, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds,
    sortModifiers
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList2.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1; index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      isExternal,
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    if (isExternal) {
      result = originalClassName + (result.length > 0 ? " " + result : result);
      continue;
    }
    let hasPostfixModifier = !!maybePostfixModifierPosition;
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group2 = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group2);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix.length; k++) {
    if (mix[k]) {
      if (resolvedValue = toValue(mix[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList2) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList2);
  }
  function tailwindMerge(classList2) {
    const cachedResult = cacheGet(classList2);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList2, configUtils);
    cacheSet(classList2, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
var fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
var arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i;
var arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i;
var fractionRegex = /^\d+\/\d+$/;
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isFraction = (value) => fractionRegex.test(value);
var isNumber2 = (value) => Boolean(value) && !Number.isNaN(Number(value));
var isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
var isPercent = (value) => value.endsWith("%") && isNumber2(value.slice(0, -1));
var isTshirtSize = (value) => tshirtUnitRegex.test(value);
var isAny = () => true;
var isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
var isNever = () => false;
var isShadow = (value) => shadowRegex.test(value);
var isImage = (value) => imageRegex.test(value);
var isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value);
var isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever);
var isArbitraryValue = (value) => arbitraryValueRegex.test(value);
var isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly);
var isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber2);
var isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever);
var isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage);
var isArbitraryShadow = (value) => getIsArbitraryValue(value, isNever, isShadow);
var isArbitraryVariable = (value) => arbitraryVariableRegex.test(value);
var isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength);
var isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName);
var isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition);
var isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize);
var isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage);
var isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, true);
var getIsArbitraryValue = (value, testLabel, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
var getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = false) => {
  const result = arbitraryVariableRegex.exec(value);
  if (result) {
    if (result[1]) {
      return testLabel(result[1]);
    }
    return shouldMatchNoLabel;
  }
  return false;
};
var isLabelPosition = (label) => label === "position";
var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
var isLabelImage = (label) => imageLabels.has(label);
var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
var isLabelSize = (label) => sizeLabels.has(label);
var isLabelLength = (label) => label === "length";
var isLabelNumber = (label) => label === "number";
var isLabelFamilyName = (label) => label === "family-name";
var isLabelShadow = (label) => label === "shadow";
var getDefaultConfig = () => {
  const themeColor = fromTheme("color");
  const themeFont = fromTheme("font");
  const themeText = fromTheme("text");
  const themeFontWeight = fromTheme("font-weight");
  const themeTracking = fromTheme("tracking");
  const themeLeading = fromTheme("leading");
  const themeBreakpoint = fromTheme("breakpoint");
  const themeContainer = fromTheme("container");
  const themeSpacing = fromTheme("spacing");
  const themeRadius = fromTheme("radius");
  const themeShadow = fromTheme("shadow");
  const themeInsetShadow = fromTheme("inset-shadow");
  const themeDropShadow = fromTheme("drop-shadow");
  const themeBlur = fromTheme("blur");
  const themePerspective = fromTheme("perspective");
  const themeAspect = fromTheme("aspect");
  const themeEase = fromTheme("ease");
  const themeAnimate = fromTheme("animate");
  const scaleBreak = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const scalePosition = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const scaleOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const scaleOverscroll = () => ["auto", "contain", "none"];
  const scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing];
  const scaleInset = () => [isFraction, "full", "auto", ...scaleUnambiguousSpacing()];
  const scaleGridTemplateColsRows = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartAndEnd = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isArbitraryVariable, isArbitraryValue];
  const scaleGridColRowStartOrEnd = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue];
  const scaleGridAutoColsRows = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue];
  const scaleAlignPrimaryAxis = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline"];
  const scaleAlignSecondaryAxis = () => ["start", "end", "center", "stretch"];
  const scaleMargin = () => ["auto", ...scaleUnambiguousSpacing()];
  const scaleSizing = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...scaleUnambiguousSpacing()];
  const scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue];
  const scaleGradientStopPosition = () => [isPercent, isArbitraryLength];
  const scaleRadius = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    themeRadius,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleBorderWidth = () => ["", isNumber2, isArbitraryVariableLength, isArbitraryLength];
  const scaleLineStyle = () => ["solid", "dashed", "dotted", "double"];
  const scaleBlendMode = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const scaleBlur = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    themeBlur,
    isArbitraryVariable,
    isArbitraryValue
  ];
  const scaleOrigin = () => ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryVariable, isArbitraryValue];
  const scaleRotate = () => ["none", isNumber2, isArbitraryVariable, isArbitraryValue];
  const scaleScale = () => ["none", isNumber2, isArbitraryVariable, isArbitraryValue];
  const scaleSkew = () => [isNumber2, isArbitraryVariable, isArbitraryValue];
  const scaleTranslate = () => [isFraction, "full", ...scaleUnambiguousSpacing()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber2],
      text: [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isNumber2, isArbitraryValue, isArbitraryVariable, themeContainer]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": scaleBreak()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": scaleBreak()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...scalePosition(), isArbitraryValue, isArbitraryVariable]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: scaleOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": scaleOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": scaleOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: scaleOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": scaleOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": scaleOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: scaleInset()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": scaleInset()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": scaleInset()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: scaleInset()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: scaleInset()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: scaleInset()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: scaleInset()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: scaleInset()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: scaleInset()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [isFraction, "full", "auto", themeContainer, ...scaleUnambiguousSpacing()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [isNumber2, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": scaleGridTemplateColsRows()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: scaleGridColRowStartAndEnd()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": scaleGridColRowStartOrEnd()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": scaleGridAutoColsRows()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": scaleGridAutoColsRows()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: scaleUnambiguousSpacing()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": scaleUnambiguousSpacing()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": scaleUnambiguousSpacing()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...scaleAlignPrimaryAxis(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...scaleAlignSecondaryAxis(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...scaleAlignPrimaryAxis()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": scaleAlignPrimaryAxis()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...scaleAlignSecondaryAxis(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...scaleAlignSecondaryAxis()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: scaleUnambiguousSpacing()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: scaleUnambiguousSpacing()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: scaleUnambiguousSpacing()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: scaleUnambiguousSpacing()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: scaleMargin()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: scaleMargin()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: scaleMargin()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: scaleMargin()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: scaleMargin()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: scaleMargin()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: scaleMargin()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: scaleMargin()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: scaleMargin()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": scaleUnambiguousSpacing()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: scaleSizing()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [themeContainer, "screen", ...scaleSizing()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          themeContainer,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...scaleSizing()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          themeContainer,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [themeBreakpoint]
          },
          ...scaleSizing()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", ...scaleSizing()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "none", ...scaleSizing()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", ...scaleSizing()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", themeText, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [isNumber2, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          themeLeading,
          ...scaleUnambiguousSpacing()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: scaleColor()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: scaleColor()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...scaleLineStyle(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [isNumber2, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: scaleColor()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [isNumber2, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: scaleUnambiguousSpacing()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "space", "round"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: scaleColor()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: scaleGradientStopPosition()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: scaleColor()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: scaleColor()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: scaleColor()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: scaleRadius()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": scaleRadius()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": scaleRadius()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": scaleRadius()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": scaleRadius()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": scaleRadius()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": scaleRadius()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": scaleRadius()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": scaleRadius()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": scaleRadius()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": scaleRadius()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": scaleRadius()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": scaleRadius()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": scaleRadius()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": scaleRadius()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: scaleBorderWidth()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": scaleBorderWidth()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": scaleBorderWidth()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": scaleBorderWidth()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": scaleBorderWidth()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": scaleBorderWidth()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": scaleBorderWidth()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": scaleBorderWidth()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": scaleBorderWidth()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": scaleBorderWidth()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": scaleBorderWidth()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...scaleLineStyle(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: scaleColor()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": scaleColor()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": scaleColor()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": scaleColor()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": scaleColor()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": scaleColor()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": scaleColor()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": scaleColor()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": scaleColor()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: scaleColor()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...scaleLineStyle(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", isNumber2, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [themeColor]
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeShadow,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: scaleColor()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", isArbitraryVariable, isArbitraryValue, themeInsetShadow]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": scaleColor()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: scaleBorderWidth()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: scaleColor()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [isNumber2, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": scaleColor()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": scaleBorderWidth()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": scaleColor()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...scaleBlendMode(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": scaleBlendMode()
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: scaleBlur()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          themeDropShadow,
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": scaleBlur()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": scaleUnambiguousSpacing()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": scaleUnambiguousSpacing()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [isNumber2, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", themeEase, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [isNumber2, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", themeAnimate, isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": scaleOrigin()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: scaleRotate()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": scaleRotate()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": scaleRotate()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": scaleRotate()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: scaleScale()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": scaleScale()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": scaleScale()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": scaleScale()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: scaleSkew()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": scaleSkew()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": scaleSkew()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: scaleOrigin()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: scaleTranslate()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": scaleTranslate()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": scaleTranslate()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": scaleTranslate()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: scaleColor()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: scaleColor()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": scaleUnambiguousSpacing()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...scaleColor()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isNumber2, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...scaleColor()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["before", "after", "placeholder", "file", "marker", "selection", "first-line", "first-letter", "backdrop", "*", "**"]
  };
};
var mergeConfigs = (baseConfig, {
  cacheSize,
  prefix,
  experimentalParseClassName,
  extend = {},
  override = {}
}) => {
  overrideProperty(baseConfig, "cacheSize", cacheSize);
  overrideProperty(baseConfig, "prefix", prefix);
  overrideProperty(baseConfig, "experimentalParseClassName", experimentalParseClassName);
  overrideConfigProperties(baseConfig.theme, override.theme);
  overrideConfigProperties(baseConfig.classGroups, override.classGroups);
  overrideConfigProperties(baseConfig.conflictingClassGroups, override.conflictingClassGroups);
  overrideConfigProperties(baseConfig.conflictingClassGroupModifiers, override.conflictingClassGroupModifiers);
  overrideProperty(baseConfig, "orderSensitiveModifiers", override.orderSensitiveModifiers);
  mergeConfigProperties(baseConfig.theme, extend.theme);
  mergeConfigProperties(baseConfig.classGroups, extend.classGroups);
  mergeConfigProperties(baseConfig.conflictingClassGroups, extend.conflictingClassGroups);
  mergeConfigProperties(baseConfig.conflictingClassGroupModifiers, extend.conflictingClassGroupModifiers);
  mergeArrayProperties(baseConfig, extend, "orderSensitiveModifiers");
  return baseConfig;
};
var overrideProperty = (baseObject, overrideKey, overrideValue) => {
  if (overrideValue !== void 0) {
    baseObject[overrideKey] = overrideValue;
  }
};
var overrideConfigProperties = (baseObject, overrideObject) => {
  if (overrideObject) {
    for (const key in overrideObject) {
      overrideProperty(baseObject, key, overrideObject[key]);
    }
  }
};
var mergeConfigProperties = (baseObject, mergeObject) => {
  if (mergeObject) {
    for (const key in mergeObject) {
      mergeArrayProperties(baseObject, mergeObject, key);
    }
  }
};
var mergeArrayProperties = (baseObject, mergeObject, key) => {
  const mergeValue = mergeObject[key];
  if (mergeValue !== void 0) {
    baseObject[key] = baseObject[key] ? baseObject[key].concat(mergeValue) : mergeValue;
  }
};
var extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension === "function" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);

// ../../ui/src/lib/cn.ts
var twMerge = extendTailwindMerge({
  extend: {
    classGroups: {
      "border-w": ["border-host-bubble", "border-button", "border-input"],
      "border-color": [
        "border-host-bubble-border",
        "border-button-border",
        "border-input-border"
      ]
    }
  }
});
function cn(...inputs) {
  return twMerge(cx(inputs));
}

// src/components/Spinner.tsx
var _tmpl$3 = /* @__PURE__ */ template(`<svg><circle class=opacity-25 cx=12 cy=12 r=10 stroke=currentColor stroke-width=4></circle><path class=opacity-75 fill=currentColor d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">`);
var Spinner = (props7) => (() => {
  var _el$ = _tmpl$3();
  spread(_el$, mergeProps(props7, {
    get ["class"]() {
      return "animate-spin h-6 w-6 " + props7.class;
    },
    "xmlns": "http://www.w3.org/2000/svg",
    "fill": "none",
    "viewBox": "0 0 24 24",
    "data-testid": "loading-spinner"
  }), true, true);
  return _el$;
})();

// src/components/Button.tsx
var _tmpl$4 = /* @__PURE__ */ template(`<button>`);
var buttonVariants = cva("font-semibold focus:outline-none filter hover:brightness-90 active:brightness-75 disabled:opacity-50 disabled:cursor-not-allowed disabled:brightness-100 flex justify-center flex-shrink-0 transition-[filter] duration-200", {
  variants: {
    variant: {
      primary: "typebot-button bg-button-bg text-button-text border-button-border rounded-button border-button blur-button shadow-button",
      secondary: "secondary-button bg-host-bubble-bg text-host-bubble-text rounded-host-bubble border-host-bubble border-host-bubble-border"
    },
    size: {
      icon: "text-sm size-6 pt-[3px]",
      sm: "py-2 px-4 text-sm",
      md: "py-2 px-4"
    }
  },
  defaultVariants: {
    variant: "primary",
    size: "md"
  }
});
var Button = (props7) => {
  const childrenReturn = children(() => props7.children);
  const [local, buttonProps] = splitProps(props7, ["variant", "size", "isDisabled", "isLoading", "fullWidth"]);
  return (() => {
    var _el$ = _tmpl$4();
    spread(_el$, mergeProps(buttonProps, {
      get disabled() {
        return local.isDisabled || local.isLoading;
      },
      get ["class"]() {
        return cn(buttonVariants({
          variant: local.variant,
          size: local.size
        }), buttonProps.class, local.fullWidth && "w-full");
      }
    }), false, true);
    insert(_el$, createComponent(Show, {
      get when() {
        return !local.isLoading;
      },
      get fallback() {
        return createComponent(Spinner, {});
      },
      get children() {
        return childrenReturn();
      }
    }));
    return _el$;
  })();
};

// src/queries/continueChatQuery.ts
var continueChatQuery = async ({
  apiHost,
  message,
  sessionId
}) => {
  try {
    const data = await distribution_default.post(
      `${isNotEmpty(apiHost) ? apiHost : guessApiHost()}/api/v1/sessions/${sessionId}/continueChat`,
      {
        json: {
          message
        },
        timeout: false
      }
    ).json();
    return { data };
  } catch (error) {
    return { error };
  }
};

// src/queries/saveClientLogsQuery.ts
var saveClientLogsQuery = async ({
  apiHost,
  sessionId,
  clientLogs
}) => {
  try {
    await distribution_default.post(
      `${isNotEmpty(apiHost) ? apiHost : guessApiHost()}/api/v2/sessions/${sessionId}/clientLogs`,
      {
        json: {
          clientLogs
        }
      }
    );
  } catch (e) {
    console.log(e);
  }
};

// src/utils/avatarHistory.ts
var initializeAvatarHistory = ({
  initialTheme,
  dynamicTheme
}) => {
  const avatars = {
    host: initialTheme.chat?.hostAvatar && dynamicTheme?.hostAvatarUrl ? {
      ...initialTheme.chat.hostAvatar,
      url: dynamicTheme.hostAvatarUrl
    }.url : initialTheme.chat?.hostAvatar?.url,
    guest: initialTheme.chat?.guestAvatar && dynamicTheme?.guestAvatarUrl ? {
      ...initialTheme.chat.guestAvatar,
      url: dynamicTheme.guestAvatarUrl
    }.url : initialTheme.chat?.guestAvatar?.url
  };
  const history = [];
  if (avatars.host) {
    history.push({
      role: "host",
      chunkIndex: 0,
      avatarUrl: avatars.host
    });
  }
  if (avatars.guest) {
    history.push({
      role: "guest",
      chunkIndex: 0,
      avatarUrl: avatars.guest
    });
  }
  return history;
};
var getAvatarAtIndex = ({
  avatarHistory,
  currentIndex,
  currentRole
}) => {
  const changes = avatarHistory.filter(
    (change) => change.role === currentRole && change.chunkIndex <= currentIndex
  );
  if (changes.length > 0) return changes.at(-1)?.avatarUrl;
};
var addAvatarsToHistoryIfChanged = ({
  newAvatars,
  avatarHistory,
  currentChunkIndex
}) => {
  const latestHostAvatarInHistory = avatarHistory.findLast(
    (avatar) => avatar.role === "host"
  )?.avatarUrl;
  const latestGuestAvatarInHistory = avatarHistory.findLast(
    (avatar) => avatar.role === "guest"
  )?.avatarUrl;
  const newAvatarHistory = [...avatarHistory];
  if (newAvatars.host !== latestHostAvatarInHistory)
    newAvatarHistory.push({
      role: "host",
      chunkIndex: currentChunkIndex,
      avatarUrl: newAvatars.host
    });
  if (newAvatars.guest !== latestGuestAvatarInHistory)
    newAvatarHistory.push({
      role: "guest",
      chunkIndex: currentChunkIndex,
      avatarUrl: newAvatars.guest
    });
  return newAvatarHistory;
};

// src/utils/error.ts
var isNetworkError = (error) => {
  if (error instanceof TypeError) {
    const networkErrorMessages = [
      "Connection refused",
      "Failed to fetch",
      "Failed to load resource",
      "Failed to execute 'fetch' on 'Window'",
      "Load failed",
      "NetworkError",
      "Network request failed",
      "Request failed"
    ];
    const requestErrorMessages = [
      "ERR_INTERNET_DISCONNECTED",
      "ERR_NAME_NOT_RESOLVED",
      "ERR_CONNECTION_REFUSED",
      "ERR_CONNECTION_TIMED_OUT",
      "ERR_SSL_PROTOCOL_ERROR"
    ];
    return [...networkErrorMessages, ...requestErrorMessages].some(
      (message) => error.message.toLowerCase().includes(message.toLowerCase())
    );
  }
  if (error instanceof DOMException) {
    return error.name === "AbortError" || error.name === "TimeoutError";
  }
  return false;
};

// ../../lib/src/parseUnknownClientError.ts
var parseUnknownClientError = async ({
  err,
  context
}) => {
  try {
    if (typeof err === "string")
      return {
        context,
        description: err,
        details: void 0
      };
    if (err instanceof Error) {
      if ("response" in err && typeof err.response === "object" && err.response && "text" in err.response && typeof err.response.text === "function") {
        return {
          context,
          description: err.message,
          details: JSON.stringify(await err.response.text())
        };
      }
      return {
        context,
        description: err.message,
        details: typeof err.cause === "string" ? err.cause : JSON.stringify(err.cause)
      };
    }
    return {
      context,
      description: JSON.stringify(err)
    };
  } catch (err2) {
    return {
      context,
      description: "Unknown error (failed to parse)"
    };
  }
};

// src/features/blocks/logic/script/executeScript.ts
var AsyncFunction = Object.getPrototypeOf(async () => {
}).constructor;
var executeScript = async ({ content, args }) => {
  try {
    const func = AsyncFunction(
      ...args.map((arg) => arg.id),
      parseContent(content)
    );
    const result = await func(...args.map((arg) => arg.value));
    if (result && typeof result === "string")
      return {
        scriptCallbackMessage: result
      };
  } catch (err) {
    console.log(err);
    return {
      logs: [
        await parseUnknownClientError({
          err,
          context: "While executing script"
        })
      ]
    };
  }
};
var parseContent = (content) => {
  const contentWithoutScriptTags = content.replace(/<script>/g, "").replace(/<\/script>/g, "");
  return contentWithoutScriptTags;
};
var executeCode = async ({
  args,
  content
}) => {
  try {
    const func = AsyncFunction(...Object.keys(args), content);
    const result = await func(...Object.keys(args).map((key) => args[key]));
    if (result && typeof result === "string")
      return {
        scriptCallbackMessage: result
      };
  } catch (err) {
    console.warn("Script threw an error:", err);
  }
};

// src/features/blocks/integrations/chatwoot/constants.ts
var chatwootWebWidgetOpenedMessage = "Chatwoot Web Widget Opened";

// src/features/blocks/integrations/chatwoot/utils/executeChatwoot.ts
var executeChatwoot = (chatwoot) => {
  executeScript(chatwoot.scriptToExecute);
  return {
    scriptCallbackMessage: chatwootWebWidgetOpenedMessage
  };
};

// src/lib/gtag.ts
var initGoogleAnalytics = (id) => {
  if (isDefined(window.gtag)) return Promise.resolve();
  return new Promise((resolve) => {
    const existingScript = document.getElementById("gtag");
    if (!existingScript) {
      const script = document.createElement("script");
      script.src = `https://www.googletagmanager.com/gtag/js?id=${id}`;
      script.id = "gtag";
      const initScript = document.createElement("script");
      initScript.innerHTML = `window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', '${id}');
      `;
      document.body.appendChild(script);
      document.body.appendChild(initScript);
      script.onload = () => {
        resolve();
      };
    }
    if (existingScript) resolve();
  });
};
var sendGaEvent = (options2) => {
  if (!options2) return;
  if (!window.gtag) {
    console.error("Google Analytics was not properly initialized");
    return;
  }
  window.gtag("event", options2.action, {
    event_category: isEmpty(options2.category) ? void 0 : options2.category,
    event_label: isEmpty(options2.label) ? void 0 : options2.label,
    value: options2.value,
    send_to: isEmpty(options2.sendTo) ? void 0 : options2.sendTo
  });
};

// src/features/blocks/integrations/googleAnalytics/utils/executeGoogleAnalytics.ts
var executeGoogleAnalyticsBlock = async (options2) => {
  if (!options2?.trackingId) return;
  sendGaEvent(options2);
};

// src/features/blocks/integrations/httpRequest/executeHttpRequest.ts
var executeHttpRequest = async (httpRequestToExecute) => {
  const { url, method, body, headers } = httpRequestToExecute;
  try {
    const response = await fetch(url, {
      method,
      body: method !== "GET" && body ? JSON.stringify(body) : void 0,
      headers
    });
    const statusCode = response.status;
    const data = await response.json();
    return JSON.stringify({ statusCode, data });
  } catch (error) {
    console.error(error);
    return JSON.stringify({
      statusCode: 500,
      data: "An error occured while executing the webhook on the client"
    });
  }
};

// ../../../node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");

// ../../../node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// ../../../node_modules/@ai-sdk/ui-utils/dist/index.mjs
var textStreamPart = {
  code: "0",
  name: "text",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }
};
var errorStreamPart = {
  code: "3",
  name: "error",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }
};
var assistantMessageStreamPart = {
  code: "4",
  name: "assistant_message",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("id" in value) || !("role" in value) || !("content" in value) || typeof value.id !== "string" || typeof value.role !== "string" || value.role !== "assistant" || !Array.isArray(value.content) || !value.content.every(
      (item) => item != null && typeof item === "object" && "type" in item && item.type === "text" && "text" in item && item.text != null && typeof item.text === "object" && "value" in item.text && typeof item.text.value === "string"
    )) {
      throw new Error(
        '"assistant_message" parts expect an object with an "id", "role", and "content" property.'
      );
    }
    return {
      type: "assistant_message",
      value
    };
  }
};
var assistantControlDataStreamPart = {
  code: "5",
  name: "assistant_control_data",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("threadId" in value) || !("messageId" in value) || typeof value.threadId !== "string" || typeof value.messageId !== "string") {
      throw new Error(
        '"assistant_control_data" parts expect an object with a "threadId" and "messageId" property.'
      );
    }
    return {
      type: "assistant_control_data",
      value: {
        threadId: value.threadId,
        messageId: value.messageId
      }
    };
  }
};
var dataMessageStreamPart = {
  code: "6",
  name: "data_message",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("role" in value) || !("data" in value) || typeof value.role !== "string" || value.role !== "data") {
      throw new Error(
        '"data_message" parts expect an object with a "role" and "data" property.'
      );
    }
    return {
      type: "data_message",
      value
    };
  }
};
var assistantStreamParts = [
  textStreamPart,
  errorStreamPart,
  assistantMessageStreamPart,
  assistantControlDataStreamPart,
  dataMessageStreamPart
];
var assistantStreamPartsByCode = {
  [textStreamPart.code]: textStreamPart,
  [errorStreamPart.code]: errorStreamPart,
  [assistantMessageStreamPart.code]: assistantMessageStreamPart,
  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,
  [dataMessageStreamPart.code]: dataMessageStreamPart
};
var StreamStringPrefixes = {
  [textStreamPart.name]: textStreamPart.code,
  [errorStreamPart.name]: errorStreamPart.code,
  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,
  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,
  [dataMessageStreamPart.name]: dataMessageStreamPart.code
};
var validCodes = assistantStreamParts.map((part) => part.code);
var textStreamPart2 = {
  code: "0",
  name: "text",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"text" parts expect a string value.');
    }
    return { type: "text", value };
  }
};
var dataStreamPart = {
  code: "2",
  name: "data",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"data" parts expect an array value.');
    }
    return { type: "data", value };
  }
};
var errorStreamPart2 = {
  code: "3",
  name: "error",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"error" parts expect a string value.');
    }
    return { type: "error", value };
  }
};
var messageAnnotationsStreamPart = {
  code: "8",
  name: "message_annotations",
  parse: (value) => {
    if (!Array.isArray(value)) {
      throw new Error('"message_annotations" parts expect an array value.');
    }
    return { type: "message_annotations", value };
  }
};
var toolCallStreamPart = {
  code: "9",
  name: "tool_call",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string" || !("args" in value) || typeof value.args !== "object") {
      throw new Error(
        '"tool_call" parts expect an object with a "toolCallId", "toolName", and "args" property.'
      );
    }
    return {
      type: "tool_call",
      value
    };
  }
};
var toolResultStreamPart = {
  code: "a",
  name: "tool_result",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("result" in value)) {
      throw new Error(
        '"tool_result" parts expect an object with a "toolCallId" and a "result" property.'
      );
    }
    return {
      type: "tool_result",
      value
    };
  }
};
var toolCallStreamingStartStreamPart = {
  code: "b",
  name: "tool_call_streaming_start",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("toolName" in value) || typeof value.toolName !== "string") {
      throw new Error(
        '"tool_call_streaming_start" parts expect an object with a "toolCallId" and "toolName" property.'
      );
    }
    return {
      type: "tool_call_streaming_start",
      value
    };
  }
};
var toolCallDeltaStreamPart = {
  code: "c",
  name: "tool_call_delta",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("toolCallId" in value) || typeof value.toolCallId !== "string" || !("argsTextDelta" in value) || typeof value.argsTextDelta !== "string") {
      throw new Error(
        '"tool_call_delta" parts expect an object with a "toolCallId" and "argsTextDelta" property.'
      );
    }
    return {
      type: "tool_call_delta",
      value
    };
  }
};
var finishMessageStreamPart = {
  code: "d",
  name: "finish_message",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_message" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    return {
      type: "finish_message",
      value: result
    };
  }
};
var finishStepStreamPart = {
  code: "e",
  name: "finish_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("finishReason" in value) || typeof value.finishReason !== "string") {
      throw new Error(
        '"finish_step" parts expect an object with a "finishReason" property.'
      );
    }
    const result = {
      finishReason: value.finishReason,
      isContinued: false
    };
    if ("usage" in value && value.usage != null && typeof value.usage === "object" && "promptTokens" in value.usage && "completionTokens" in value.usage) {
      result.usage = {
        promptTokens: typeof value.usage.promptTokens === "number" ? value.usage.promptTokens : Number.NaN,
        completionTokens: typeof value.usage.completionTokens === "number" ? value.usage.completionTokens : Number.NaN
      };
    }
    if ("isContinued" in value && typeof value.isContinued === "boolean") {
      result.isContinued = value.isContinued;
    }
    return {
      type: "finish_step",
      value: result
    };
  }
};
var startStepStreamPart = {
  code: "f",
  name: "start_step",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("messageId" in value) || typeof value.messageId !== "string") {
      throw new Error(
        '"start_step" parts expect an object with an "id" property.'
      );
    }
    return {
      type: "start_step",
      value: {
        messageId: value.messageId
      }
    };
  }
};
var reasoningStreamPart = {
  code: "g",
  name: "reasoning",
  parse: (value) => {
    if (typeof value !== "string") {
      throw new Error('"reasoning" parts expect a string value.');
    }
    return { type: "reasoning", value };
  }
};
var sourcePart = {
  code: "h",
  name: "source",
  parse: (value) => {
    if (value == null || typeof value !== "object") {
      throw new Error('"source" parts expect a Source object.');
    }
    return {
      type: "source",
      value
    };
  }
};
var redactedReasoningStreamPart = {
  code: "i",
  name: "redacted_reasoning",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string") {
      throw new Error(
        '"redacted_reasoning" parts expect an object with a "data" property.'
      );
    }
    return { type: "redacted_reasoning", value: { data: value.data } };
  }
};
var reasoningSignatureStreamPart = {
  code: "j",
  name: "reasoning_signature",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("signature" in value) || typeof value.signature !== "string") {
      throw new Error(
        '"reasoning_signature" parts expect an object with a "signature" property.'
      );
    }
    return {
      type: "reasoning_signature",
      value: { signature: value.signature }
    };
  }
};
var fileStreamPart = {
  code: "k",
  name: "file",
  parse: (value) => {
    if (value == null || typeof value !== "object" || !("data" in value) || typeof value.data !== "string" || !("mimeType" in value) || typeof value.mimeType !== "string") {
      throw new Error(
        '"file" parts expect an object with a "data" and "mimeType" property.'
      );
    }
    return { type: "file", value };
  }
};
var dataStreamParts = [
  textStreamPart2,
  dataStreamPart,
  errorStreamPart2,
  messageAnnotationsStreamPart,
  toolCallStreamPart,
  toolResultStreamPart,
  toolCallStreamingStartStreamPart,
  toolCallDeltaStreamPart,
  finishMessageStreamPart,
  finishStepStreamPart,
  startStepStreamPart,
  reasoningStreamPart,
  sourcePart,
  redactedReasoningStreamPart,
  reasoningSignatureStreamPart,
  fileStreamPart
];
var dataStreamPartsByCode = Object.fromEntries(
  dataStreamParts.map((part) => [part.code, part])
);
var DataStreamStringPrefixes = Object.fromEntries(
  dataStreamParts.map((part) => [part.name, part.code])
);
var validCodes2 = dataStreamParts.map((part) => part.code);
var parseDataStreamPart = (line) => {
  const firstSeparatorIndex = line.indexOf(":");
  if (firstSeparatorIndex === -1) {
    throw new Error("Failed to parse stream string. No separator found.");
  }
  const prefix = line.slice(0, firstSeparatorIndex);
  if (!validCodes2.includes(prefix)) {
    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);
  }
  const code = prefix;
  const textValue = line.slice(firstSeparatorIndex + 1);
  const jsonValue = JSON.parse(textValue);
  return dataStreamPartsByCode[code].parse(jsonValue);
};
var NEWLINE = "\n".charCodeAt(0);
function concatChunks(chunks, totalLength) {
  const concatenatedChunks = new Uint8Array(totalLength);
  let offset3 = 0;
  for (const chunk of chunks) {
    concatenatedChunks.set(chunk, offset3);
    offset3 += chunk.length;
  }
  chunks.length = 0;
  return concatenatedChunks;
}
async function processDataStream({
  stream,
  onTextPart,
  onReasoningPart,
  onReasoningSignaturePart,
  onRedactedReasoningPart,
  onSourcePart,
  onFilePart,
  onDataPart,
  onErrorPart,
  onToolCallStreamingStartPart,
  onToolCallDeltaPart,
  onToolCallPart,
  onToolResultPart,
  onMessageAnnotationsPart,
  onFinishMessagePart,
  onFinishStepPart,
  onStartStepPart
}) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  const chunks = [];
  let totalLength = 0;
  while (true) {
    const { value } = await reader.read();
    if (value) {
      chunks.push(value);
      totalLength += value.length;
      if (value[value.length - 1] !== NEWLINE) {
        continue;
      }
    }
    if (chunks.length === 0) {
      break;
    }
    const concatenatedChunks = concatChunks(chunks, totalLength);
    totalLength = 0;
    const streamParts = decoder.decode(concatenatedChunks, { stream: true }).split("\n").filter((line) => line !== "").map(parseDataStreamPart);
    for (const { type, value: value2 } of streamParts) {
      switch (type) {
        case "text":
          await (onTextPart == null ? void 0 : onTextPart(value2));
          break;
        case "reasoning":
          await (onReasoningPart == null ? void 0 : onReasoningPart(value2));
          break;
        case "reasoning_signature":
          await (onReasoningSignaturePart == null ? void 0 : onReasoningSignaturePart(value2));
          break;
        case "redacted_reasoning":
          await (onRedactedReasoningPart == null ? void 0 : onRedactedReasoningPart(value2));
          break;
        case "file":
          await (onFilePart == null ? void 0 : onFilePart(value2));
          break;
        case "source":
          await (onSourcePart == null ? void 0 : onSourcePart(value2));
          break;
        case "data":
          await (onDataPart == null ? void 0 : onDataPart(value2));
          break;
        case "error":
          await (onErrorPart == null ? void 0 : onErrorPart(value2));
          break;
        case "message_annotations":
          await (onMessageAnnotationsPart == null ? void 0 : onMessageAnnotationsPart(value2));
          break;
        case "tool_call_streaming_start":
          await (onToolCallStreamingStartPart == null ? void 0 : onToolCallStreamingStartPart(value2));
          break;
        case "tool_call_delta":
          await (onToolCallDeltaPart == null ? void 0 : onToolCallDeltaPart(value2));
          break;
        case "tool_call":
          await (onToolCallPart == null ? void 0 : onToolCallPart(value2));
          break;
        case "tool_result":
          await (onToolResultPart == null ? void 0 : onToolResultPart(value2));
          break;
        case "finish_message":
          await (onFinishMessagePart == null ? void 0 : onFinishMessagePart(value2));
          break;
        case "finish_step":
          await (onFinishStepPart == null ? void 0 : onFinishStepPart(value2));
          break;
        case "start_step":
          await (onStartStepPart == null ? void 0 : onStartStepPart(value2));
          break;
        default: {
          const exhaustiveCheck = type;
          throw new Error(`Unknown stream part type: ${exhaustiveCheck}`);
        }
      }
    }
  }
}
var NEWLINE2 = "\n".charCodeAt(0);
var schemaSymbol = Symbol.for("vercel.ai.schema");

// src/features/blocks/integrations/openai/streamChat.ts
var abortController = null;
var secondsToWaitBeforeRetries = 3;
var maxRetryAttempts = 1;
var streamChat = (context) => async ({
  messages,
  onMessageStream,
  onError
}) => {
  try {
    abortController = new AbortController();
    const apiHost = context.apiHost;
    const res = await fetch(
      (isNotEmpty(apiHost) ? apiHost : guessApiHost()) + `/api/v2/sessions/${context.sessionId}/streamMessage`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages
        }),
        signal: abortController.signal
      }
    );
    if (!res.ok) {
      if ((context.retryAttempt ?? 0) < maxRetryAttempts && (res.status === 403 || res.status === 500 || res.status === 503)) {
        await new Promise(
          (resolve) => setTimeout(resolve, secondsToWaitBeforeRetries * 1e3)
        );
        return streamChat({
          ...context,
          retryAttempt: (context.retryAttempt ?? 0) + 1
        })({ messages, onMessageStream });
      }
      return {
        error: {
          description: "Failed to fetch chat streaming",
          details: await res.text(),
          context: "While streaming chat"
        }
      };
    }
    if (!res.body) {
      return {
        error: {
          description: "The chat stream response body is empty"
        }
      };
    }
    let message = "";
    const id = createUniqueId();
    await processDataStream({
      stream: res.body,
      onTextPart: async (text2) => {
        message += text2;
        if (onMessageStream) onMessageStream({ id, message });
      },
      onErrorPart: (error) => {
        onError?.(JSON.parse(error));
      }
    });
    abortController = null;
    return { message };
  } catch (err) {
    console.error(err);
    if (err.name === "AbortError") {
      abortController = null;
      return { error: { description: "Request aborted" } };
    }
    return {
      error: await parseUnknownClientError({
        err,
        context: "While streaming chat"
      })
    };
  }
};

// src/lib/pixel.ts
var initPixel = (pixelIds) => {
  const script = document.createElement("script");
  script.innerHTML = `!function(f,b,e,v,n,t,s)
  {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
  n.callMethod.apply(n,arguments):n.queue.push(arguments)};
  if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
  n.queue=[];t=b.createElement(e);t.async=!0;
  t.src=v;s=b.getElementsByTagName(e)[0];
  s.parentNode.insertBefore(t,s)}(window, document,'script',
  'https://connect.facebook.net/en_US/fbevents.js');
  ${pixelIds.map((pixelId) => `fbq('init', '${pixelId}');`).join("\n")}
  fbq('track', 'PageView');`;
  document.head.appendChild(script);
};
var trackPixelEvent = (options2) => {
  if (!options2?.eventType || !options2.pixelId) return;
  if (!window.fbq) {
    console.error("Facebook Pixel was not properly initialized");
    return;
  }
  const params = options2.params?.length ? options2.params.reduce((obj, param) => {
    if (!param.key || !param.value) return obj;
    return { ...obj, [param.key]: param.value };
  }, {}) : void 0;
  if (options2.eventType === "Custom") {
    if (!options2.name) return;
    window.fbq("trackSingleCustom", options2.pixelId, options2.name, params);
  }
  window.fbq("trackSingle", options2.pixelId, options2.eventType, params);
};

// src/features/blocks/integrations/pixel/executePixel.ts
var executePixel = async (options2) => {
  if (isEmpty(options2?.pixelId)) return;
  trackPixelEvent(options2);
};

// src/features/blocks/logic/redirect/utils/executeRedirect.ts
var executeRedirect = ({
  url,
  isNewTab
} = {}) => {
  if (!url) return;
  const updatedWindow = window.open(url, isNewTab ? "_blank" : "_top");
  if (!updatedWindow)
    return {
      blockedPopupUrl: url
    };
};

// ../../lib/src/safeStringify.ts
var safeStringify = (val) => {
  if (isNotDefined(val)) return null;
  if (typeof val === "string") return val;
  try {
    return JSON.stringify(val);
  } catch {
    console.warn("Failed to safely stringify variable value", val);
    return null;
  }
};

// src/features/blocks/logic/setVariable/executeSetVariable.ts
var AsyncFunction2 = Object.getPrototypeOf(async () => {
}).constructor;
var executeSetVariable = async ({
  content,
  args,
  isCode
}) => {
  try {
    if (!isNaN(content) && /0[^.].+/.test(content))
      return {
        replyToSend: content
      };
    const func = AsyncFunction2(
      ...args.map((arg) => arg.id),
      content.includes("return ") ? content : `return ${content}`
    );
    const replyToSend = await func(...args.map((arg) => arg.value));
    return {
      replyToSend: safeStringify(replyToSend) ?? void 0
    };
  } catch (err) {
    console.error(err);
    return {
      replyToSend: safeStringify(content) ?? void 0,
      logs: isCode ? [
        await parseUnknownClientError({
          err,
          context: "While executing set variable"
        })
      ] : void 0
    };
  }
};

// src/features/blocks/logic/wait/utils/executeWait.ts
var executeWait = async ({ secondsToWaitFor }) => {
  await new Promise((resolve) => setTimeout(resolve, secondsToWaitFor * 1e3));
};

// src/utils/getPartyKitHost.ts
var cloudFallback = "partykit.typebot.io";
var getPartyKitHost = (hostFromContext) => hostFromContext ?? getRuntimeVariable("NEXT_PUBLIC_PARTYKIT_HOST") ?? cloudFallback;

// ../../../node_modules/partysocket/dist/chunk-4SNNYC7I.mjs
if (!globalThis.EventTarget || !globalThis.Event) {
  console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);
}
var ErrorEvent = class extends Event {
  message;
  error;
  constructor(error, target) {
    super("error", target);
    this.message = error.message;
    this.error = error;
  }
};
var CloseEvent = class extends Event {
  code;
  reason;
  wasClean = true;
  constructor(code = 1e3, reason = "", target) {
    super("close", target);
    this.code = code;
    this.reason = reason;
  }
};
var Events = {
  Event,
  ErrorEvent,
  CloseEvent
};
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function cloneEventBrowser(e) {
  return new e.constructor(e.type, e);
}
function cloneEventNode(e) {
  if ("data" in e) {
    const evt2 = new MessageEvent(e.type, e);
    return evt2;
  }
  if ("code" in e || "reason" in e) {
    const evt2 = new CloseEvent(
      // @ts-expect-error we need to fix event/listener types
      e.code || 1999,
      // @ts-expect-error we need to fix event/listener types
      e.reason || "unknown reason",
      e
    );
    return evt2;
  }
  if ("error" in e) {
    const evt2 = new ErrorEvent(e.error, e);
    return evt2;
  }
  const evt = new Event(e.type, e);
  return evt;
}
var isNode3 = typeof process !== "undefined" && typeof process.versions?.node !== "undefined" && typeof document === "undefined";
var cloneEvent = isNode3 ? cloneEventNode : cloneEventBrowser;
var DEFAULT = {
  maxReconnectionDelay: 1e4,
  minReconnectionDelay: 1e3 + Math.random() * 4e3,
  minUptime: 5e3,
  reconnectionDelayGrowFactor: 1.3,
  connectionTimeout: 4e3,
  maxRetries: Infinity,
  maxEnqueuedMessages: Infinity,
  startClosed: false,
  debug: false
};
var didWarnAboutMissingWebSocket = false;
var ReconnectingWebSocket = class _ReconnectingWebSocket extends EventTarget {
  _ws;
  _retryCount = -1;
  _uptimeTimeout;
  _connectTimeout;
  _shouldReconnect = true;
  _connectLock = false;
  _binaryType = "blob";
  _closeCalled = false;
  _messageQueue = [];
  _debugLogger = console.log.bind(console);
  _url;
  _protocols;
  _options;
  constructor(url, protocols, options2 = {}) {
    super();
    this._url = url;
    this._protocols = protocols;
    this._options = options2;
    if (this._options.startClosed) {
      this._shouldReconnect = false;
    }
    if (this._options.debugLogger) {
      this._debugLogger = this._options.debugLogger;
    }
    this._connect();
  }
  static get CONNECTING() {
    return 0;
  }
  static get OPEN() {
    return 1;
  }
  static get CLOSING() {
    return 2;
  }
  static get CLOSED() {
    return 3;
  }
  get CONNECTING() {
    return _ReconnectingWebSocket.CONNECTING;
  }
  get OPEN() {
    return _ReconnectingWebSocket.OPEN;
  }
  get CLOSING() {
    return _ReconnectingWebSocket.CLOSING;
  }
  get CLOSED() {
    return _ReconnectingWebSocket.CLOSED;
  }
  get binaryType() {
    return this._ws ? this._ws.binaryType : this._binaryType;
  }
  set binaryType(value) {
    this._binaryType = value;
    if (this._ws) {
      this._ws.binaryType = value;
    }
  }
  /**
   * Returns the number or connection retries
   */
  get retryCount() {
    return Math.max(this._retryCount, 0);
  }
  /**
   * The number of bytes of data that have been queued using calls to send() but not yet
   * transmitted to the network. This value resets to zero once all queued data has been sent.
   * This value does not reset to zero when the connection is closed; if you keep calling send(),
   * this will continue to climb. Read only
   */
  get bufferedAmount() {
    const bytes = this._messageQueue.reduce((acc, message) => {
      if (typeof message === "string") {
        acc += message.length;
      } else if (message instanceof Blob) {
        acc += message.size;
      } else {
        acc += message.byteLength;
      }
      return acc;
    }, 0);
    return bytes + (this._ws ? this._ws.bufferedAmount : 0);
  }
  /**
   * The extensions selected by the server. This is currently only the empty string or a list of
   * extensions as negotiated by the connection
   */
  get extensions() {
    return this._ws ? this._ws.extensions : "";
  }
  /**
   * A string indicating the name of the sub-protocol the server selected;
   * this will be one of the strings specified in the protocols parameter when creating the
   * WebSocket object
   */
  get protocol() {
    return this._ws ? this._ws.protocol : "";
  }
  /**
   * The current state of the connection; this is one of the Ready state constants
   */
  get readyState() {
    if (this._ws) {
      return this._ws.readyState;
    }
    return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;
  }
  /**
   * The URL as resolved by the constructor
   */
  get url() {
    return this._ws ? this._ws.url : "";
  }
  /**
   * Whether the websocket object is now in reconnectable state
   */
  get shouldReconnect() {
    return this._shouldReconnect;
  }
  /**
   * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
   */
  onclose = null;
  /**
   * An event listener to be called when an error occurs
   */
  onerror = null;
  /**
   * An event listener to be called when a message is received from the server
   */
  onmessage = null;
  /**
   * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
   * this indicates that the connection is ready to send and receive data
   */
  onopen = null;
  /**
   * Closes the WebSocket connection or connection attempt, if any. If the connection is already
   * CLOSED, this method does nothing
   */
  close(code = 1e3, reason) {
    this._closeCalled = true;
    this._shouldReconnect = false;
    this._clearTimeouts();
    if (!this._ws) {
      this._debug("close enqueued: no ws instance");
      return;
    }
    if (this._ws.readyState === this.CLOSED) {
      this._debug("close: already closed");
      return;
    }
    this._ws.close(code, reason);
  }
  /**
   * Closes the WebSocket connection or connection attempt and connects again.
   * Resets retry counter;
   */
  reconnect(code, reason) {
    this._shouldReconnect = true;
    this._closeCalled = false;
    this._retryCount = -1;
    if (!this._ws || this._ws.readyState === this.CLOSED) {
      this._connect();
    } else {
      this._disconnect(code, reason);
      this._connect();
    }
  }
  /**
   * Enqueue specified data to be transmitted to the server over the WebSocket connection
   */
  send(data) {
    if (this._ws && this._ws.readyState === this.OPEN) {
      this._debug("send", data);
      this._ws.send(data);
    } else {
      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
      if (this._messageQueue.length < maxEnqueuedMessages) {
        this._debug("enqueue", data);
        this._messageQueue.push(data);
      }
    }
  }
  _debug(...args) {
    if (this._options.debug) {
      this._debugLogger("RWS>", ...args);
    }
  }
  _getNextDelay() {
    const {
      reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,
      minReconnectionDelay = DEFAULT.minReconnectionDelay,
      maxReconnectionDelay = DEFAULT.maxReconnectionDelay
    } = this._options;
    let delay3 = 0;
    if (this._retryCount > 0) {
      delay3 = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
      if (delay3 > maxReconnectionDelay) {
        delay3 = maxReconnectionDelay;
      }
    }
    this._debug("next delay", delay3);
    return delay3;
  }
  _wait() {
    return new Promise((resolve) => {
      setTimeout(resolve, this._getNextDelay());
    });
  }
  _getNextProtocols(protocolsProvider) {
    if (!protocolsProvider) return Promise.resolve(null);
    if (typeof protocolsProvider === "string" || Array.isArray(protocolsProvider)) {
      return Promise.resolve(protocolsProvider);
    }
    if (typeof protocolsProvider === "function") {
      const protocols = protocolsProvider();
      if (!protocols) return Promise.resolve(null);
      if (typeof protocols === "string" || Array.isArray(protocols)) {
        return Promise.resolve(protocols);
      }
      if (protocols.then) {
        return protocols;
      }
    }
    throw Error("Invalid protocols");
  }
  _getNextUrl(urlProvider) {
    if (typeof urlProvider === "string") {
      return Promise.resolve(urlProvider);
    }
    if (typeof urlProvider === "function") {
      const url = urlProvider();
      if (typeof url === "string") {
        return Promise.resolve(url);
      }
      if (url.then) {
        return url;
      }
    }
    throw Error("Invalid URL");
  }
  _connect() {
    if (this._connectLock || !this._shouldReconnect) {
      return;
    }
    this._connectLock = true;
    const {
      maxRetries = DEFAULT.maxRetries,
      connectionTimeout = DEFAULT.connectionTimeout
    } = this._options;
    if (this._retryCount >= maxRetries) {
      this._debug("max retries reached", this._retryCount, ">=", maxRetries);
      return;
    }
    this._retryCount++;
    this._debug("connect", this._retryCount);
    this._removeListeners();
    this._wait().then(
      () => Promise.all([
        this._getNextUrl(this._url),
        this._getNextProtocols(this._protocols || null)
      ])
    ).then(([url, protocols]) => {
      if (this._closeCalled) {
        this._connectLock = false;
        return;
      }
      if (!this._options.WebSocket && typeof WebSocket === "undefined" && !didWarnAboutMissingWebSocket) {
        console.error(`\u203C\uFE0F No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`);
        didWarnAboutMissingWebSocket = true;
      }
      const WS = this._options.WebSocket || WebSocket;
      this._debug("connect", { url, protocols });
      this._ws = protocols ? new WS(url, protocols) : new WS(url);
      this._ws.binaryType = this._binaryType;
      this._connectLock = false;
      this._addListeners();
      this._connectTimeout = setTimeout(
        () => this._handleTimeout(),
        connectionTimeout
      );
    }).catch((err) => {
      this._connectLock = false;
      this._handleError(new Events.ErrorEvent(Error(err.message), this));
    });
  }
  _handleTimeout() {
    this._debug("timeout event");
    this._handleError(new Events.ErrorEvent(Error("TIMEOUT"), this));
  }
  _disconnect(code = 1e3, reason) {
    this._clearTimeouts();
    if (!this._ws) {
      return;
    }
    this._removeListeners();
    try {
      this._ws.close(code, reason);
      this._handleClose(new Events.CloseEvent(code, reason, this));
    } catch (error) {
    }
  }
  _acceptOpen() {
    this._debug("accept open");
    this._retryCount = 0;
  }
  _handleOpen = (event) => {
    this._debug("open event");
    const { minUptime = DEFAULT.minUptime } = this._options;
    clearTimeout(this._connectTimeout);
    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
    assert(this._ws, "WebSocket is not defined");
    this._ws.binaryType = this._binaryType;
    this._messageQueue.forEach((message) => this._ws?.send(message));
    this._messageQueue = [];
    if (this.onopen) {
      this.onopen(event);
    }
    this.dispatchEvent(cloneEvent(event));
  };
  _handleMessage = (event) => {
    this._debug("message event");
    if (this.onmessage) {
      this.onmessage(event);
    }
    this.dispatchEvent(cloneEvent(event));
  };
  _handleError = (event) => {
    this._debug("error event", event.message);
    this._disconnect(
      void 0,
      event.message === "TIMEOUT" ? "timeout" : void 0
    );
    if (this.onerror) {
      this.onerror(event);
    }
    this._debug("exec error listeners");
    this.dispatchEvent(cloneEvent(event));
    this._connect();
  };
  _handleClose = (event) => {
    this._debug("close event");
    this._clearTimeouts();
    if (this._shouldReconnect) {
      this._connect();
    }
    if (this.onclose) {
      this.onclose(event);
    }
    this.dispatchEvent(cloneEvent(event));
  };
  _removeListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("removeListeners");
    this._ws.removeEventListener("open", this._handleOpen);
    this._ws.removeEventListener("close", this._handleClose);
    this._ws.removeEventListener("message", this._handleMessage);
    this._ws.removeEventListener("error", this._handleError);
  }
  _addListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("addListeners");
    this._ws.addEventListener("open", this._handleOpen);
    this._ws.addEventListener("close", this._handleClose);
    this._ws.addEventListener("message", this._handleMessage);
    this._ws.addEventListener("error", this._handleError);
  }
  _clearTimeouts() {
    clearTimeout(this._connectTimeout);
    clearTimeout(this._uptimeTimeout);
  }
};

// ../../../node_modules/partysocket/dist/chunk-H3IJA3WK.mjs
var valueIsNotNil = (keyValuePair) => keyValuePair[1] !== null && keyValuePair[1] !== void 0;
function generateUUID() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  let d = (/* @__PURE__ */ new Date()).getTime();
  let d2 = typeof performance !== "undefined" && performance.now && performance.now() * 1e3 || 0;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    let r2 = Math.random() * 16;
    if (d > 0) {
      r2 = (d + r2) % 16 | 0;
      d = Math.floor(d / 16);
    } else {
      r2 = (d2 + r2) % 16 | 0;
      d2 = Math.floor(d2 / 16);
    }
    return (c === "x" ? r2 : r2 & 3 | 8).toString(16);
  });
}
function getPartyInfo(partySocketOptions, defaultProtocol, defaultParams = {}) {
  const {
    host: rawHost,
    path: rawPath,
    protocol: rawProtocol,
    room,
    party,
    prefix,
    query
  } = partySocketOptions;
  let host = rawHost.replace(/^(http|https|ws|wss):\/\//, "");
  if (host.endsWith("/")) {
    host = host.slice(0, -1);
  }
  if (rawPath && rawPath.startsWith("/")) {
    throw new Error("path must not start with a slash");
  }
  const name = party ?? "main";
  const path = rawPath ? `/${rawPath}` : "";
  const protocol = rawProtocol || (host.startsWith("localhost:") || host.startsWith("127.0.0.1:") || host.startsWith("192.168.") || host.startsWith("10.") || host.startsWith("172.") && host.split(".")[1] >= "16" && host.split(".")[1] <= "31" || host.startsWith("[::ffff:7f00:1]:") ? (
    // http / ws
    defaultProtocol
  ) : (
    // https / wss
    defaultProtocol + "s"
  ));
  const baseUrl = `${protocol}://${host}/${prefix || `parties/${name}/${room}`}${path}`;
  const makeUrl = (query2 = {}) => `${baseUrl}?${new URLSearchParams([
    ...Object.entries(defaultParams),
    ...Object.entries(query2).filter(valueIsNotNil)
  ])}`;
  const urlProvider = typeof query === "function" ? async () => makeUrl(await query()) : makeUrl(query);
  return {
    host,
    path,
    room,
    name,
    protocol,
    partyUrl: baseUrl,
    urlProvider
  };
}
var PartySocket = class extends ReconnectingWebSocket {
  constructor(partySocketOptions) {
    const wsOptions = getWSOptions(partySocketOptions);
    super(wsOptions.urlProvider, wsOptions.protocols, wsOptions.socketOptions);
    this.partySocketOptions = partySocketOptions;
    this.setWSProperties(wsOptions);
  }
  _pk;
  _pkurl;
  name;
  room;
  host;
  path;
  updateProperties(partySocketOptions) {
    const wsOptions = getWSOptions({
      ...this.partySocketOptions,
      ...partySocketOptions,
      host: partySocketOptions.host ?? this.host,
      room: partySocketOptions.room ?? this.room,
      path: partySocketOptions.path ?? this.path
    });
    this._url = wsOptions.urlProvider;
    this._protocols = wsOptions.protocols;
    this._options = wsOptions.socketOptions;
    this.setWSProperties(wsOptions);
  }
  setWSProperties(wsOptions) {
    const { _pk, _pkurl, name, room, host, path } = wsOptions;
    this._pk = _pk;
    this._pkurl = _pkurl;
    this.name = name;
    this.room = room;
    this.host = host;
    this.path = path;
  }
  reconnect(code, reason) {
    if (!this.room || !this.host) {
      throw new Error(
        "The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor."
      );
    }
    super.reconnect(code, reason);
  }
  get id() {
    return this._pk;
  }
  /**
   * Exposes the static PartyKit room URL without applying query parameters.
   * To access the currently connected WebSocket url, use PartySocket#url.
   */
  get roomUrl() {
    return this._pkurl;
  }
  // a `fetch` method that uses (almost) the same options as `PartySocket`
  static async fetch(options2, init) {
    const party = getPartyInfo(options2, "http");
    const url = typeof party.urlProvider === "string" ? party.urlProvider : await party.urlProvider();
    const doFetch = options2.fetch ?? fetch;
    return doFetch(url, init);
  }
};
function getWSOptions(partySocketOptions) {
  const {
    id,
    host: _host,
    path: _path,
    party: _party,
    room: _room,
    protocol: _protocol,
    query: _query,
    protocols,
    ...socketOptions
  } = partySocketOptions;
  const _pk = id || generateUUID();
  const party = getPartyInfo(partySocketOptions, "ws", { _pk });
  return {
    _pk,
    _pkurl: party.partyUrl,
    name: party.name,
    room: party.room,
    host: party.host,
    path: party.path,
    protocols,
    socketOptions,
    urlProvider: party.urlProvider
  };
}

// src/features/blocks/logic/webhook/listenForWebhook.ts
var listenForWebhook = ({ sessionId, resultId, context }) => {
  const ws = new PartySocket({
    host: getPartyKitHost(context.wsHost),
    room: getRoomName({ sessionId, resultId })
  });
  return new Promise((resolve) => {
    ws.addEventListener("message", (event) => {
      ws.close();
      resolve({ replyToSend: event.data });
    });
    ws.addEventListener("error", (error) => {
      resolve({
        logs: [
          {
            status: "error",
            description: "Websocket returned an error",
            details: JSON.stringify(error, null, 2)
          }
        ],
        replyToSend: void 0
      });
    });
  });
};
var getRoomName = ({
  sessionId,
  resultId
}) => {
  if (resultId) return `${resultId}/webhooks`;
  const [typebotId, userId] = sessionId.split("-");
  return `${userId}/${typebotId}/webhooks`;
};

// src/lib/gtm.ts
var gtmBodyElement = (googleTagManagerId) => {
  if (document.getElementById("gtm-noscript")) return "";
  const noScriptElement = document.createElement("noscript");
  noScriptElement.id = "gtm-noscript";
  const iframeElement = document.createElement("iframe");
  iframeElement.src = `https://www.googletagmanager.com/ns.html?id=${googleTagManagerId}`;
  iframeElement.height = "0";
  iframeElement.width = "0";
  iframeElement.style.display = "none";
  iframeElement.style.visibility = "hidden";
  noScriptElement.appendChild(iframeElement);
  return noScriptElement;
};

// src/utils/injectStartProps.ts
var injectStartProps = async (startPropsToInject) => {
  const customHeadCode = startPropsToInject.customHeadCode;
  if (isNotEmpty(customHeadCode)) injectCustomHeadCode(customHeadCode);
  const gtmId = startPropsToInject.gtmId;
  if (isNotEmpty(gtmId)) document.body.prepend(gtmBodyElement(gtmId));
  const googleAnalyticsId = startPropsToInject.googleAnalyticsId;
  if (isNotEmpty(googleAnalyticsId))
    await initGoogleAnalytics(googleAnalyticsId);
  const pixelIds = startPropsToInject.pixelIds;
  if (isDefined(pixelIds)) initPixel(pixelIds);
};

// src/utils/executeClientSideActions.ts
var executeClientSideAction = async ({
  clientSideAction,
  context,
  onMessageStream,
  onStreamError
}) => {
  if ("chatwoot" in clientSideAction) {
    return executeChatwoot(clientSideAction.chatwoot);
  }
  if ("googleAnalytics" in clientSideAction) {
    return executeGoogleAnalyticsBlock(clientSideAction.googleAnalytics);
  }
  if ("scriptToExecute" in clientSideAction) {
    return executeScript(clientSideAction.scriptToExecute);
  }
  if ("redirect" in clientSideAction) {
    return executeRedirect(clientSideAction.redirect);
  }
  if ("wait" in clientSideAction) {
    await executeWait(clientSideAction.wait);
    return clientSideAction.expectsDedicatedReply ? { replyToSend: void 0 } : void 0;
  }
  if ("setVariable" in clientSideAction) {
    return executeSetVariable(clientSideAction.setVariable.scriptToExecute);
  }
  if ("streamOpenAiChatCompletion" in clientSideAction || "stream" in clientSideAction) {
    const { error, message } = await streamChat(context)({
      messages: "streamOpenAiChatCompletion" in clientSideAction ? clientSideAction.streamOpenAiChatCompletion?.messages : void 0,
      onMessageStream,
      onError: onStreamError
    });
    if (error)
      return {
        replyToSend: void 0,
        logs: [
          {
            status: "error",
            description: "Message streaming returned an error",
            details: JSON.stringify(error, null, 2)
          }
        ]
      };
    return { replyToSend: message };
  }
  if ("httpRequestToExecute" in clientSideAction) {
    const response = await executeHttpRequest(
      clientSideAction.httpRequestToExecute
    );
    return { replyToSend: response };
  }
  if ("startPropsToInject" in clientSideAction) {
    return injectStartProps(clientSideAction.startPropsToInject);
  }
  if ("pixel" in clientSideAction) {
    return executePixel(clientSideAction.pixel);
  }
  if ("codeToExecute" in clientSideAction) {
    return executeCode(clientSideAction.codeToExecute);
  }
  if (clientSideAction.type === "listenForWebhook") {
    return listenForWebhook({
      sessionId: context.sessionId,
      resultId: context.resultId,
      context
    });
  }
};

// src/utils/formattedMessagesSignal.ts
var [formattedMessages, setFormattedMessages] = createSignal([]);

// src/utils/getAnswerContent.ts
var getAnswerContent = (answer) => {
  if (answer.type === "text") return answer.label ?? answer.value;
  return answer.url;
};

// src/utils/hiddenInputSignal.ts
var [hiddenInput, setHiddenInput] = createSignal({});

// src/utils/isMobileSignal.ts
var [isMobile, setIsMobile] = createSignal();
var [isMediumContainer, setIsMediumContainer] = createSignal();

// src/utils/streamingMessageSignal.ts
var [streamingMessage, setStreamingMessage] = createSignal();

// ../../schemas/src/versions.ts
var latestTypebotVersion = "6.1";

// src/components/icons/CloseIcon.tsx
var _tmpl$5 = /* @__PURE__ */ template(`<svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2px stroke-linecap=round stroke-linejoin=round><line x1=18 y1=6 x2=6 y2=18></line><line x1=6 y1=6 x2=18 y2=18>`);
var CloseIcon = (props7) => (() => {
  var _el$ = _tmpl$5();
  spread(_el$, props7, true, true);
  return _el$;
})();

// src/components/inputs/SearchInput.tsx
var _tmpl$6 = /* @__PURE__ */ template(`<button class="w-5 h-5">`);
var _tmpl$22 = /* @__PURE__ */ template(`<div class="flex justify-between items-center gap-2 w-full pr-4"><input class="focus:outline-none bg-transparent px-4 py-4 flex-1 w-full text-input"type=text>`);
var SearchInput = (props7) => {
  const [value, setValue] = createSignal("");
  const [local, others] = splitProps(props7, ["onInput", "ref"]);
  const changeValue = (value2) => {
    setValue(value2);
    local.onInput(value2);
  };
  const clearValue = () => {
    setValue("");
    props7.onClear();
  };
  return (() => {
    var _el$ = _tmpl$22(), _el$2 = _el$.firstChild;
    _el$2.$$input = (e) => changeValue(e.currentTarget.value);
    var _ref$ = props7.ref;
    typeof _ref$ === "function" ? use(_ref$, _el$2) : props7.ref = _el$2;
    spread(_el$2, mergeProps({
      get value() {
        return value();
      }
    }, others), false, false);
    insert(_el$, createComponent(Show, {
      get when() {
        return value().length > 0;
      },
      get children() {
        var _el$3 = _tmpl$6();
        addEventListener(_el$3, "click", clearValue);
        insert(_el$3, createComponent(CloseIcon, {}));
        return _el$3;
      }
    }), null);
    return _el$;
  })();
};
delegateEvents(["input"]);

// ../../blocks/inputs/src/constants.ts
var defaultButtonLabel = "Send";

// ../../blocks/inputs/src/choice/constants.ts
var defaultChoiceInputOptions = {
  buttonLabel: defaultButtonLabel,
  searchInputPlaceholder: "Filter the options...",
  isMultipleChoice: false,
  isSearchable: false,
  areInitialSearchButtonsVisible: true
};

// src/features/blocks/inputs/buttons/components/Buttons.tsx
var _tmpl$7 = /* @__PURE__ */ template(`<div class="flex items-end typebot-input w-full">`);
var _tmpl$23 = /* @__PURE__ */ template(`<div class="flex flex-col items-end gap-2 w-full typebot-buttons-input"><div data-slot=list>`);
var _tmpl$32 = /* @__PURE__ */ template(`<span>`);
var _tmpl$42 = /* @__PURE__ */ template(`<span class="flex h-3 w-3 absolute top-0 right-0 -mt-1 -mr-1 ping"><span class="animate-ping absolute inline-flex h-full w-full rounded-full brightness-200 opacity-75"></span><span class="relative inline-flex rounded-full h-3 w-3 brightness-150">`);
var Buttons = (props7) => {
  let inputRef;
  const areButtonsVisible = props7.options?.areInitialSearchButtonsVisible ?? defaultChoiceInputOptions.areInitialSearchButtonsVisible;
  const [filteredItems, setFilteredItems] = createSignal(props7.options?.isSearchable && !areButtonsVisible ? [] : props7.defaultItems);
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
  });
  const handleClick = (itemIndex) => {
    const item = filteredItems()[itemIndex];
    const {
      value,
      content
    } = item;
    props7.onSubmit({
      type: "text",
      value: value ?? content ?? "",
      label: value ? content : void 0
    });
  };
  const filterItems = (inputValue) => {
    if (inputValue === "" || inputValue.trim().length === 0) {
      setFilteredItems(!areButtonsVisible ? [] : props7.defaultItems);
      return;
    }
    setFilteredItems(props7.defaultItems.filter((item) => item.content?.toLowerCase().includes(inputValue.toLowerCase())));
  };
  return (() => {
    var _el$ = _tmpl$23(), _el$3 = _el$.firstChild;
    insert(_el$, createComponent(Show, {
      get when() {
        return props7.options?.isSearchable;
      },
      get children() {
        var _el$2 = _tmpl$7();
        insert(_el$2, createComponent(SearchInput, {
          ref(r$) {
            var _ref$ = inputRef;
            typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
          },
          onInput: filterItems,
          get placeholder() {
            return props7.options?.searchInputPlaceholder ?? defaultChoiceInputOptions.searchInputPlaceholder;
          },
          onClear: () => setFilteredItems(!areButtonsVisible ? [] : props7.defaultItems)
        }));
        return _el$2;
      }
    }), _el$3);
    insert(_el$3, createComponent(For, {
      get each() {
        return filteredItems();
      },
      children: (item, index) => (() => {
        var _el$4 = _tmpl$32();
        insert(_el$4, createComponent(Button, {
          "on:click": () => handleClick(index()),
          get ["data-itemid"]() {
            return item.id;
          },
          "class": "w-full",
          get children() {
            return item.content;
          }
        }), null);
        insert(_el$4, (() => {
          var _c$ = createMemo(() => !!(props7.chunkIndex === 0 && props7.defaultItems.length === 1));
          return () => _c$() && _tmpl$42();
        })(), null);
        createRenderEffect(() => className(_el$4, "relative" + (isMobile() ? " w-full" : "")));
        return _el$4;
      })()
    }));
    createRenderEffect(() => className(_el$3, "flex justify-end gap-2" + (props7.options?.isSearchable ? " overflow-y-scroll max-h-80 rounded-md" : "")));
    return _el$;
  })();
};

// src/components/icons/SendIcon.tsx
var _tmpl$8 = /* @__PURE__ */ template(`<svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 512 512"fill=currentColor><path d="M476.59 227.05l-.16-.07L49.35 49.84A23.56 23.56 0 0027.14 52 24.65 24.65 0 0016 72.59v113.29a24 24 0 0019.52 23.57l232.93 43.07a4 4 0 010 7.86L35.53 303.45A24 24 0 0016 327v113.31A23.57 23.57 0 0026.59 460a23.94 23.94 0 0013.22 4 24.55 24.55 0 009.52-1.93L476.4 285.94l.19-.09a32 32 0 000-58.8z">`);
var SendIcon = (props7) => (() => {
  var _el$ = _tmpl$8();
  spread(_el$, props7, true, true);
  return _el$;
})();

// src/components/SendButton.tsx
var SendButton = (props7) => {
  const [local, buttonProps] = splitProps(props7, ["isDisabled", "isLoading", "disableIcon"]);
  const showIcon = isMobile() && !local.disableIcon || !buttonProps.children || typeof buttonProps.children === "string" && isEmpty(buttonProps.children);
  return createComponent(Button, mergeProps(buttonProps, {
    type: "submit",
    get ["class"]() {
      return cx(buttonProps.class, "flex items-center rounded-3xl");
    },
    "aria-label": showIcon ? "Send" : void 0,
    get children() {
      return createComponent(Switch, {
        get children() {
          return [createComponent(Match, {
            when: showIcon,
            get children() {
              return createComponent(SendIcon, {
                get ["class"]() {
                  return "send-icon flex w-6 h-6 " + (local.disableIcon ? "hidden" : "");
                }
              });
            }
          }), createComponent(Match, {
            when: !showIcon,
            get children() {
              return props7.children;
            }
          })];
        }
      });
    }
  }));
};

// src/components/icons/CheckIcon.tsx
var _tmpl$9 = /* @__PURE__ */ template(`<svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=3px stroke-linecap=round stroke-linejoin=round><polyline points="20 6 9 17 4 12">`);
var CheckIcon = (props7) => (() => {
  var _el$ = _tmpl$9();
  spread(_el$, props7, true, true);
  return _el$;
})();

// src/features/blocks/inputs/buttons/components/Checkbox.tsx
var _tmpl$10 = /* @__PURE__ */ template(`<div>`);
var Checkbox = (props7) => {
  return (() => {
    var _el$ = _tmpl$10();
    insert(_el$, createComponent(Show, {
      get when() {
        return props7.isChecked;
      },
      get children() {
        return createComponent(CheckIcon, {});
      }
    }));
    createRenderEffect(() => className(_el$, "w-4 h-4 typebot-checkbox" + (props7.isChecked ? " checked" : "") + (props7.class ? ` ${props7.class}` : "")));
    return _el$;
  })();
};

// src/features/blocks/inputs/buttons/components/MultipleChoicesForm.tsx
var _tmpl$11 = /* @__PURE__ */ template(`<div class="flex items-end typebot-input w-full">`);
var _tmpl$24 = /* @__PURE__ */ template(`<form class="flex flex-col items-end gap-2 w-full typebot-buttons-input"><div data-slot=list>`);
var _tmpl$33 = /* @__PURE__ */ template(`<span><div role=checkbox><div class="flex items-center gap-2"><span>`);
var _tmpl$43 = /* @__PURE__ */ template(`<span><div role=checkbox aria-checked class="w-full py-2 px-4 font-semibold focus:outline-none cursor-pointer select-none typebot-selectable selected"><div class="flex items-center gap-2"><span>`);
var MultipleChoicesForm = (props7) => {
  let inputRef;
  const [filteredItems, setFilteredItems] = createSignal(props7.options?.isSearchable && !props7.options?.areInitialSearchButtonsVisible ? [] : props7.defaultItems);
  const [selectedItemIds, setSelectedItemIds] = createSignal([]);
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
  });
  const handleClick = (itemId) => {
    toggleSelectedItemId(itemId);
  };
  const toggleSelectedItemId = (itemId) => {
    const existingIndex = selectedItemIds().indexOf(itemId);
    if (existingIndex !== -1) {
      setSelectedItemIds((selectedItemIds2) => selectedItemIds2.filter((selectedItemId) => selectedItemId !== itemId));
    } else {
      setSelectedItemIds((selectedIndices) => [...selectedIndices, itemId]);
    }
  };
  const handleSubmit = () => {
    const selectedItems = selectedItemIds().map((selectedItemId) => props7.defaultItems.find((item) => item.id === selectedItemId));
    const hasInternalValue = selectedItems.some((item) => item?.value);
    props7.onSubmit({
      type: "text",
      value: selectedItems.map((item) => {
        return item?.value ?? item?.content;
      }).join(", "),
      label: hasInternalValue ? selectedItems.map((item) => {
        return item?.content ?? item?.value;
      }).join(", ") : void 0
    });
  };
  const filterItems = (inputValue) => {
    if (inputValue === "" || inputValue.trim().length === 0) {
      setFilteredItems(!props7.options?.areInitialSearchButtonsVisible ? [] : props7.defaultItems);
      return;
    }
    setFilteredItems(props7.defaultItems.filter((item) => item.content?.toLowerCase().includes(inputValue.toLowerCase())));
  };
  return (() => {
    var _el$ = _tmpl$24(), _el$3 = _el$.firstChild;
    _el$.addEventListener("submit", handleSubmit);
    insert(_el$, createComponent(Show, {
      get when() {
        return props7.options?.isSearchable;
      },
      get children() {
        var _el$2 = _tmpl$11();
        insert(_el$2, createComponent(SearchInput, {
          ref(r$) {
            var _ref$ = inputRef;
            typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
          },
          onInput: filterItems,
          get placeholder() {
            return props7.options?.searchInputPlaceholder ?? defaultChoiceInputOptions.searchInputPlaceholder;
          },
          onClear: () => setFilteredItems(!props7.options?.areInitialSearchButtonsVisible ? [] : props7.defaultItems)
        }));
        return _el$2;
      }
    }), _el$3);
    insert(_el$3, createComponent(For, {
      get each() {
        return filteredItems();
      },
      children: (item) => (() => {
        var _el$4 = _tmpl$33(), _el$5 = _el$4.firstChild, _el$6 = _el$5.firstChild, _el$7 = _el$6.firstChild;
        addEventListener(_el$5, "click", () => handleClick(item.id));
        insert(_el$6, createComponent(Checkbox, {
          get isChecked() {
            return selectedItemIds().some((selectedItemId) => selectedItemId === item.id);
          },
          "class": "flex-shrink-0"
        }), _el$7);
        insert(_el$7, () => item.content);
        createRenderEffect((_p$) => {
          var _v$ = "relative" + (isMobile() ? " w-full" : ""), _v$2 = selectedItemIds().some((selectedItemId) => selectedItemId === item.id), _v$3 = "w-full py-2 px-4 font-semibold focus:outline-none cursor-pointer select-none typebot-selectable" + (selectedItemIds().some((selectedItemId) => selectedItemId === item.id) ? " selected" : ""), _v$4 = item.id;
          _v$ !== _p$.e && className(_el$4, _p$.e = _v$);
          _v$2 !== _p$.t && setAttribute(_el$5, "aria-checked", _p$.t = _v$2);
          _v$3 !== _p$.a && className(_el$5, _p$.a = _v$3);
          _v$4 !== _p$.o && setAttribute(_el$5, "data-itemid", _p$.o = _v$4);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0,
          o: void 0
        });
        return _el$4;
      })()
    }), null);
    insert(_el$3, createComponent(For, {
      get each() {
        return selectedItemIds().filter((selectedItemId) => filteredItems().every((item) => item.id !== selectedItemId));
      },
      children: (selectedItemId) => (() => {
        var _el$8 = _tmpl$43(), _el$9 = _el$8.firstChild, _el$10 = _el$9.firstChild, _el$11 = _el$10.firstChild;
        addEventListener(_el$9, "click", () => handleClick(selectedItemId));
        setAttribute(_el$9, "data-itemid", selectedItemId);
        insert(_el$10, createComponent(Checkbox, {
          isChecked: true
        }), _el$11);
        insert(_el$11, () => props7.defaultItems.find((item) => item.id === selectedItemId)?.content);
        createRenderEffect(() => className(_el$8, "relative" + (isMobile() ? " w-full" : "")));
        return _el$8;
      })()
    }), null);
    insert(_el$, (() => {
      var _c$ = createMemo(() => selectedItemIds().length > 0);
      return () => _c$() && createComponent(SendButton, {
        disableIcon: true,
        get children() {
          return props7.options?.buttonLabel ?? defaultChoiceInputOptions.buttonLabel;
        }
      });
    })(), null);
    createRenderEffect(() => className(_el$3, "flex justify-end gap-2" + (props7.options?.isSearchable ? " overflow-y-scroll max-h-80 rounded-md" : "")));
    return _el$;
  })();
};

// src/components/carousel.tsx
var Root = (props7) => {
  return createComponent(carousel_exports.Root, props7);
};
var Control = (props7) => {
  return createComponent(carousel_exports.Control, props7);
};
var PrevTrigger = (props7) => {
  return createComponent(carousel_exports.PrevTrigger, props7);
};
var NextTrigger = (props7) => {
  return createComponent(carousel_exports.NextTrigger, props7);
};
var ItemGroup = (props7) => {
  return createComponent(carousel_exports.ItemGroup, props7);
};
var Item = (props7) => {
  return createComponent(carousel_exports.Item, props7);
};
var Carousel = {
  Root,
  Control,
  PrevTrigger,
  NextTrigger,
  ItemGroup,
  Item
};

// src/components/icons/ArrowLeftIcon.tsx
var _tmpl$12 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round><path d="m12 19-7-7 7-7"></path><path d="M19 12H5">`);
var ArrowLeftIcon = (props7) => (() => {
  var _el$ = _tmpl$12();
  spread(_el$, props7, true, true);
  return _el$;
})();

// src/components/icons/ArrowRightIcon.tsx
var _tmpl$13 = /* @__PURE__ */ template(`<svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round><path d="M5 12h14"></path><path d="m12 5 7 7-7 7">`);
var ArrowRightIcon = (props7) => (() => {
  var _el$ = _tmpl$13();
  spread(_el$, props7, true, true);
  return _el$;
})();

// src/features/blocks/inputs/cards/CardsCaroussel.tsx
var _tmpl$14 = /* @__PURE__ */ template(`<div class="flex w-full justify-end mb-2 pr-2">`);
var _tmpl$25 = /* @__PURE__ */ template(`<div class="flex flex-col gap-4"><div class="flex flex-col gap-2">`);
var _tmpl$34 = /* @__PURE__ */ template(`<div class="px-3 pb-2">`);
var _tmpl$44 = /* @__PURE__ */ template(`<img alt="Card image"class="aspect-[16/11] object-cover rounded-t-host-bubble rounded-b-none">`);
var _tmpl$52 = /* @__PURE__ */ template(`<h2 class="px-4 font-semibold">`);
var _tmpl$62 = /* @__PURE__ */ template(`<p class=px-4>`);
var _tmpl$72 = /* @__PURE__ */ template(`<div>`);
var CardsCaroussel = (props7) => {
  const onButtonClick = (itemIndex, pathIndex) => {
    props7.onSubmit({
      type: "text",
      value: props7.block.items[itemIndex].paths?.[pathIndex]?.id ?? "",
      label: props7.block.items[itemIndex].paths?.[pathIndex]?.text ?? "",
      attachments: props7.block.items[itemIndex].imageUrl ? [{
        url: props7.block.items[itemIndex].imageUrl,
        type: "image"
      }] : void 0
    });
  };
  const slidesPerPage = createMemo(() => computeSlidesPerPage(props7.block.items.length));
  return createComponent(Carousel.Root, {
    get slideCount() {
      return props7.block.items.length;
    },
    get slidesPerPage() {
      return slidesPerPage();
    },
    slidesPerMove: 1,
    spacing: "12px",
    "class": "w-[min(calc(var(--slides-per-page)*270px),100%)]",
    get style() {
      return {
        "margin-right": isMobile() ? "-13px" : "-21px"
      };
    },
    get children() {
      return [(() => {
        var _el$ = _tmpl$14();
        insert(_el$, createComponent(Carousel.Control, {
          "class": "flex gap-2",
          get children() {
            return [createComponent(Carousel.PrevTrigger, {
              asChild: (props8) => createComponent(Button, mergeProps({
                variant: "secondary"
              }, props8, {
                get children() {
                  return createComponent(ArrowLeftIcon, {
                    "class": "w-4 h-4"
                  });
                }
              }))
            }), createComponent(Carousel.NextTrigger, {
              asChild: (props8) => createComponent(Button, mergeProps({
                variant: "secondary"
              }, props8, {
                get children() {
                  return createComponent(ArrowRightIcon, {
                    "class": "w-4 h-4"
                  });
                }
              }))
            })];
          }
        }));
        createRenderEffect((_$p) => (_$p = props7.block.items.length > slidesPerPage() ? void 0 : "none") != null ? _el$.style.setProperty("display", _$p) : _el$.style.removeProperty("display"));
        return _el$;
      })(), createComponent(Carousel.ItemGroup, {
        "class": "rounded-host-bubble",
        get children() {
          return createComponent(Index, {
            get each() {
              return props7.block.items;
            },
            children: (item, index) => createComponent(Carousel.Item, {
              index,
              get children() {
                return createComponent(Card, {
                  "class": "h-full",
                  get children() {
                    return [(() => {
                      var _el$2 = _tmpl$25(), _el$3 = _el$2.firstChild;
                      insert(_el$2, createComponent(Show, {
                        get when() {
                          return item().imageUrl;
                        },
                        children: (imageUrl) => (() => {
                          var _el$5 = _tmpl$44();
                          createRenderEffect(() => setAttribute(_el$5, "src", imageUrl()));
                          return _el$5;
                        })()
                      }), _el$3);
                      insert(_el$3, createComponent(Show, {
                        get when() {
                          return item().title;
                        },
                        children: (title) => (() => {
                          var _el$6 = _tmpl$52();
                          insert(_el$6, title);
                          return _el$6;
                        })()
                      }), null);
                      insert(_el$3, createComponent(Show, {
                        get when() {
                          return item().description;
                        },
                        children: (description) => (() => {
                          var _el$7 = _tmpl$62();
                          insert(_el$7, description);
                          return _el$7;
                        })()
                      }), null);
                      createRenderEffect((_$p) => (_$p = item().imageUrl ? void 0 : "12px") != null ? _el$2.style.setProperty("padding-top", _$p) : _el$2.style.removeProperty("padding-top"));
                      return _el$2;
                    })(), (() => {
                      var _el$4 = _tmpl$34();
                      insert(_el$4, createComponent(For, {
                        get each() {
                          return item().paths;
                        },
                        children: (path, idx) => createComponent(Button, {
                          variant: "secondary",
                          get ["class"]() {
                            return cn("w-full font-normal text-sm border-host-bubble-border rounded-none", idx() === 0 && "rounded-t-host-bubble border border-b-0", idx() !== 0 && "border border-b-0", idx() === (item().paths?.length ?? 1) - 1 && "rounded-b-host-bubble border-b");
                          },
                          size: "sm",
                          "on:click": () => onButtonClick(index, idx()),
                          get children() {
                            return path.text;
                          }
                        })
                      }));
                      return _el$4;
                    })()];
                  }
                });
              }
            })
          });
        }
      })];
    }
  });
};
var Card = (props7) => {
  return (() => {
    var _el$8 = _tmpl$72();
    insert(_el$8, () => props7.children);
    createRenderEffect(() => className(_el$8, cn("typebot-card flex flex-col justify-between gap-4 text-host-bubble-text bg-host-bubble-bg border-host-bubble-border border-host-bubble rounded-host-bubble shadow-host-bubble filter-host-bubble", props7.class)));
    return _el$8;
  })();
};
var computeSlidesPerPage = (totalCards) => {
  if (isMobile()) {
    return totalCards > 1 ? 1.2 : 1;
  }
  if (isMediumContainer()) {
    return totalCards > 1 ? 1.5 : 1;
  }
  return totalCards > 2 ? 2.2 : totalCards;
};

// ../../blocks/inputs/src/date/constants.ts
var defaultDateInputOptions = {
  hasTime: false,
  isRange: false,
  labels: { button: defaultButtonLabel, from: "From:", to: "To:" },
  format: "dd/MM/yyyy",
  formatWithTime: "dd/MM/yyyy HH:mm"
};

// src/features/blocks/inputs/date/components/DateForm.tsx
var _tmpl$15 = /* @__PURE__ */ template(`<div class="typebot-input-form flex gap-2 items-end"><form><div class="flex flex-col"><div><input class="focus:outline-none flex-1 w-full text-input typebot-datetime-input"data-testid=from-date>`);
var _tmpl$26 = /* @__PURE__ */ template(`<p class=font-semibold>`);
var _tmpl$35 = /* @__PURE__ */ template(`<div class="flex items-center p-4"><input class="focus:outline-none flex-1 w-full text-input ml-2 typebot-datetime-input"data-testid=to-date>`);
var DateForm = (props7) => {
  const [inputValues, setInputValues] = createSignal(parseDefaultValue(props7.defaultValue ?? ""));
  const submit = () => {
    if (inputValues().from === "" && inputValues().to === "") return;
    props7.onSubmit({
      type: "text",
      value: `${inputValues().from}${props7.options?.isRange ? ` to ${inputValues().to}` : ""}`
    });
  };
  return (() => {
    var _el$ = _tmpl$15(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild;
    _el$2.addEventListener("submit", (e) => {
      e.preventDefault();
      submit();
    });
    insert(_el$4, (() => {
      var _c$ = createMemo(() => !!props7.options?.isRange);
      return () => _c$() && (() => {
        var _el$6 = _tmpl$26();
        insert(_el$6, () => props7.options.labels?.from ?? defaultDateInputOptions.labels.from);
        return _el$6;
      })();
    })(), _el$5);
    _el$5.addEventListener("change", (e) => setInputValues({
      ...inputValues(),
      from: e.currentTarget.value
    }));
    _el$5.style.setProperty("min-height", "32px");
    _el$5.style.setProperty("min-width", "100px");
    _el$5.style.setProperty("font-size", "16px");
    insert(_el$3, (() => {
      var _c$2 = createMemo(() => !!props7.options?.isRange);
      return () => _c$2() && (() => {
        var _el$7 = _tmpl$35(), _el$8 = _el$7.firstChild;
        insert(_el$7, (() => {
          var _c$3 = createMemo(() => !!props7.options.isRange);
          return () => _c$3() && (() => {
            var _el$9 = _tmpl$26();
            insert(_el$9, () => props7.options.labels?.to ?? defaultDateInputOptions.labels.to);
            return _el$9;
          })();
        })(), _el$8);
        _el$8.addEventListener("change", (e) => setInputValues({
          ...inputValues(),
          to: e.currentTarget.value
        }));
        _el$8.style.setProperty("min-height", "32px");
        _el$8.style.setProperty("min-width", "100px");
        _el$8.style.setProperty("font-size", "16px");
        createRenderEffect((_p$) => {
          var _v$6 = props7.options.hasTime ? "datetime-local" : "date", _v$7 = props7.options?.min, _v$8 = props7.options?.max;
          _v$6 !== _p$.e && setAttribute(_el$8, "type", _p$.e = _v$6);
          _v$7 !== _p$.t && setAttribute(_el$8, "min", _p$.t = _v$7);
          _v$8 !== _p$.a && setAttribute(_el$8, "max", _p$.a = _v$8);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0
        });
        createRenderEffect(() => _el$8.value = inputValues().to);
        return _el$7;
      })();
    })(), null);
    insert(_el$, createComponent(SendButton, {
      "class": "h-[56px]",
      "on:click": submit,
      get children() {
        return props7.options?.labels?.button;
      }
    }), null);
    createRenderEffect((_p$) => {
      var _v$ = cx("flex typebot-input", props7.options?.isRange ? "items-end" : "items-center"), _v$2 = "flex items-center p-4 " + (props7.options?.isRange ? "pb-0 gap-2" : ""), _v$3 = props7.options?.hasTime ? "datetime-local" : "date", _v$4 = props7.options?.min, _v$5 = props7.options?.max;
      _v$ !== _p$.e && className(_el$2, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$4, _p$.t = _v$2);
      _v$3 !== _p$.a && setAttribute(_el$5, "type", _p$.a = _v$3);
      _v$4 !== _p$.o && setAttribute(_el$5, "min", _p$.o = _v$4);
      _v$5 !== _p$.i && setAttribute(_el$5, "max", _p$.i = _v$5);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    });
    createRenderEffect(() => _el$5.value = inputValues().from);
    return _el$;
  })();
};
var parseDefaultValue = (defaultValue) => {
  if (!defaultValue.includes("to")) return {
    from: defaultValue,
    to: ""
  };
  const [from, to] = defaultValue.split(" to ");
  return {
    from,
    to
  };
};

// ../../../node_modules/@solid-primitives/input-mask/dist/index.js
var stringMaskRegExp = {
  9: /\d/,
  0: /\d?/,
  a: /[a-z]/i,
  o: /[a-z]?/i,
  "*": /\w/,
  "?": /\w?/
};
var stringMaskToArray = (mask, regexps = stringMaskRegExp) => [...mask].map((c) => regexps[c] || c);
var regexMaskToFn = (regex, replacer) => (value, selection) => [
  value.replace(regex, (...args) => {
    const replacement = replacer(...args);
    const index = args[args.length - 2];
    selection[0] += index < selection[0] ? 0 : (replacement.length - args[0].length) / args[0].length * Math.max(selection[0] - index, args[0].length);
    selection[1] += index < selection[1] ? 0 : (replacement.length - args[0].length) / args[0].length * Math.max(selection[1] - index, args[0].length);
    return replacement;
  }),
  selection
];
var maskArrayToFn = (maskArray) => (value, selection) => {
  let pos = 0;
  maskArray.forEach((maskItem) => {
    if (value.length >= pos + 1) {
      if (typeof maskItem === "string") {
        const index = value.slice(pos).indexOf(maskItem);
        if (index !== 0) {
          value = value.slice(0, pos) + maskItem + value.slice(pos);
          selection[0] += (selection[0] > pos) * maskItem.length;
          selection[1] += (selection[1] > pos) * maskItem.length;
        }
        pos += maskItem.length;
        return;
      }
      const match2 = value.slice(pos).match(maskItem);
      if (!match2 || match2.index === void 0) {
        value = value.slice(0, pos);
        return;
      } else if (match2.index > 0) {
        value = value.slice(0, pos) + value.slice(pos + match2.index);
        pos -= match2.index - 1;
        selection[0] -= (selection[0] > pos) * match2.index;
        selection[1] -= (selection[1] > pos) * match2.index;
      }
      pos += match2[0].length;
    }
  });
  return [value.slice(0, pos), selection];
};
var anyMaskToFn = (mask, regexps) => typeof mask === "function" ? mask : typeof mask[1] === "function" && mask[0] instanceof RegExp ? regexMaskToFn(mask[0], mask[1]) : maskArrayToFn(Array.isArray(mask) ? mask : stringMaskToArray(mask, regexps));
var createInputMask = (mask, regexps) => {
  const maskFn = anyMaskToFn(mask, regexps);
  const handler = (ev) => {
    const ref = ev.currentTarget || ev.target;
    const [value, selection] = maskFn(ref.value, [
      ref.selectionStart || ref.value.length,
      ref.selectionEnd || ref.value.length
    ]);
    ref.value = value;
    ref.setSelectionRange(...selection);
    return value;
  };
  return handler;
};
var createMaskPattern = (inputMask, pattern) => {
  const handler = (ev) => {
    const value = inputMask(ev);
    const ref = ev.currentTarget || ev.target;
    const prev = ref.previousElementSibling;
    const fn = value === "" ? "removeAttribute" : "setAttribute";
    prev[fn]("data-mask-value", value);
    prev[fn]("data-mask-pattern", pattern(value).slice(value.length));
    return value;
  };
  return handler;
};

// src/components/inputs/ShortTextInput.tsx
var _tmpl$16 = /* @__PURE__ */ template(`<input class="focus:outline-none bg-transparent px-4 py-2 flex-1 w-full text-input"type=text>`);
var ShortTextInput = (props7) => {
  const [local, others] = splitProps(props7, ["ref", "onInput"]);
  if (props7.type === "tel11") {
    return (() => {
      var _el$ = _tmpl$16();
      var _ref$ = props7.ref;
      typeof _ref$ === "function" ? use(_ref$, _el$) : props7.ref = _el$;
      spread(_el$, mergeProps({
        get onInput() {
          return createMaskPattern(createInputMask("(99) 99999-9999"), () => "(99) 99999-9999");
        }
      }, others), false, false);
      return _el$;
    })();
  }
  return (() => {
    var _el$2 = _tmpl$16();
    _el$2.$$input = (e) => local.onInput(e.currentTarget.value);
    var _ref$2 = props7.ref;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : props7.ref = _el$2;
    spread(_el$2, others, false, false);
    return _el$2;
  })();
};
delegateEvents(["input"]);

// ../../blocks/inputs/src/email/constants.ts
var defaultEmailInputOptions = {
  labels: {
    button: defaultButtonLabel,
    placeholder: "Type your email..."
  },
  retryMessageContent: "This email doesn't seem to be valid. Can you type it again?"
};

// src/features/blocks/inputs/email/components/EmailInput.tsx
var _tmpl$17 = /* @__PURE__ */ template(`<div class="typebot-input-form flex w-full gap-2 items-end max-w-[350px]"><div class="flex typebot-input w-full">`);
var EmailInput = (props7) => {
  const [inputValue, setInputValue2] = createSignal(props7.defaultValue ?? "");
  let inputRef;
  const handleInput = (inputValue2) => setInputValue2(inputValue2);
  const checkIfInputIsValid = () => inputRef?.value !== "" && inputRef?.reportValidity();
  const submit = () => {
    if (checkIfInputIsValid()) props7.onSubmit({
      type: "text",
      value: inputRef?.value ?? inputValue()
    });
    else inputRef?.focus();
  };
  const submitWhenEnter = (e) => {
    if (e.key === "Enter") submit();
  };
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
    window.addEventListener("message", processIncomingEvent);
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot) return;
    if (data.command === "setInputValue") setInputValue2(data.value);
  };
  return (() => {
    var _el$ = _tmpl$17(), _el$2 = _el$.firstChild;
    _el$.$$keydown = submitWhenEnter;
    insert(_el$2, createComponent(ShortTextInput, {
      ref(r$) {
        var _ref$ = inputRef;
        typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
      },
      get value() {
        return inputValue();
      },
      get placeholder() {
        return props7.block.options?.labels?.placeholder ?? defaultEmailInputOptions.labels.placeholder;
      },
      onInput: handleInput,
      type: "email",
      autocomplete: "email"
    }));
    insert(_el$, createComponent(SendButton, {
      type: "button",
      "class": "h-[56px]",
      "on:click": submit,
      get children() {
        return props7.block.options?.labels?.button;
      }
    }), null);
    return _el$;
  })();
};
delegateEvents(["keydown"]);

// ../../blocks/inputs/src/file/constants.ts
var defaultFileInputOptions = {
  isRequired: true,
  isMultipleAllowed: false,
  visibility: "Auto",
  labels: {
    placeholder: `<strong>
      Click to upload
    </strong> or drag and drop<br>
    (size limit: 10MB)`,
    button: "Upload",
    clear: "Clear",
    skip: "Skip",
    success: {
      single: "File uploaded",
      multiple: "{total} files uploaded"
    }
  }
};

// src/features/blocks/inputs/fileUpload/helpers/sanitizeSelectedFiles.ts
var sanitizeNewFile = ({
  newFile,
  existingFiles,
  params,
  context,
  onError
}) => {
  const sizeLimit = params.sizeLimit ?? getRuntimeVariable("NEXT_PUBLIC_BOT_FILE_UPLOAD_MAX_SIZE");
  if (sizeLimit && newFile.size > Number(sizeLimit) * 1024 * 1024) {
    onError({
      description: (context.typebot.settings.general?.systemMessages?.fileUploadSizeError ?? defaultSystemMessages.fileUploadSizeError).replace("[[file]]", newFile.name).replace("[[limit]]", sizeLimit)
    });
    return;
  }
  if (existingFiles.length === 0) return newFile;
  let fileName = newFile.name;
  let counter2 = 1;
  while (existingFiles.some((file) => file.name === fileName)) {
    const dotIndex = newFile.name.lastIndexOf(".");
    const extension = dotIndex !== -1 ? newFile.name.slice(dotIndex) : "";
    fileName = `${newFile.name.slice(0, dotIndex)}(${counter2})${extension}`;
    counter2++;
  }
  return new File([newFile], fileName, { type: newFile.type });
};

// src/features/blocks/inputs/fileUpload/helpers/uploadFiles.ts
var uploadFiles2 = async ({
  apiHost,
  files,
  onUploadProgress
}) => {
  const urls = [];
  let i = 0;
  for (const { input, file } of files) {
    onUploadProgress && onUploadProgress({ progress: i / files.length * 100, fileIndex: i });
    i += 1;
    const { data } = await sendRequest({
      method: "POST",
      url: `${apiHost}/api/v3/generate-upload-url`,
      body: {
        fileName: input.fileName,
        sessionId: input.sessionId,
        fileType: file.type,
        blockId: input.blockId
      }
    });
    if (!data?.presignedUrl) continue;
    else {
      const formData = new FormData();
      Object.entries(data.formData).forEach(([key, value]) => {
        formData.append(key, value);
      });
      formData.append("file", file);
      const upload = await fetch(data.presignedUrl, {
        method: "POST",
        body: formData
      });
      if (!upload.ok) continue;
      urls.push({ url: data.fileUrl, type: file.type });
    }
  }
  return urls;
};

// src/components/icons/FileIcon.tsx
var _tmpl$18 = /* @__PURE__ */ template(`<svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2px stroke-linecap=round stroke-linejoin=round><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"></path><path d="M14 2v4a2 2 0 0 0 2 2h4">`);
var FileIcon = (props7) => (() => {
  var _el$ = _tmpl$18();
  spread(_el$, props7, true, true);
  return _el$;
})();

// src/features/blocks/inputs/fileUpload/components/FilePreview.tsx
var _tmpl$19 = /* @__PURE__ */ template(`<div class="flex items-center gap-4 border bg-white border-gray-200 rounded-md p-2 text-gray-900 min-w-[250px]"><div></div><div class="flex flex-col"><span class="text-md font-semibold text-sm"></span><span class="text-gray-500 text-xs">`);
var FilePreview = (props7) => {
  const fileColor = getFileAssociatedColor(props7.file);
  return (() => {
    var _el$ = _tmpl$19(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling;
    insert(_el$2, createComponent(FileIcon, {
      "class": "w-6 h-6"
    }));
    insert(_el$4, () => props7.file.name);
    insert(_el$5, () => formatFileExtensionHumanReadable(props7.file));
    createRenderEffect(() => className(_el$2, cx("rounded-md text-white p-2 flex items-center", fileColor === "pink" && "bg-pink-400", fileColor === "blue" && "bg-blue-400", fileColor === "green" && "bg-green-400", fileColor === "gray" && "bg-gray-400", fileColor === "orange" && "bg-orange-400")));
    return _el$;
  })();
};
var formatFileExtensionHumanReadable = (file) => {
  const extension = file.name.split(".").pop();
  switch (extension) {
    case "pdf":
      return "PDF";
    case "doc":
    case "docx":
      return "Word";
    case "xls":
    case "xlsx":
    case "csv":
      return "Sheet";
    case "json":
      return "JSON";
    case "md":
      return "Markdown";
    default:
      return "DOCUMENT";
  }
};
var getFileAssociatedColor = (file) => {
  const extension = file.name.split(".").pop();
  if (!extension) return "gray";
  switch (extension) {
    case "pdf":
      return "pink";
    case "doc":
    case "docx":
      return "blue";
    case "xls":
    case "xlsx":
    case "csv":
      return "green";
    case "json":
      return "orange";
    default:
      return "gray";
  }
};

// src/features/blocks/inputs/fileUpload/components/SelectedFile.tsx
var _tmpl$20 = /* @__PURE__ */ template(`<img class="rounded-md object-cover w-[58px] h-[58px]">`);
var _tmpl$27 = /* @__PURE__ */ template(`<div class="relative group flex-shrink-0"><button class="absolute -right-2 p-0.5 -top-2 rounded-full bg-gray-200 text-black border border-gray-400 opacity-1 sm:opacity-0 group-hover:opacity-100 transition-opacity"aria-label="Remove attachment">`);
var _tmpl$36 = /* @__PURE__ */ template(`<div class="absolute w-full h-full inset-0 bg-black/20 rounded-md">`);
var SelectedFile = (props7) => {
  return (() => {
    var _el$ = _tmpl$27(), _el$3 = _el$.firstChild;
    insert(_el$, createComponent(Switch, {
      get children() {
        return [createComponent(Match, {
          get when() {
            return props7.file.type.startsWith("image");
          },
          get children() {
            var _el$2 = _tmpl$20();
            createRenderEffect((_p$) => {
              var _v$ = URL.createObjectURL(props7.file), _v$2 = props7.file.name;
              _v$ !== _p$.e && setAttribute(_el$2, "src", _p$.e = _v$);
              _v$2 !== _p$.t && setAttribute(_el$2, "alt", _p$.t = _v$2);
              return _p$;
            }, {
              e: void 0,
              t: void 0
            });
            return _el$2;
          }
        }), createComponent(Match, {
          when: true,
          get children() {
            return createComponent(FilePreview, {
              get file() {
                return props7.file;
              }
            });
          }
        })];
      }
    }), _el$3);
    addEventListener(_el$3, "click", props7.onRemoveClick);
    insert(_el$3, createComponent(CloseIcon, {
      "class": "w-4"
    }));
    insert(_el$, createComponent(Show, {
      get when() {
        return isDefined(props7.uploadProgressPercent) && props7.uploadProgressPercent !== 100;
      },
      get children() {
        return createComponent(UploadOverlay, {
          get progressPercent() {
            return props7.uploadProgressPercent;
          }
        });
      }
    }), null);
    return _el$;
  })();
};
var UploadOverlay = (props7) => {
  const [progressPercent, setProgressPercent] = createSignal(props7.progressPercent ?? 0);
  let interval;
  createEffect(() => {
    if (props7.progressPercent === 20) {
      const incrementProgress = () => {
        if (progressPercent() < 100) {
          setProgressPercent((prev) => prev + (Math.floor(Math.random() * 10) + 1));
        }
      };
      interval = setInterval(incrementProgress, 1e3);
    }
  });
  onCleanup(() => {
    clearInterval(interval);
  });
  return (() => {
    var _el$4 = _tmpl$36();
    insert(_el$4, createComponent(progress_exports.Root, {
      get value() {
        return progressPercent();
      },
      "class": "flex items-center justify-center",
      get children() {
        return createComponent(progress_exports.Circle, {
          get children() {
            return [createComponent(progress_exports.CircleTrack, {}), createComponent(progress_exports.CircleRange, {})];
          }
        });
      }
    }));
    return _el$4;
  })();
};

// src/features/blocks/inputs/fileUpload/components/FileUploadForm.tsx
var _tmpl$21 = /* @__PURE__ */ template(`<div class="w-full bg-gray-200 rounded-full h-2.5"><div class="upload-progress-bar h-2.5 rounded-full">`);
var _tmpl$28 = /* @__PURE__ */ template(`<div class="p-4 flex gap-2 border-gray-200 border overflow-auto bg-white rounded-md w-full">`);
var _tmpl$37 = /* @__PURE__ */ template(`<div class="flex flex-col justify-center items-center gap-4 max-w-[90%]"><p class="text-sm text-gray-500 text-center">`);
var _tmpl$45 = /* @__PURE__ */ template(`<input id=dropzone-file type=file class=hidden>`);
var _tmpl$53 = /* @__PURE__ */ template(`<div class="flex justify-end">`);
var _tmpl$63 = /* @__PURE__ */ template(`<div class="flex justify-end"><div class="flex gap-2">`);
var _tmpl$73 = /* @__PURE__ */ template(`<form class="flex flex-col w-full gap-2"><label for=dropzone-file>`);
var _tmpl$82 = /* @__PURE__ */ template(`<svg xmlns=http://www.w3.org/2000/svg width=24 height=24 viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round class=text-gray-500><polyline points="16 16 12 12 8 16"></polyline><line x1=12 y1=12 x2=12 y2=21></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16">`);
var FileUploadForm = (props7) => {
  const [selectedFiles, setSelectedFiles] = createSignal([]);
  const [isUploading, setIsUploading] = createSignal(false);
  const [uploadProgressPercent, setUploadProgressPercent] = createSignal(0);
  const [isDraggingOver, setIsDraggingOver] = createSignal(false);
  const fileUploadErrorMessage = props7.context.typebot.settings.general?.systemMessages?.fileUploadError ?? defaultSystemMessages.fileUploadError;
  const onNewFiles = (files) => {
    const newFiles = Array.from(files).map((file) => sanitizeNewFile({
      existingFiles: selectedFiles(),
      newFile: file,
      params: {
        sizeLimit: props7.block.options && "sizeLimit" in props7.block.options ? props7.block.options.sizeLimit : void 0
      },
      context: props7.context,
      onError: ({
        description
      }) => toaster.create({
        description
      })
    })).filter(isDefined);
    if (newFiles.length === 0) return;
    if (!props7.block.options?.isMultipleAllowed) return startSingleFileUpload(newFiles[0]);
    setSelectedFiles([...selectedFiles(), ...newFiles]);
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (selectedFiles().length === 0) return;
    startFilesUpload(selectedFiles());
  };
  const startSingleFileUpload = async (file) => {
    setIsUploading(true);
    const urls = await uploadFiles2({
      apiHost: props7.context.apiHost ?? guessApiHost({
        ignoreChatApiUrl: true
      }),
      files: [{
        file,
        input: {
          sessionId: props7.context.sessionId,
          blockId: props7.block.id,
          fileName: file.name
        }
      }]
    });
    setIsUploading(false);
    if (urls.length && urls[0]) return props7.onSubmit({
      type: "text",
      label: props7.block.options?.labels?.success?.single ?? defaultFileInputOptions.labels.success.single,
      value: urls[0] ? encodeUrl(urls[0].url) : "",
      attachments: [{
        type: file.type,
        url: urls[0].url,
        blobUrl: URL.createObjectURL(file)
      }]
    });
    toaster.create({
      description: fileUploadErrorMessage
    });
  };
  const startFilesUpload = async (files) => {
    setIsUploading(true);
    const urls = await uploadFiles2({
      apiHost: props7.context.apiHost ?? guessApiHost({
        ignoreChatApiUrl: true
      }),
      files: files.map((file) => ({
        file,
        input: {
          sessionId: props7.context.sessionId,
          blockId: props7.block.id,
          fileName: file.name
        }
      })),
      onUploadProgress: setUploadProgressPercent
    });
    setIsUploading(false);
    setUploadProgressPercent(0);
    if (urls.length !== files.length) return toaster.create({
      description: fileUploadErrorMessage
    });
    props7.onSubmit({
      type: "text",
      label: urls.length > 1 ? (props7.block.options?.labels?.success?.multiple ?? defaultFileInputOptions.labels.success.multiple).replaceAll("{total}", urls.length.toString()) : props7.block.options?.labels?.success?.single ?? defaultFileInputOptions.labels.success.single,
      value: urls.filter(isDefined).map(({
        url
      }) => encodeUrl(url)).join(", "),
      attachments: urls.map((urls2, index) => urls2 ? {
        ...urls2,
        blobUrl: URL.createObjectURL(selectedFiles()[index])
      } : null).filter(isDefined)
    });
  };
  const handleDragOver = (e) => {
    e.preventDefault();
    setIsDraggingOver(true);
  };
  const handleDragLeave = () => setIsDraggingOver(false);
  const handleDropFile = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!e.dataTransfer?.files) return;
    onNewFiles(e.dataTransfer.files);
  };
  const clearFiles = () => setSelectedFiles([]);
  const skip = () => props7.onSkip(props7.block.options?.labels?.skip ?? defaultFileInputOptions.labels.skip);
  const removeSelectedFile = (index) => {
    setSelectedFiles((selectedFiles2) => selectedFiles2.filter((_, i) => i !== index));
  };
  return (() => {
    var _el$ = _tmpl$73(), _el$2 = _el$.firstChild;
    _el$.addEventListener("submit", handleSubmit);
    _el$2.addEventListener("drop", handleDropFile);
    _el$2.addEventListener("dragleave", handleDragLeave);
    _el$2.addEventListener("dragover", handleDragOver);
    insert(_el$2, createComponent(Switch, {
      get children() {
        return [createComponent(Match, {
          get when() {
            return isUploading();
          },
          get children() {
            return createComponent(Show, {
              get when() {
                return selectedFiles().length > 1;
              },
              get fallback() {
                return createComponent(Spinner, {});
              },
              get children() {
                var _el$3 = _tmpl$21(), _el$4 = _el$3.firstChild;
                _el$4.style.setProperty("transition", "width 150ms cubic-bezier(0.4, 0, 0.2, 1)");
                createRenderEffect((_$p) => (_$p = `${uploadProgressPercent() > 0 ? uploadProgressPercent : 10}%`) != null ? _el$4.style.setProperty("width", _$p) : _el$4.style.removeProperty("width"));
                return _el$3;
              }
            });
          }
        }), createComponent(Match, {
          get when() {
            return !isUploading();
          },
          get children() {
            return [(() => {
              var _el$5 = _tmpl$37(), _el$7 = _el$5.firstChild;
              insert(_el$5, createComponent(Show, {
                get when() {
                  return selectedFiles().length;
                },
                get fallback() {
                  return createComponent(UploadIcon, {});
                },
                get children() {
                  var _el$6 = _tmpl$28();
                  addEventListener(_el$6, "click", (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                  });
                  insert(_el$6, createComponent(For, {
                    get each() {
                      return selectedFiles();
                    },
                    children: (file, index) => createComponent(SelectedFile, {
                      file,
                      onRemoveClick: () => removeSelectedFile(index())
                    })
                  }));
                  return _el$6;
                }
              }), _el$7);
              createRenderEffect(() => _el$7.innerHTML = props7.block.options?.labels?.placeholder ?? defaultFileInputOptions.labels.placeholder);
              return _el$5;
            })(), (() => {
              var _el$8 = _tmpl$45();
              _el$8.addEventListener("change", (e) => {
                if (!e.currentTarget.files) return;
                onNewFiles(e.currentTarget.files);
              });
              createRenderEffect((_p$) => {
                var _v$ = props7.block.options?.allowedFileTypes?.isEnabled ? props7.block.options?.allowedFileTypes?.types?.join(", ") : void 0, _v$2 = props7.block.options?.isMultipleAllowed ?? defaultFileInputOptions.isMultipleAllowed;
                _v$ !== _p$.e && setAttribute(_el$8, "accept", _p$.e = _v$);
                _v$2 !== _p$.t && (_el$8.multiple = _p$.t = _v$2);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$8;
            })()];
          }
        })];
      }
    }));
    insert(_el$, createComponent(Show, {
      get when() {
        return selectedFiles().length === 0 && props7.block.options?.isRequired === false;
      },
      get children() {
        var _el$9 = _tmpl$53();
        insert(_el$9, createComponent(Button, {
          "on:click": skip,
          get children() {
            return props7.block.options?.labels?.skip ?? defaultFileInputOptions.labels.skip;
          }
        }));
        return _el$9;
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return createMemo(() => !!(props7.block.options?.isMultipleAllowed && selectedFiles().length > 0))() && !isUploading();
      },
      get children() {
        var _el$10 = _tmpl$63(), _el$11 = _el$10.firstChild;
        insert(_el$11, createComponent(Show, {
          get when() {
            return selectedFiles().length;
          },
          get children() {
            return createComponent(Button, {
              variant: "secondary",
              "on:click": clearFiles,
              get children() {
                return props7.block.options?.labels?.clear ?? defaultFileInputOptions.labels.clear;
              }
            });
          }
        }), null);
        insert(_el$11, createComponent(SendButton, {
          type: "submit",
          disableIcon: true,
          get children() {
            return createMemo(() => (props7.block.options?.labels?.button ?? defaultFileInputOptions.labels.button) === defaultFileInputOptions.labels.button)() ? `Upload ${selectedFiles().length} file${selectedFiles().length > 1 ? "s" : ""}` : props7.block.options?.labels?.button;
          }
        }), null);
        return _el$10;
      }
    }), null);
    createRenderEffect(() => className(_el$2, "typebot-upload-input py-6 flex flex-col justify-center items-center w-full bg-gray-50 border-2 border-gray-300 border-dashed cursor-pointer hover:bg-gray-100 px-8 " + (isDraggingOver() ? "dragging-over" : "")));
    return _el$;
  })();
};
var UploadIcon = () => _tmpl$82();
var encodeUrl = (url) => {
  const fileName = url.split("/").pop();
  if (!fileName) return url;
  const encodedFileName = encodeURIComponent(fileName);
  return url.replace(fileName, encodedFileName);
};

// src/components/icons/ChevronDownIcon.tsx
var _tmpl$29 = /* @__PURE__ */ template(`<svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2px stroke-linecap=round stroke-linejoin=round><polyline points="6 9 12 15 18 9">`);
var ChevronDownIcon = (props7) => (() => {
  var _el$ = _tmpl$29();
  spread(_el$, props7, true, true);
  return _el$;
})();

// src/components/icons/ChevronUpIcon.tsx
var _tmpl$30 = /* @__PURE__ */ template(`<svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round><path d="M18 15l-6-6-6 6">`);
var ChevronUpIcon = (props7) => (() => {
  var _el$ = _tmpl$30();
  spread(_el$, props7, true, true);
  return _el$;
})();

// ../../blocks/inputs/src/number/constants.ts
var defaultNumberInputStyle = "decimal" /* DECIMAL */;
var defaultNumberInputButtonLabel = defaultButtonLabel;
var defaultNumberInputPlaceholder = "Type a number...";

// ../../lib/src/safeParseFloat.ts
var safeParseFloat = (value) => {
  if (typeof value === "number") return value;
  if (!value) return void 0;
  const parsedValue = Number.parseFloat(value.toString().replace(",", "."));
  return isNaN(parsedValue) ? void 0 : parsedValue;
};

// src/features/blocks/inputs/number/components/NumberInput.tsx
var _tmpl$31 = /* @__PURE__ */ template(`<div class="typebot-input-form flex w-full gap-2 items-end max-w-[350px]">`);
var NumberInput = (props7) => {
  const numberInput = useNumberInput({
    locale: props7.block.options?.locale,
    formatOptions: parseFormatOptions(props7.block.options),
    min: safeParseFloat(props7.block.options?.min),
    max: safeParseFloat(props7.block.options?.max),
    step: safeParseFloat(props7.block.options?.step)
  });
  let inputRef;
  const isInputValid = () => {
    if (numberInput().invalid) {
      inputRef?.reportValidity();
      return false;
    }
    return true;
  };
  const submit = () => {
    if (isInputValid()) {
      props7.onSubmit({
        type: "text",
        value: numberInput().valueAsNumber.toString(),
        label: numberInput().value.toString()
      });
    } else numberInput().focus();
  };
  const submitWhenEnter = (e) => {
    if (e.key === "Enter") submit();
  };
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
    window.addEventListener("message", processIncomingEvent);
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot) return;
    if (data.command === "setInputValue") numberInput().setValue(Number(data.value));
  };
  return (() => {
    var _el$ = _tmpl$31();
    _el$.$$keydown = submitWhenEnter;
    insert(_el$, createComponent(number_input_exports.RootProvider, {
      value: numberInput,
      "class": "flex typebot-input w-full",
      get children() {
        return [createComponent(number_input_exports.Input, {
          ref(r$) {
            var _ref$ = inputRef;
            typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
          },
          "class": "focus:outline-none bg-transparent px-4 py-4 flex-1 w-full text-input",
          style: {
            "font-size": "16px",
            appearance: "auto"
          },
          get placeholder() {
            return props7.block.options?.labels?.placeholder ?? defaultNumberInputPlaceholder;
          }
        }), createComponent(number_input_exports.Control, {
          "class": "flex flex-col rounded-r-md overflow-hidden divide-y h-[56px]",
          get children() {
            return [createComponent(number_input_exports.IncrementTrigger, {
              "class": "flex items-center justify-center h-7 w-8 border-input-border border-l",
              get children() {
                return createComponent(ChevronUpIcon, {
                  "class": "size-4"
                });
              }
            }), createComponent(number_input_exports.DecrementTrigger, {
              "class": "flex items-center justify-center h-7 w-8 border-input-border border-l",
              get children() {
                return createComponent(ChevronDownIcon, {
                  "class": "size-4"
                });
              }
            })];
          }
        })];
      }
    }), null);
    insert(_el$, createComponent(SendButton, {
      type: "button",
      "on:click": submit,
      get children() {
        return props7.block.options?.labels?.button ?? defaultNumberInputButtonLabel;
      }
    }), null);
    return _el$;
  })();
};
var parseFormatOptions = (options2) => {
  const defaultFormat = {
    style: defaultNumberInputStyle
  };
  if (options2?.style === "currency" /* CURRENCY */ && options2.currency) return {
    style: options2.style,
    currency: options2.currency
  };
  if (options2?.style === "unit" /* UNIT */ && options2.unit) return {
    style: options2.style,
    unit: options2.unit
  };
  return defaultFormat;
};
delegateEvents(["keydown"]);

// src/features/blocks/inputs/payment/components/StripePaymentForm.tsx
var import_pure = __toESM(require_pure2(), 1);

// ../../blocks/inputs/src/payment/constants.ts
var defaultPaymentInputOptions = {
  provider: "Stripe" /* STRIPE */,
  labels: { button: "Pay", success: "Success" },
  retryMessageContent: "Payment failed. Please, try again.",
  currency: "USD"
};

// src/features/blocks/inputs/payment/components/StripePaymentForm.tsx
var _tmpl$38 = /* @__PURE__ */ template(`<div class="typebot-input-error-message mt-4 text-center animate-fade-in">`);
var _tmpl$210 = /* @__PURE__ */ template(`<form id=payment-form class="flex flex-col p-4 typebot-input w-full items-center"><slot name=stripe-payment-form>`);
var slotName = "stripe-payment-form";
var paymentElementSlot;
var stripe = null;
var elements = null;
var StripePaymentForm = (props7) => {
  const [message, setMessage] = createSignal();
  const [isMounted, setIsMounted] = createSignal(false);
  const [isLoading, setIsLoading] = createSignal(false);
  onMount(async () => {
    if (!paymentElementSlot) return;
    initShadowMountPoint(paymentElementSlot);
    if (!props7.options?.publicKey) return setMessage("Missing Stripe public key");
    stripe = await (0, import_pure.loadStripe)(props7.options?.publicKey);
    if (!stripe) return;
    elements = stripe.elements({
      appearance: {
        theme: "stripe",
        variables: {
          colorPrimary: getComputedStyle(paymentElementSlot).getPropertyValue("--typebot-button-bg-color")
        }
      },
      clientSecret: props7.options.paymentIntentSecret
    });
    const paymentElement = elements.create("payment", {
      layout: "tabs"
    });
    paymentElement.mount("#payment-element");
    setTimeout(() => {
      setIsMounted(true);
      props7.onTransitionEnd();
    }, 1e3);
  });
  const handleSubmit = async (event) => {
    event.preventDefault();
    if (!stripe || !elements) return;
    setIsLoading(true);
    setPaymentInProgressInStorage({
      sessionId: props7.context.sessionId,
      resultId: props7.context.resultId,
      typebot: props7.context.typebot
    });
    const {
      postalCode,
      ...address
    } = props7.options?.additionalInformation?.address ?? {};
    const {
      error,
      paymentIntent
    } = await stripe.confirmPayment({
      elements,
      confirmParams: {
        return_url: window.location.href,
        payment_method_data: {
          billing_details: {
            name: props7.options?.additionalInformation?.name,
            email: props7.options?.additionalInformation?.email,
            phone: props7.options?.additionalInformation?.phoneNumber,
            address: {
              ...address,
              postal_code: postalCode
            }
          }
        }
      },
      redirect: "if_required"
    });
    removePaymentInProgressFromStorage();
    setIsLoading(false);
    if (error?.type === "validation_error") return;
    if (error?.type === "card_error") return setMessage(error.message);
    if (!error && paymentIntent.status === "succeeded") return props7.onSuccess();
  };
  return (() => {
    var _el$ = _tmpl$210(), _el$2 = _el$.firstChild;
    _el$.addEventListener("submit", handleSubmit);
    var _ref$ = paymentElementSlot;
    typeof _ref$ === "function" ? use(_ref$, _el$2) : paymentElementSlot = _el$2;
    _el$2._$owner = getOwner();
    insert(_el$, createComponent(Show, {
      get when() {
        return isMounted();
      },
      get children() {
        return createComponent(SendButton, {
          get isLoading() {
            return isLoading();
          },
          "class": "mt-4 w-full max-w-lg animate-fade-in",
          disableIcon: true,
          get children() {
            return [createMemo(() => props7.options?.labels?.button ?? defaultPaymentInputOptions.labels.button), " ", createMemo(() => props7.options?.amountLabel)];
          }
        });
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return message();
      },
      get children() {
        var _el$3 = _tmpl$38();
        insert(_el$3, message);
        return _el$3;
      }
    }), null);
    return _el$;
  })();
};
var initShadowMountPoint = (element) => {
  const rootNode = element.getRootNode();
  const host = rootNode.host;
  const slotPlaceholder = document.createElement("div");
  slotPlaceholder.style.width = "100%";
  slotPlaceholder.slot = slotName;
  host.appendChild(slotPlaceholder);
  const paymentElementContainer = document.createElement("div");
  paymentElementContainer.id = "payment-element";
  slotPlaceholder.appendChild(paymentElementContainer);
};

// src/features/blocks/inputs/payment/components/PaymentForm.tsx
var PaymentForm = (props7) => createComponent(StripePaymentForm, {
  get onSuccess() {
    return props7.onSuccess;
  },
  get options() {
    return props7.options;
  },
  get context() {
    return props7.context;
  },
  get onTransitionEnd() {
    return props7.onTransitionEnd;
  }
});

// ../../blocks/inputs/src/phone/constants.ts
var defaultPhoneInputOptions = {
  labels: {
    button: defaultButtonLabel,
    placeholder: "Type your phone number..."
  },
  retryMessageContent: "This phone number doesn't seem to be valid. Can you type it again?"
};

// ../../lib/src/phoneCountries.ts
var phoneCountries = [
  {
    name: "International",
    flag: "\u{1F310}",
    code: "INT",
    dial_code: ""
  },
  {
    name: "Afghanistan",
    flag: "\u{1F1E6}\u{1F1EB}",
    code: "AF",
    dial_code: "+93"
  },
  {
    name: "\xC5land Islands",
    flag: "\u{1F1E6}\u{1F1FD}",
    code: "AX",
    dial_code: "+358"
  },
  {
    name: "Albania",
    flag: "\u{1F1E6}\u{1F1F1}",
    code: "AL",
    dial_code: "+355"
  },
  {
    name: "Algeria",
    flag: "\u{1F1E9}\u{1F1FF}",
    code: "DZ",
    dial_code: "+213"
  },
  {
    name: "American Samoa",
    flag: "\u{1F1E6}\u{1F1F8}",
    code: "AS",
    dial_code: "+1684"
  },
  {
    name: "Andorra",
    flag: "\u{1F1E6}\u{1F1E9}",
    code: "AD",
    dial_code: "+376"
  },
  {
    name: "Angola",
    flag: "\u{1F1E6}\u{1F1F4}",
    code: "AO",
    dial_code: "+244"
  },
  {
    name: "Anguilla",
    flag: "\u{1F1E6}\u{1F1EE}",
    code: "AI",
    dial_code: "+1264"
  },
  {
    name: "Antarctica",
    flag: "\u{1F1E6}\u{1F1F6}",
    code: "AQ",
    dial_code: "+672"
  },
  {
    name: "Antigua and Barbuda",
    flag: "\u{1F1E6}\u{1F1EC}",
    code: "AG",
    dial_code: "+1268"
  },
  {
    name: "Argentina",
    flag: "\u{1F1E6}\u{1F1F7}",
    code: "AR",
    dial_code: "+54"
  },
  {
    name: "Armenia",
    flag: "\u{1F1E6}\u{1F1F2}",
    code: "AM",
    dial_code: "+374"
  },
  {
    name: "Aruba",
    flag: "\u{1F1E6}\u{1F1FC}",
    code: "AW",
    dial_code: "+297"
  },
  {
    name: "Australia",
    flag: "\u{1F1E6}\u{1F1FA}",
    code: "AU",
    dial_code: "+61"
  },
  {
    name: "Austria",
    flag: "\u{1F1E6}\u{1F1F9}",
    code: "AT",
    dial_code: "+43"
  },
  {
    name: "Azerbaijan",
    flag: "\u{1F1E6}\u{1F1FF}",
    code: "AZ",
    dial_code: "+994"
  },
  {
    name: "Bahamas",
    flag: "\u{1F1E7}\u{1F1F8}",
    code: "BS",
    dial_code: "+1242"
  },
  {
    name: "Bahrain",
    flag: "\u{1F1E7}\u{1F1ED}",
    code: "BH",
    dial_code: "+973"
  },
  {
    name: "Bangladesh",
    flag: "\u{1F1E7}\u{1F1E9}",
    code: "BD",
    dial_code: "+880"
  },
  {
    name: "Barbados",
    flag: "\u{1F1E7}\u{1F1E7}",
    code: "BB",
    dial_code: "+1246"
  },
  {
    name: "Belarus",
    flag: "\u{1F1E7}\u{1F1FE}",
    code: "BY",
    dial_code: "+375"
  },
  {
    name: "Belgium",
    flag: "\u{1F1E7}\u{1F1EA}",
    code: "BE",
    dial_code: "+32"
  },
  {
    name: "Belize",
    flag: "\u{1F1E7}\u{1F1FF}",
    code: "BZ",
    dial_code: "+501"
  },
  {
    name: "Benin",
    flag: "\u{1F1E7}\u{1F1EF}",
    code: "BJ",
    dial_code: "+229"
  },
  {
    name: "Bermuda",
    flag: "\u{1F1E7}\u{1F1F2}",
    code: "BM",
    dial_code: "+1441"
  },
  {
    name: "Bhutan",
    flag: "\u{1F1E7}\u{1F1F9}",
    code: "BT",
    dial_code: "+975"
  },
  {
    name: "Bolivia, Plurinational State of bolivia",
    flag: "\u{1F1E7}\u{1F1F4}",
    code: "BO",
    dial_code: "+591"
  },
  {
    name: "Bosnia and Herzegovina",
    flag: "\u{1F1E7}\u{1F1E6}",
    code: "BA",
    dial_code: "+387"
  },
  {
    name: "Botswana",
    flag: "\u{1F1E7}\u{1F1FC}",
    code: "BW",
    dial_code: "+267"
  },
  {
    name: "Bouvet Island",
    flag: "\u{1F1E7}\u{1F1FB}",
    code: "BV",
    dial_code: "+47"
  },
  {
    name: "Brazil",
    flag: "\u{1F1E7}\u{1F1F7}",
    code: "BR",
    dial_code: "+55"
  },
  {
    name: "British Indian Ocean Territory",
    flag: "\u{1F1EE}\u{1F1F4}",
    code: "IO",
    dial_code: "+246"
  },
  {
    name: "Brunei Darussalam",
    flag: "\u{1F1E7}\u{1F1F3}",
    code: "BN",
    dial_code: "+673"
  },
  {
    name: "Bulgaria",
    flag: "\u{1F1E7}\u{1F1EC}",
    code: "BG",
    dial_code: "+359"
  },
  {
    name: "Burkina Faso",
    flag: "\u{1F1E7}\u{1F1EB}",
    code: "BF",
    dial_code: "+226"
  },
  {
    name: "Burundi",
    flag: "\u{1F1E7}\u{1F1EE}",
    code: "BI",
    dial_code: "+257"
  },
  {
    name: "Cambodia",
    flag: "\u{1F1F0}\u{1F1ED}",
    code: "KH",
    dial_code: "+855"
  },
  {
    name: "Cameroon",
    flag: "\u{1F1E8}\u{1F1F2}",
    code: "CM",
    dial_code: "+237"
  },
  {
    name: "Canada",
    flag: "\u{1F1E8}\u{1F1E6}",
    code: "CA",
    dial_code: "+1"
  },
  {
    name: "Cape Verde",
    flag: "\u{1F1E8}\u{1F1FB}",
    code: "CV",
    dial_code: "+238"
  },
  {
    name: "Cayman Islands",
    flag: "\u{1F1F0}\u{1F1FE}",
    code: "KY",
    dial_code: "+345"
  },
  {
    name: "Central African Republic",
    flag: "\u{1F1E8}\u{1F1EB}",
    code: "CF",
    dial_code: "+236"
  },
  {
    name: "Chad",
    flag: "\u{1F1F9}\u{1F1E9}",
    code: "TD",
    dial_code: "+235"
  },
  {
    name: "Chile",
    flag: "\u{1F1E8}\u{1F1F1}",
    code: "CL",
    dial_code: "+56"
  },
  {
    name: "China",
    flag: "\u{1F1E8}\u{1F1F3}",
    code: "CN",
    dial_code: "+86"
  },
  {
    name: "Christmas Island",
    flag: "\u{1F1E8}\u{1F1FD}",
    code: "CX",
    dial_code: "+61"
  },
  {
    name: "Cocos (Keeling) Islands",
    flag: "\u{1F1E8}\u{1F1E8}",
    code: "CC",
    dial_code: "+61"
  },
  {
    name: "Colombia",
    flag: "\u{1F1E8}\u{1F1F4}",
    code: "CO",
    dial_code: "+57"
  },
  {
    name: "Comoros",
    flag: "\u{1F1F0}\u{1F1F2}",
    code: "KM",
    dial_code: "+269"
  },
  {
    name: "Congo",
    flag: "\u{1F1E8}\u{1F1EC}",
    code: "CG",
    dial_code: "+242"
  },
  {
    name: "Congo, The Democratic Republic of the Congo",
    flag: "\u{1F1E8}\u{1F1E9}",
    code: "CD",
    dial_code: "+243"
  },
  {
    name: "Cook Islands",
    flag: "\u{1F1E8}\u{1F1F0}",
    code: "CK",
    dial_code: "+682"
  },
  {
    name: "Costa Rica",
    flag: "\u{1F1E8}\u{1F1F7}",
    code: "CR",
    dial_code: "+506"
  },
  {
    name: "Cote d'Ivoire",
    flag: "\u{1F1E8}\u{1F1EE}",
    code: "CI",
    dial_code: "+225"
  },
  {
    name: "Croatia",
    flag: "\u{1F1ED}\u{1F1F7}",
    code: "HR",
    dial_code: "+385"
  },
  {
    name: "Cuba",
    flag: "\u{1F1E8}\u{1F1FA}",
    code: "CU",
    dial_code: "+53"
  },
  {
    name: "Cyprus",
    flag: "\u{1F1E8}\u{1F1FE}",
    code: "CY",
    dial_code: "+357"
  },
  {
    name: "Czech Republic",
    flag: "\u{1F1E8}\u{1F1FF}",
    code: "CZ",
    dial_code: "+420"
  },
  {
    name: "Denmark",
    flag: "\u{1F1E9}\u{1F1F0}",
    code: "DK",
    dial_code: "+45"
  },
  {
    name: "Djibouti",
    flag: "\u{1F1E9}\u{1F1EF}",
    code: "DJ",
    dial_code: "+253"
  },
  {
    name: "Dominica",
    flag: "\u{1F1E9}\u{1F1F2}",
    code: "DM",
    dial_code: "+1767"
  },
  {
    name: "Dominican Republic",
    flag: "\u{1F1E9}\u{1F1F4}",
    code: "DO",
    dial_code: "+1849"
  },
  {
    name: "Dominican Republic",
    flag: "\u{1F1E9}\u{1F1F4}",
    code: "DO",
    dial_code: "+1829"
  },
  {
    name: "Dominican Republic",
    flag: "\u{1F1E9}\u{1F1F4}",
    code: "DO",
    dial_code: "+1809"
  },
  {
    name: "Ecuador",
    flag: "\u{1F1EA}\u{1F1E8}",
    code: "EC",
    dial_code: "+593"
  },
  {
    name: "Egypt",
    flag: "\u{1F1EA}\u{1F1EC}",
    code: "EG",
    dial_code: "+20"
  },
  {
    name: "El Salvador",
    flag: "\u{1F1F8}\u{1F1FB}",
    code: "SV",
    dial_code: "+503"
  },
  {
    name: "Equatorial Guinea",
    flag: "\u{1F1EC}\u{1F1F6}",
    code: "GQ",
    dial_code: "+240"
  },
  {
    name: "Eritrea",
    flag: "\u{1F1EA}\u{1F1F7}",
    code: "ER",
    dial_code: "+291"
  },
  {
    name: "Estonia",
    flag: "\u{1F1EA}\u{1F1EA}",
    code: "EE",
    dial_code: "+372"
  },
  {
    name: "Ethiopia",
    flag: "\u{1F1EA}\u{1F1F9}",
    code: "ET",
    dial_code: "+251"
  },
  {
    name: "Falkland Islands (Malvinas)",
    flag: "\u{1F1EB}\u{1F1F0}",
    code: "FK",
    dial_code: "+500"
  },
  {
    name: "Faroe Islands",
    flag: "\u{1F1EB}\u{1F1F4}",
    code: "FO",
    dial_code: "+298"
  },
  {
    name: "Fiji",
    flag: "\u{1F1EB}\u{1F1EF}",
    code: "FJ",
    dial_code: "+679"
  },
  {
    name: "Finland",
    flag: "\u{1F1EB}\u{1F1EE}",
    code: "FI",
    dial_code: "+358"
  },
  {
    name: "France",
    flag: "\u{1F1EB}\u{1F1F7}",
    code: "FR",
    dial_code: "+33"
  },
  {
    name: "French Guiana",
    flag: "\u{1F1EC}\u{1F1EB}",
    code: "GF",
    dial_code: "+594"
  },
  {
    name: "French Polynesia",
    flag: "\u{1F1F5}\u{1F1EB}",
    code: "PF",
    dial_code: "+689"
  },
  {
    name: "French Southern Territories",
    flag: "\u{1F1F9}\u{1F1EB}",
    code: "TF",
    dial_code: "+262"
  },
  {
    name: "Gabon",
    flag: "\u{1F1EC}\u{1F1E6}",
    code: "GA",
    dial_code: "+241"
  },
  {
    name: "Gambia",
    flag: "\u{1F1EC}\u{1F1F2}",
    code: "GM",
    dial_code: "+220"
  },
  {
    name: "Georgia",
    flag: "\u{1F1EC}\u{1F1EA}",
    code: "GE",
    dial_code: "+995"
  },
  {
    name: "Germany",
    flag: "\u{1F1E9}\u{1F1EA}",
    code: "DE",
    dial_code: "+49"
  },
  {
    name: "Ghana",
    flag: "\u{1F1EC}\u{1F1ED}",
    code: "GH",
    dial_code: "+233"
  },
  {
    name: "Gibraltar",
    flag: "\u{1F1EC}\u{1F1EE}",
    code: "GI",
    dial_code: "+350"
  },
  {
    name: "Greece",
    flag: "\u{1F1EC}\u{1F1F7}",
    code: "GR",
    dial_code: "+30"
  },
  {
    name: "Greenland",
    flag: "\u{1F1EC}\u{1F1F1}",
    code: "GL",
    dial_code: "+299"
  },
  {
    name: "Grenada",
    flag: "\u{1F1EC}\u{1F1E9}",
    code: "GD",
    dial_code: "+1473"
  },
  {
    name: "Guadeloupe",
    flag: "\u{1F1EC}\u{1F1F5}",
    code: "GP",
    dial_code: "+590"
  },
  {
    name: "Guam",
    flag: "\u{1F1EC}\u{1F1FA}",
    code: "GU",
    dial_code: "+1671"
  },
  {
    name: "Guatemala",
    flag: "\u{1F1EC}\u{1F1F9}",
    code: "GT",
    dial_code: "+502"
  },
  {
    name: "Guernsey",
    flag: "\u{1F1EC}\u{1F1EC}",
    code: "GG",
    dial_code: "+44"
  },
  {
    name: "Guinea",
    flag: "\u{1F1EC}\u{1F1F3}",
    code: "GN",
    dial_code: "+224"
  },
  {
    name: "Guinea-Bissau",
    flag: "\u{1F1EC}\u{1F1FC}",
    code: "GW",
    dial_code: "+245"
  },
  {
    name: "Guyana",
    flag: "\u{1F1EC}\u{1F1FE}",
    code: "GY",
    dial_code: "+592"
  },
  {
    name: "Haiti",
    flag: "\u{1F1ED}\u{1F1F9}",
    code: "HT",
    dial_code: "+509"
  },
  {
    name: "Heard Island and Mcdonald Islands",
    flag: "\u{1F1ED}\u{1F1F2}",
    code: "HM",
    dial_code: "+672"
  },
  {
    name: "Holy See (Vatican City State)",
    flag: "\u{1F1FB}\u{1F1E6}",
    code: "VA",
    dial_code: "+379"
  },
  {
    name: "Honduras",
    flag: "\u{1F1ED}\u{1F1F3}",
    code: "HN",
    dial_code: "+504"
  },
  {
    name: "Hong Kong",
    flag: "\u{1F1ED}\u{1F1F0}",
    code: "HK",
    dial_code: "+852"
  },
  {
    name: "Hungary",
    flag: "\u{1F1ED}\u{1F1FA}",
    code: "HU",
    dial_code: "+36"
  },
  {
    name: "Iceland",
    flag: "\u{1F1EE}\u{1F1F8}",
    code: "IS",
    dial_code: "+354"
  },
  {
    name: "India",
    flag: "\u{1F1EE}\u{1F1F3}",
    code: "IN",
    dial_code: "+91"
  },
  {
    name: "Indonesia",
    flag: "\u{1F1EE}\u{1F1E9}",
    code: "ID",
    dial_code: "+62"
  },
  {
    name: "Iran, Islamic Republic of Persian Gulf",
    flag: "\u{1F1EE}\u{1F1F7}",
    code: "IR",
    dial_code: "+98"
  },
  {
    name: "Iraq",
    flag: "\u{1F1EE}\u{1F1F6}",
    code: "IQ",
    dial_code: "+964"
  },
  {
    name: "Ireland",
    flag: "\u{1F1EE}\u{1F1EA}",
    code: "IE",
    dial_code: "+353"
  },
  {
    name: "Isle of Man",
    flag: "\u{1F1EE}\u{1F1F2}",
    code: "IM",
    dial_code: "+44"
  },
  {
    name: "Israel",
    flag: "\u{1F1EE}\u{1F1F1}",
    code: "IL",
    dial_code: "+972"
  },
  {
    name: "Italy",
    flag: "\u{1F1EE}\u{1F1F9}",
    code: "IT",
    dial_code: "+39"
  },
  {
    name: "Jamaica",
    flag: "\u{1F1EF}\u{1F1F2}",
    code: "JM",
    dial_code: "+1876"
  },
  {
    name: "Japan",
    flag: "\u{1F1EF}\u{1F1F5}",
    code: "JP",
    dial_code: "+81"
  },
  {
    name: "Jersey",
    flag: "\u{1F1EF}\u{1F1EA}",
    code: "JE",
    dial_code: "+44"
  },
  {
    name: "Jordan",
    flag: "\u{1F1EF}\u{1F1F4}",
    code: "JO",
    dial_code: "+962"
  },
  {
    name: "Kazakhstan",
    flag: "\u{1F1F0}\u{1F1FF}",
    code: "KZ",
    dial_code: "+7"
  },
  {
    name: "Kenya",
    flag: "\u{1F1F0}\u{1F1EA}",
    code: "KE",
    dial_code: "+254"
  },
  {
    name: "Kiribati",
    flag: "\u{1F1F0}\u{1F1EE}",
    code: "KI",
    dial_code: "+686"
  },
  {
    name: "Korea, Democratic People's Republic of Korea",
    flag: "\u{1F1F0}\u{1F1F5}",
    code: "KP",
    dial_code: "+850"
  },
  {
    name: "Korea, Republic of South Korea",
    flag: "\u{1F1F0}\u{1F1F7}",
    code: "KR",
    dial_code: "+82"
  },
  {
    name: "Kosovo",
    flag: "\u{1F1FD}\u{1F1F0}",
    code: "XK",
    dial_code: "+383"
  },
  {
    name: "Kuwait",
    flag: "\u{1F1F0}\u{1F1FC}",
    code: "KW",
    dial_code: "+965"
  },
  {
    name: "Kyrgyzstan",
    flag: "\u{1F1F0}\u{1F1EC}",
    code: "KG",
    dial_code: "+996"
  },
  {
    name: "Laos",
    flag: "\u{1F1F1}\u{1F1E6}",
    code: "LA",
    dial_code: "+856"
  },
  {
    name: "Latvia",
    flag: "\u{1F1F1}\u{1F1FB}",
    code: "LV",
    dial_code: "+371"
  },
  {
    name: "Lebanon",
    flag: "\u{1F1F1}\u{1F1E7}",
    code: "LB",
    dial_code: "+961"
  },
  {
    name: "Lesotho",
    flag: "\u{1F1F1}\u{1F1F8}",
    code: "LS",
    dial_code: "+266"
  },
  {
    name: "Liberia",
    flag: "\u{1F1F1}\u{1F1F7}",
    code: "LR",
    dial_code: "+231"
  },
  {
    name: "Libyan Arab Jamahiriya",
    flag: "\u{1F1F1}\u{1F1FE}",
    code: "LY",
    dial_code: "+218"
  },
  {
    name: "Liechtenstein",
    flag: "\u{1F1F1}\u{1F1EE}",
    code: "LI",
    dial_code: "+423"
  },
  {
    name: "Lithuania",
    flag: "\u{1F1F1}\u{1F1F9}",
    code: "LT",
    dial_code: "+370"
  },
  {
    name: "Luxembourg",
    flag: "\u{1F1F1}\u{1F1FA}",
    code: "LU",
    dial_code: "+352"
  },
  {
    name: "Macao",
    flag: "\u{1F1F2}\u{1F1F4}",
    code: "MO",
    dial_code: "+853"
  },
  {
    name: "Macedonia",
    flag: "\u{1F1F2}\u{1F1F0}",
    code: "MK",
    dial_code: "+389"
  },
  {
    name: "Madagascar",
    flag: "\u{1F1F2}\u{1F1EC}",
    code: "MG",
    dial_code: "+261"
  },
  {
    name: "Malawi",
    flag: "\u{1F1F2}\u{1F1FC}",
    code: "MW",
    dial_code: "+265"
  },
  {
    name: "Malaysia",
    flag: "\u{1F1F2}\u{1F1FE}",
    code: "MY",
    dial_code: "+60"
  },
  {
    name: "Maldives",
    flag: "\u{1F1F2}\u{1F1FB}",
    code: "MV",
    dial_code: "+960"
  },
  {
    name: "Mali",
    flag: "\u{1F1F2}\u{1F1F1}",
    code: "ML",
    dial_code: "+223"
  },
  {
    name: "Malta",
    flag: "\u{1F1F2}\u{1F1F9}",
    code: "MT",
    dial_code: "+356"
  },
  {
    name: "Marshall Islands",
    flag: "\u{1F1F2}\u{1F1ED}",
    code: "MH",
    dial_code: "+692"
  },
  {
    name: "Martinique",
    flag: "\u{1F1F2}\u{1F1F6}",
    code: "MQ",
    dial_code: "+596"
  },
  {
    name: "Mauritania",
    flag: "\u{1F1F2}\u{1F1F7}",
    code: "MR",
    dial_code: "+222"
  },
  {
    name: "Mauritius",
    flag: "\u{1F1F2}\u{1F1FA}",
    code: "MU",
    dial_code: "+230"
  },
  {
    name: "Mayotte",
    flag: "\u{1F1FE}\u{1F1F9}",
    code: "YT",
    dial_code: "+262"
  },
  {
    name: "Mexico",
    flag: "\u{1F1F2}\u{1F1FD}",
    code: "MX",
    dial_code: "+52"
  },
  {
    name: "Micronesia, Federated States of Micronesia",
    flag: "\u{1F1EB}\u{1F1F2}",
    code: "FM",
    dial_code: "+691"
  },
  {
    name: "Moldova",
    flag: "\u{1F1F2}\u{1F1E9}",
    code: "MD",
    dial_code: "+373"
  },
  {
    name: "Monaco",
    flag: "\u{1F1F2}\u{1F1E8}",
    code: "MC",
    dial_code: "+377"
  },
  {
    name: "Mongolia",
    flag: "\u{1F1F2}\u{1F1F3}",
    code: "MN",
    dial_code: "+976"
  },
  {
    name: "Montenegro",
    flag: "\u{1F1F2}\u{1F1EA}",
    code: "ME",
    dial_code: "+382"
  },
  {
    name: "Montserrat",
    flag: "\u{1F1F2}\u{1F1F8}",
    code: "MS",
    dial_code: "+1664"
  },
  {
    name: "Morocco",
    flag: "\u{1F1F2}\u{1F1E6}",
    code: "MA",
    dial_code: "+212"
  },
  {
    name: "Mozambique",
    flag: "\u{1F1F2}\u{1F1FF}",
    code: "MZ",
    dial_code: "+258"
  },
  {
    name: "Myanmar",
    flag: "\u{1F1F2}\u{1F1F2}",
    code: "MM",
    dial_code: "+95"
  },
  {
    name: "Namibia",
    flag: "\u{1F1F3}\u{1F1E6}",
    code: "NA",
    dial_code: "+264"
  },
  {
    name: "Nauru",
    flag: "\u{1F1F3}\u{1F1F7}",
    code: "NR",
    dial_code: "+674"
  },
  {
    name: "Nepal",
    flag: "\u{1F1F3}\u{1F1F5}",
    code: "NP",
    dial_code: "+977"
  },
  {
    name: "Netherlands",
    flag: "\u{1F1F3}\u{1F1F1}",
    code: "NL",
    dial_code: "+31"
  },
  {
    name: "Netherlands Antilles",
    flag: "",
    code: "AN",
    dial_code: "+599"
  },
  {
    name: "New Caledonia",
    flag: "\u{1F1F3}\u{1F1E8}",
    code: "NC",
    dial_code: "+687"
  },
  {
    name: "New Zealand",
    flag: "\u{1F1F3}\u{1F1FF}",
    code: "NZ",
    dial_code: "+64"
  },
  {
    name: "Nicaragua",
    flag: "\u{1F1F3}\u{1F1EE}",
    code: "NI",
    dial_code: "+505"
  },
  {
    name: "Niger",
    flag: "\u{1F1F3}\u{1F1EA}",
    code: "NE",
    dial_code: "+227"
  },
  {
    name: "Nigeria",
    flag: "\u{1F1F3}\u{1F1EC}",
    code: "NG",
    dial_code: "+234"
  },
  {
    name: "Niue",
    flag: "\u{1F1F3}\u{1F1FA}",
    code: "NU",
    dial_code: "+683"
  },
  {
    name: "Norfolk Island",
    flag: "\u{1F1F3}\u{1F1EB}",
    code: "NF",
    dial_code: "+672"
  },
  {
    name: "Northern Mariana Islands",
    flag: "\u{1F1F2}\u{1F1F5}",
    code: "MP",
    dial_code: "+1670"
  },
  {
    name: "Norway",
    flag: "\u{1F1F3}\u{1F1F4}",
    code: "NO",
    dial_code: "+47"
  },
  {
    name: "Oman",
    flag: "\u{1F1F4}\u{1F1F2}",
    code: "OM",
    dial_code: "+968"
  },
  {
    name: "Pakistan",
    flag: "\u{1F1F5}\u{1F1F0}",
    code: "PK",
    dial_code: "+92"
  },
  {
    name: "Palau",
    flag: "\u{1F1F5}\u{1F1FC}",
    code: "PW",
    dial_code: "+680"
  },
  {
    name: "Palestinian Territory, Occupied",
    flag: "\u{1F1F5}\u{1F1F8}",
    code: "PS",
    dial_code: "+970"
  },
  {
    name: "Panama",
    flag: "\u{1F1F5}\u{1F1E6}",
    code: "PA",
    dial_code: "+507"
  },
  {
    name: "Papua New Guinea",
    flag: "\u{1F1F5}\u{1F1EC}",
    code: "PG",
    dial_code: "+675"
  },
  {
    name: "Paraguay",
    flag: "\u{1F1F5}\u{1F1FE}",
    code: "PY",
    dial_code: "+595"
  },
  {
    name: "Peru",
    flag: "\u{1F1F5}\u{1F1EA}",
    code: "PE",
    dial_code: "+51"
  },
  {
    name: "Philippines",
    flag: "\u{1F1F5}\u{1F1ED}",
    code: "PH",
    dial_code: "+63"
  },
  {
    name: "Pitcairn",
    flag: "\u{1F1F5}\u{1F1F3}",
    code: "PN",
    dial_code: "+64"
  },
  {
    name: "Poland",
    flag: "\u{1F1F5}\u{1F1F1}",
    code: "PL",
    dial_code: "+48"
  },
  {
    name: "Portugal",
    flag: "\u{1F1F5}\u{1F1F9}",
    code: "PT",
    dial_code: "+351"
  },
  {
    name: "Puerto Rico",
    flag: "\u{1F1F5}\u{1F1F7}",
    code: "PR",
    dial_code: "+1939"
  },
  {
    name: "Qatar",
    flag: "\u{1F1F6}\u{1F1E6}",
    code: "QA",
    dial_code: "+974"
  },
  {
    name: "Romania",
    flag: "\u{1F1F7}\u{1F1F4}",
    code: "RO",
    dial_code: "+40"
  },
  {
    name: "Russia",
    flag: "\u{1F1F7}\u{1F1FA}",
    code: "RU",
    dial_code: "+7"
  },
  {
    name: "Rwanda",
    flag: "\u{1F1F7}\u{1F1FC}",
    code: "RW",
    dial_code: "+250"
  },
  {
    name: "Reunion",
    flag: "\u{1F1F7}\u{1F1EA}",
    code: "RE",
    dial_code: "+262"
  },
  {
    name: "Saint Barthelemy",
    flag: "\u{1F1E7}\u{1F1F1}",
    code: "BL",
    dial_code: "+590"
  },
  {
    name: "Saint Helena, Ascension and Tristan Da Cunha",
    flag: "\u{1F1F8}\u{1F1ED}",
    code: "SH",
    dial_code: "+290"
  },
  {
    name: "Saint Kitts and Nevis",
    flag: "\u{1F1F0}\u{1F1F3}",
    code: "KN",
    dial_code: "+1869"
  },
  {
    name: "Saint Lucia",
    flag: "\u{1F1F1}\u{1F1E8}",
    code: "LC",
    dial_code: "+1758"
  },
  {
    name: "Saint Martin",
    flag: "\u{1F1F2}\u{1F1EB}",
    code: "MF",
    dial_code: "+590"
  },
  {
    name: "Saint Pierre and Miquelon",
    flag: "\u{1F1F5}\u{1F1F2}",
    code: "PM",
    dial_code: "+508"
  },
  {
    name: "Saint Vincent and the Grenadines",
    flag: "\u{1F1FB}\u{1F1E8}",
    code: "VC",
    dial_code: "+1784"
  },
  {
    name: "Samoa",
    flag: "\u{1F1FC}\u{1F1F8}",
    code: "WS",
    dial_code: "+685"
  },
  {
    name: "San Marino",
    flag: "\u{1F1F8}\u{1F1F2}",
    code: "SM",
    dial_code: "+378"
  },
  {
    name: "Sao Tome and Principe",
    flag: "\u{1F1F8}\u{1F1F9}",
    code: "ST",
    dial_code: "+239"
  },
  {
    name: "Saudi Arabia",
    flag: "\u{1F1F8}\u{1F1E6}",
    code: "SA",
    dial_code: "+966"
  },
  {
    name: "Senegal",
    flag: "\u{1F1F8}\u{1F1F3}",
    code: "SN",
    dial_code: "+221"
  },
  {
    name: "Serbia",
    flag: "\u{1F1F7}\u{1F1F8}",
    code: "RS",
    dial_code: "+381"
  },
  {
    name: "Seychelles",
    flag: "\u{1F1F8}\u{1F1E8}",
    code: "SC",
    dial_code: "+248"
  },
  {
    name: "Sierra Leone",
    flag: "\u{1F1F8}\u{1F1F1}",
    code: "SL",
    dial_code: "+232"
  },
  {
    name: "Singapore",
    flag: "\u{1F1F8}\u{1F1EC}",
    code: "SG",
    dial_code: "+65"
  },
  {
    name: "Slovakia",
    flag: "\u{1F1F8}\u{1F1F0}",
    code: "SK",
    dial_code: "+421"
  },
  {
    name: "Slovenia",
    flag: "\u{1F1F8}\u{1F1EE}",
    code: "SI",
    dial_code: "+386"
  },
  {
    name: "Solomon Islands",
    flag: "\u{1F1F8}\u{1F1E7}",
    code: "SB",
    dial_code: "+677"
  },
  {
    name: "Somalia",
    flag: "\u{1F1F8}\u{1F1F4}",
    code: "SO",
    dial_code: "+252"
  },
  {
    name: "South Africa",
    flag: "\u{1F1FF}\u{1F1E6}",
    code: "ZA",
    dial_code: "+27"
  },
  {
    name: "South Sudan",
    flag: "\u{1F1F8}\u{1F1F8}",
    code: "SS",
    dial_code: "+211"
  },
  {
    name: "South Georgia and the South Sandwich Islands",
    flag: "\u{1F1EC}\u{1F1F8}",
    code: "GS",
    dial_code: "+500"
  },
  {
    name: "Spain",
    flag: "\u{1F1EA}\u{1F1F8}",
    code: "ES",
    dial_code: "+34"
  },
  {
    name: "Sri Lanka",
    flag: "\u{1F1F1}\u{1F1F0}",
    code: "LK",
    dial_code: "+94"
  },
  {
    name: "Sudan",
    flag: "\u{1F1F8}\u{1F1E9}",
    code: "SD",
    dial_code: "+249"
  },
  {
    name: "Suriname",
    flag: "\u{1F1F8}\u{1F1F7}",
    code: "SR",
    dial_code: "+597"
  },
  {
    name: "Svalbard and Jan Mayen",
    flag: "\u{1F1F8}\u{1F1EF}",
    code: "SJ",
    dial_code: "+47"
  },
  {
    name: "Swaziland",
    flag: "\u{1F1F8}\u{1F1FF}",
    code: "SZ",
    dial_code: "+268"
  },
  {
    name: "Sweden",
    flag: "\u{1F1F8}\u{1F1EA}",
    code: "SE",
    dial_code: "+46"
  },
  {
    name: "Switzerland",
    flag: "\u{1F1E8}\u{1F1ED}",
    code: "CH",
    dial_code: "+41"
  },
  {
    name: "Syrian Arab Republic",
    flag: "\u{1F1F8}\u{1F1FE}",
    code: "SY",
    dial_code: "+963"
  },
  {
    name: "Taiwan",
    flag: "\u{1F1F9}\u{1F1FC}",
    code: "TW",
    dial_code: "+886"
  },
  {
    name: "Tajikistan",
    flag: "\u{1F1F9}\u{1F1EF}",
    code: "TJ",
    dial_code: "+992"
  },
  {
    name: "Tanzania, United Republic of Tanzania",
    flag: "\u{1F1F9}\u{1F1FF}",
    code: "TZ",
    dial_code: "+255"
  },
  {
    name: "Thailand",
    flag: "\u{1F1F9}\u{1F1ED}",
    code: "TH",
    dial_code: "+66"
  },
  {
    name: "Timor-Leste",
    flag: "\u{1F1F9}\u{1F1F1}",
    code: "TL",
    dial_code: "+670"
  },
  {
    name: "Togo",
    flag: "\u{1F1F9}\u{1F1EC}",
    code: "TG",
    dial_code: "+228"
  },
  {
    name: "Tokelau",
    flag: "\u{1F1F9}\u{1F1F0}",
    code: "TK",
    dial_code: "+690"
  },
  {
    name: "Tonga",
    flag: "\u{1F1F9}\u{1F1F4}",
    code: "TO",
    dial_code: "+676"
  },
  {
    name: "Trinidad and Tobago",
    flag: "\u{1F1F9}\u{1F1F9}",
    code: "TT",
    dial_code: "+1868"
  },
  {
    name: "Tunisia",
    flag: "\u{1F1F9}\u{1F1F3}",
    code: "TN",
    dial_code: "+216"
  },
  {
    name: "Turkey",
    flag: "\u{1F1F9}\u{1F1F7}",
    code: "TR",
    dial_code: "+90"
  },
  {
    name: "Turkmenistan",
    flag: "\u{1F1F9}\u{1F1F2}",
    code: "TM",
    dial_code: "+993"
  },
  {
    name: "Turks and Caicos Islands",
    flag: "\u{1F1F9}\u{1F1E8}",
    code: "TC",
    dial_code: "+1649"
  },
  {
    name: "Tuvalu",
    flag: "\u{1F1F9}\u{1F1FB}",
    code: "TV",
    dial_code: "+688"
  },
  {
    name: "Uganda",
    flag: "\u{1F1FA}\u{1F1EC}",
    code: "UG",
    dial_code: "+256"
  },
  {
    name: "Ukraine",
    flag: "\u{1F1FA}\u{1F1E6}",
    code: "UA",
    dial_code: "+380"
  },
  {
    name: "United Arab Emirates",
    flag: "\u{1F1E6}\u{1F1EA}",
    code: "AE",
    dial_code: "+971"
  },
  {
    name: "United Kingdom",
    flag: "\u{1F1EC}\u{1F1E7}",
    code: "GB",
    dial_code: "+44"
  },
  {
    name: "United States",
    flag: "\u{1F1FA}\u{1F1F8}",
    code: "US",
    dial_code: "+1"
  },
  {
    name: "Uruguay",
    flag: "\u{1F1FA}\u{1F1FE}",
    code: "UY",
    dial_code: "+598"
  },
  {
    name: "Uzbekistan",
    flag: "\u{1F1FA}\u{1F1FF}",
    code: "UZ",
    dial_code: "+998"
  },
  {
    name: "Vanuatu",
    flag: "\u{1F1FB}\u{1F1FA}",
    code: "VU",
    dial_code: "+678"
  },
  {
    name: "Venezuela, Bolivarian Republic of Venezuela",
    flag: "\u{1F1FB}\u{1F1EA}",
    code: "VE",
    dial_code: "+58"
  },
  {
    name: "Vietnam",
    flag: "\u{1F1FB}\u{1F1F3}",
    code: "VN",
    dial_code: "+84"
  },
  {
    name: "Virgin Islands, British",
    flag: "\u{1F1FB}\u{1F1EC}",
    code: "VG",
    dial_code: "+1284"
  },
  {
    name: "Virgin Islands, U.S.",
    flag: "\u{1F1FB}\u{1F1EE}",
    code: "VI",
    dial_code: "+1340"
  },
  {
    name: "Wallis and Futuna",
    flag: "\u{1F1FC}\u{1F1EB}",
    code: "WF",
    dial_code: "+681"
  },
  {
    name: "Yemen",
    flag: "\u{1F1FE}\u{1F1EA}",
    code: "YE",
    dial_code: "+967"
  },
  {
    name: "Zambia",
    flag: "\u{1F1FF}\u{1F1F2}",
    code: "ZM",
    dial_code: "+260"
  },
  {
    name: "Zimbabwe",
    flag: "\u{1F1FF}\u{1F1FC}",
    code: "ZW",
    dial_code: "+263"
  }
];

// src/features/blocks/inputs/phone/components/PhoneInput.tsx
var _tmpl$39 = /* @__PURE__ */ template(`<div class="typebot-input-form flex w-full gap-2 items-end max-w-[350px]"><div class="flex typebot-input w-full"><div class="relative typebot-country-select flex justify-center items-center"><div class="pl-2 pr-1 flex items-center gap-2"><span></span></div><select class="absolute top-0 left-0 w-full h-full cursor-pointer opacity-0">`);
var _tmpl$211 = /* @__PURE__ */ template(`<option> `);
var PhoneInput = (props7) => {
  const [selectedCountryCode, setSelectedCountryCode] = createSignal(isEmpty(props7.defaultCountryCode) ? "INT" : props7.defaultCountryCode);
  const [inputValue, setInputValue2] = createSignal(props7.defaultValue ?? "");
  let inputRef;
  const handleInput = (inputValue2) => {
    setInputValue2(inputValue2);
    if (inputValue2?.startsWith("+") && inputValue2.length > 2) {
      const matchedCountry = phoneCountries.reduce((matchedCountry2, country) => {
        if (!country?.dial_code || matchedCountry2 !== null && !matchedCountry2.dial_code) {
          return matchedCountry2;
        }
        if (inputValue2?.startsWith(country.dial_code) && country.dial_code.length > (matchedCountry2?.dial_code.length ?? 0)) {
          return country;
        }
        return matchedCountry2;
      }, null);
      if (matchedCountry) setSelectedCountryCode(matchedCountry.code);
    }
  };
  const checkIfInputIsValid = () => inputRef?.value !== "" && inputRef?.reportValidity();
  const submit = () => {
    const selectedCountryDialCode = phoneCountries.find((country) => country.code === selectedCountryCode())?.dial_code;
    if (checkIfInputIsValid()) {
      const val = inputRef?.value ?? inputValue();
      props7.onSubmit({
        type: "text",
        value: val.startsWith("+") ? val : `${selectedCountryDialCode ?? ""}${val}`
      });
    } else inputRef?.focus();
  };
  const submitWhenEnter = (e) => {
    if (e.key === "Enter") submit();
  };
  const selectNewCountryCode = (event) => {
    const selectedCountry = phoneCountries.find((country) => country.code === event.currentTarget.value);
    if (!selectedCountry) return;
    const currentCountry = phoneCountries.find((country) => country.code === selectedCountryCode());
    if (inputValue() === "" || currentCountry && inputValue() === currentCountry.dial_code) setInputValue2(selectedCountry.dial_code);
    setSelectedCountryCode(selectedCountry.code);
    inputRef?.focus();
  };
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
    window.addEventListener("message", processIncomingEvent);
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot) return;
    if (data.command === "setInputValue") setInputValue2(data.value);
  };
  return (() => {
    var _el$ = _tmpl$39(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild, _el$6 = _el$4.nextSibling;
    _el$.$$keydown = submitWhenEnter;
    insert(_el$5, () => phoneCountries.find((country) => selectedCountryCode() === country.code)?.flag);
    insert(_el$4, createComponent(ChevronDownIcon, {
      "class": "w-3"
    }), null);
    _el$6.addEventListener("change", selectNewCountryCode);
    insert(_el$6, createComponent(For, {
      each: phoneCountries,
      children: (country) => (() => {
        var _el$7 = _tmpl$211(), _el$8 = _el$7.firstChild;
        insert(_el$7, () => country.name, _el$8);
        insert(_el$7, () => country.dial_code ? `(${country.dial_code})` : "", null);
        createRenderEffect(() => _el$7.selected = country.code === selectedCountryCode());
        createRenderEffect(() => _el$7.value = country.code);
        return _el$7;
      })()
    }));
    insert(_el$2, createComponent(ShortTextInput, {
      type: "tel",
      ref(r$) {
        var _ref$ = inputRef;
        typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
      },
      get value() {
        return inputValue();
      },
      onInput: handleInput,
      get placeholder() {
        return props7.labels?.placeholder ?? defaultPhoneInputOptions.labels.placeholder;
      },
      get autofocus() {
        return !isMobile();
      }
    }), null);
    insert(_el$, createComponent(SendButton, {
      type: "button",
      "on:click": submit,
      get children() {
        return props7.labels?.button;
      }
    }), null);
    return _el$;
  })();
};
delegateEvents(["keydown"]);

// ../../blocks/inputs/src/pictureChoice/constants.ts
var defaultPictureChoiceOptions = {
  buttonLabel: defaultButtonLabel,
  searchInputPlaceholder: "Filter the options...",
  isMultipleChoice: false,
  isSearchable: false,
  dynamicItems: {
    isEnabled: false
  }
};

// src/features/blocks/inputs/pictureChoice/MultiplePictureChoice.tsx
var _tmpl$40 = /* @__PURE__ */ template(`<div class="flex items-end typebot-input w-full">`);
var _tmpl$212 = /* @__PURE__ */ template(`<form class="flex flex-col gap-2 w-full items-end"><div>`);
var _tmpl$310 = /* @__PURE__ */ template(`<span class=font-semibold>`);
var _tmpl$46 = /* @__PURE__ */ template(`<span class="text-sm whitespace-pre-wrap text-left">`);
var _tmpl$54 = /* @__PURE__ */ template(`<div class="flex flex-col gap-1 ">`);
var _tmpl$64 = /* @__PURE__ */ template(`<div role=checkbox><img fetchpriority=high class=m-auto><div>`);
var _tmpl$74 = /* @__PURE__ */ template(`<div role=checkbox aria-checked class="flex flex-col focus:outline-none cursor-pointer select-none typebot-selectable-picture selected"><img fetchpriority=high><div>`);
var MultiplePictureChoice = (props7) => {
  let inputRef;
  const [filteredItems, setFilteredItems] = createSignal(props7.defaultItems);
  const [selectedItemIds, setSelectedItemIds] = createSignal([]);
  const [totalLoadedImages, setTotalLoadedImages] = createSignal(0);
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
  });
  const handleClick = (itemId) => {
    toggleSelectedItemId(itemId);
  };
  const toggleSelectedItemId = (itemId) => {
    const existingIndex = selectedItemIds().indexOf(itemId);
    if (existingIndex !== -1) {
      setSelectedItemIds((selectedItemIds2) => selectedItemIds2.filter((selectedItemId) => selectedItemId !== itemId));
    } else {
      setSelectedItemIds((selectedIndices) => [...selectedIndices, itemId]);
    }
  };
  const handleSubmit = () => {
    const selectedItems = selectedItemIds().map((selectedItemId) => props7.defaultItems.find((item) => item.id === selectedItemId));
    const hasInternalValue = selectedItems.some((item) => item?.value);
    props7.onSubmit({
      type: "text",
      value: selectedItems.map((item) => {
        if (item?.value) return item.value;
        return isNotEmpty(item?.title) ? item.title : item?.pictureSrc;
      }).join(", "),
      label: hasInternalValue ? selectedItems.map((item) => {
        return isNotEmpty(item?.title) ? item.title : item?.pictureSrc;
      }).join(", ") : void 0
    });
  };
  const filterItems = (inputValue) => {
    setFilteredItems(props7.defaultItems.filter((item) => item.title?.toLowerCase().includes((inputValue ?? "").toLowerCase()) || item.description?.toLowerCase().includes((inputValue ?? "").toLowerCase())));
  };
  createEffect(() => {
    if (totalLoadedImages() === props7.defaultItems.filter((item) => isDefined(item.pictureSrc)).length) props7.onTransitionEnd();
  });
  const onImageLoad = () => {
    setTotalLoadedImages((acc) => acc + 1);
  };
  return (() => {
    var _el$ = _tmpl$212(), _el$3 = _el$.firstChild;
    _el$.addEventListener("submit", handleSubmit);
    insert(_el$, createComponent(Show, {
      get when() {
        return props7.options?.isSearchable;
      },
      get children() {
        var _el$2 = _tmpl$40();
        insert(_el$2, createComponent(SearchInput, {
          ref(r$) {
            var _ref$ = inputRef;
            typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
          },
          onInput: filterItems,
          get placeholder() {
            return props7.options?.searchInputPlaceholder ?? defaultPictureChoiceOptions.searchInputPlaceholder;
          },
          onClear: () => setFilteredItems(props7.defaultItems)
        }));
        return _el$2;
      }
    }), _el$3);
    insert(_el$3, createComponent(For, {
      get each() {
        return filteredItems();
      },
      children: (item, index) => (() => {
        var _el$4 = _tmpl$64(), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling;
        addEventListener(_el$4, "click", () => handleClick(item.id));
        _el$5.addEventListener("load", onImageLoad);
        insert(_el$6, createComponent(Checkbox, {
          get isChecked() {
            return selectedItemIds().some((selectedItemId) => selectedItemId === item.id);
          },
          get ["class"]() {
            return "flex-shrink-0" + (item.title || item.description ? " mt-1" : void 0);
          }
        }), null);
        insert(_el$6, createComponent(Show, {
          get when() {
            return item.title || item.description;
          },
          get children() {
            var _el$7 = _tmpl$54();
            insert(_el$7, createComponent(Show, {
              get when() {
                return item.title;
              },
              get children() {
                var _el$8 = _tmpl$310();
                insert(_el$8, () => item.title);
                return _el$8;
              }
            }), null);
            insert(_el$7, createComponent(Show, {
              get when() {
                return item.description;
              },
              get children() {
                var _el$9 = _tmpl$46();
                insert(_el$9, () => item.description);
                return _el$9;
              }
            }), null);
            return _el$7;
          }
        }), null);
        createRenderEffect((_p$) => {
          var _v$ = selectedItemIds().some((selectedItemId) => selectedItemId === item.id), _v$2 = "flex flex-col focus:outline-none cursor-pointer select-none typebot-selectable-picture" + (selectedItemIds().some((selectedItemId) => selectedItemId === item.id) ? " selected" : "") + (isSvgSrc(item.pictureSrc) ? " has-svg" : ""), _v$3 = item.id, _v$4 = item.pictureSrc, _v$5 = item.title ?? `Picture ${index() + 1}`, _v$6 = `Picture choice ${index() + 1}`, _v$7 = "flex gap-3 py-2 flex-shrink-0" + (isEmpty(item.title) && isEmpty(item.description) ? " justify-center" : " px-3");
          _v$ !== _p$.e && setAttribute(_el$4, "aria-checked", _p$.e = _v$);
          _v$2 !== _p$.t && className(_el$4, _p$.t = _v$2);
          _v$3 !== _p$.a && setAttribute(_el$4, "data-itemid", _p$.a = _v$3);
          _v$4 !== _p$.o && setAttribute(_el$5, "src", _p$.o = _v$4);
          _v$5 !== _p$.i && setAttribute(_el$5, "alt", _p$.i = _v$5);
          _v$6 !== _p$.n && setAttribute(_el$5, "elementtiming", _p$.n = _v$6);
          _v$7 !== _p$.s && className(_el$6, _p$.s = _v$7);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0,
          o: void 0,
          i: void 0,
          n: void 0,
          s: void 0
        });
        return _el$4;
      })()
    }), null);
    insert(_el$3, createComponent(For, {
      get each() {
        return selectedItemIds().filter((selectedItemId) => filteredItems().every((item) => item.id !== selectedItemId)).map((selectedItemId) => props7.defaultItems.find((item) => item.id === selectedItemId)).filter(isDefined);
      },
      children: (selectedItem, index) => (() => {
        var _el$10 = _tmpl$74(), _el$11 = _el$10.firstChild, _el$12 = _el$11.nextSibling;
        addEventListener(_el$10, "click", () => handleClick(selectedItem.id));
        insert(_el$12, createComponent(Checkbox, {
          get isChecked() {
            return selectedItemIds().some((selectedItemId) => selectedItemId === selectedItem.id);
          },
          get ["class"]() {
            return "flex-shrink-0" + (selectedItem.title || selectedItem.description ? " mt-1" : void 0);
          }
        }), null);
        insert(_el$12, createComponent(Show, {
          get when() {
            return selectedItem.title || selectedItem.description;
          },
          get children() {
            var _el$13 = _tmpl$54();
            insert(_el$13, createComponent(Show, {
              get when() {
                return selectedItem.title;
              },
              get children() {
                var _el$14 = _tmpl$310();
                insert(_el$14, () => selectedItem.title);
                return _el$14;
              }
            }), null);
            insert(_el$13, createComponent(Show, {
              get when() {
                return selectedItem.description;
              },
              get children() {
                var _el$15 = _tmpl$46();
                insert(_el$15, () => selectedItem.description);
                return _el$15;
              }
            }), null);
            return _el$13;
          }
        }), null);
        createRenderEffect((_p$) => {
          var _v$8 = selectedItem.id, _v$9 = props7.defaultItems.find((item) => item.id === selectedItem.id)?.pictureSrc, _v$10 = selectedItem.title ?? `Selected picture ${index() + 1}`, _v$11 = `Selected picture choice ${index() + 1}`, _v$12 = "flex gap-3 py-2 flex-shrink-0" + (isEmpty(selectedItem.title) && isEmpty(selectedItem.description) ? " justify-center" : " pl-4");
          _v$8 !== _p$.e && setAttribute(_el$10, "data-itemid", _p$.e = _v$8);
          _v$9 !== _p$.t && setAttribute(_el$11, "src", _p$.t = _v$9);
          _v$10 !== _p$.a && setAttribute(_el$11, "alt", _p$.a = _v$10);
          _v$11 !== _p$.o && setAttribute(_el$11, "elementtiming", _p$.o = _v$11);
          _v$12 !== _p$.i && className(_el$12, _p$.i = _v$12);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0,
          o: void 0,
          i: void 0
        });
        return _el$10;
      })()
    }), null);
    insert(_el$, (() => {
      var _c$ = createMemo(() => selectedItemIds().length > 0);
      return () => _c$() && createComponent(SendButton, {
        disableIcon: true,
        get children() {
          return props7.options?.buttonLabel ?? defaultPictureChoiceOptions.buttonLabel;
        }
      });
    })(), null);
    createRenderEffect(() => className(_el$3, "flex flex-wrap justify-end gap-2" + (props7.options?.isSearchable ? " overflow-y-scroll max-h-[464px] rounded-md" : "")));
    return _el$;
  })();
};

// src/features/blocks/inputs/pictureChoice/SinglePictureChoice.tsx
var _tmpl$41 = /* @__PURE__ */ template(`<div class="flex items-end typebot-input w-full">`);
var _tmpl$213 = /* @__PURE__ */ template(`<div class="flex flex-col gap-2 w-full"><div>`);
var _tmpl$311 = /* @__PURE__ */ template(`<button><img fetchpriority=high class=m-auto><div><span class=font-semibold></span><span class="text-sm whitespace-pre-wrap text-left">`);
var SinglePictureChoice = (props7) => {
  let inputRef;
  const [filteredItems, setFilteredItems] = createSignal(props7.defaultItems);
  const [totalLoadedImages, setTotalLoadedImages] = createSignal(0);
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
  });
  const handleClick = (itemIndex) => {
    const item = filteredItems()[itemIndex];
    if (!item) return;
    return props7.onSubmit({
      type: "text",
      label: isNotEmpty(item.title) ? item.title : item.pictureSrc ?? item.id,
      value: isNotEmpty(item.value) ? item.value : item.id
    });
  };
  const filterItems = (inputValue) => {
    setFilteredItems(props7.defaultItems.filter((item) => item.title?.toLowerCase().includes((inputValue ?? "").toLowerCase()) || item.description?.toLowerCase().includes((inputValue ?? "").toLowerCase())));
  };
  createEffect(() => {
    if (totalLoadedImages() === props7.defaultItems.filter((item) => isDefined(item.pictureSrc)).length) props7.onTransitionEnd();
  });
  const onImageLoad = () => {
    setTotalLoadedImages((acc) => acc + 1);
  };
  return (() => {
    var _el$ = _tmpl$213(), _el$3 = _el$.firstChild;
    insert(_el$, createComponent(Show, {
      get when() {
        return props7.options?.isSearchable;
      },
      get children() {
        var _el$2 = _tmpl$41();
        insert(_el$2, createComponent(SearchInput, {
          ref(r$) {
            var _ref$ = inputRef;
            typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
          },
          onInput: filterItems,
          get placeholder() {
            return props7.options?.searchInputPlaceholder ?? "";
          },
          onClear: () => setFilteredItems(props7.defaultItems)
        }));
        return _el$2;
      }
    }), _el$3);
    insert(_el$3, createComponent(For, {
      get each() {
        return filteredItems();
      },
      children: (item, index) => (() => {
        var _el$4 = _tmpl$311(), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling, _el$7 = _el$6.firstChild, _el$8 = _el$7.nextSibling;
        addEventListener(_el$4, "click", () => handleClick(index()));
        _el$5.addEventListener("load", onImageLoad);
        insert(_el$7, () => item.title);
        insert(_el$8, () => item.description);
        createRenderEffect((_p$) => {
          var _v$ = item.id, _v$2 = "flex flex-col typebot-picture-button focus:outline-none filter hover:brightness-90 active:brightness-75 justify-between  " + (isSvgSrc(item.pictureSrc) ? "has-svg" : ""), _v$3 = item.pictureSrc, _v$4 = item.title ?? `Picture ${index() + 1}`, _v$5 = `Picture choice ${index() + 1}`, _v$6 = "flex flex-col gap-1 py-2 flex-shrink-0 px-4 w-full" + (item.description ? " items-start" : "");
          _v$ !== _p$.e && setAttribute(_el$4, "data-itemid", _p$.e = _v$);
          _v$2 !== _p$.t && className(_el$4, _p$.t = _v$2);
          _v$3 !== _p$.a && setAttribute(_el$5, "src", _p$.a = _v$3);
          _v$4 !== _p$.o && setAttribute(_el$5, "alt", _p$.o = _v$4);
          _v$5 !== _p$.i && setAttribute(_el$5, "elementtiming", _p$.i = _v$5);
          _v$6 !== _p$.n && className(_el$6, _p$.n = _v$6);
          return _p$;
        }, {
          e: void 0,
          t: void 0,
          a: void 0,
          o: void 0,
          i: void 0,
          n: void 0
        });
        return _el$4;
      })()
    }));
    createRenderEffect(() => className(_el$3, "gap-2 flex flex-wrap justify-end" + (props7.options?.isSearchable ? " overflow-y-scroll max-h-[464px] rounded-md" : "")));
    return _el$;
  })();
};

// ../../blocks/inputs/src/rating/constants.ts
var defaultRatingInputOptions = {
  buttonType: "Numbers",
  length: 10,
  labels: {
    button: defaultButtonLabel
  },
  startsAt: 0,
  customIcon: { isEnabled: false },
  isOneClickSubmitEnabled: false
};

// src/features/blocks/inputs/rating/components/RatingForm.tsx
var _tmpl$47 = /* @__PURE__ */ template(`<form class="flex flex-col gap-2"><div class="flex flex-wrap justify-center gap-2"></div><div class="flex justify-end">`);
var _tmpl$214 = /* @__PURE__ */ template(`<span class="text-sm w-full rating-label">`);
var _tmpl$312 = /* @__PURE__ */ template(`<span class="text-sm w-full text-right pr-2 rating-label">`);
var _tmpl$48 = /* @__PURE__ */ template(`<div role=checkbox>`);
var _tmpl$55 = /* @__PURE__ */ template(`<div>`);
var RatingForm = (props7) => {
  const [rating, setRating] = createSignal(props7.defaultValue ? Number(props7.defaultValue) : void 0);
  const handleSubmit = (e) => {
    e.preventDefault();
    const selectedRating = rating();
    if (isNotDefined(selectedRating)) return;
    props7.onSubmit({
      type: "text",
      value: selectedRating.toString()
    });
  };
  const handleClick = (rating2) => {
    if (props7.block.options?.isOneClickSubmitEnabled) props7.onSubmit({
      type: "text",
      value: rating2.toString()
    });
    setRating(rating2);
  };
  return (() => {
    var _el$ = _tmpl$47(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    _el$.addEventListener("submit", handleSubmit);
    insert(_el$, (() => {
      var _c$ = createMemo(() => !!props7.block.options?.labels?.left);
      return () => _c$() && (() => {
        var _el$4 = _tmpl$214();
        insert(_el$4, () => props7.block.options.labels.left);
        return _el$4;
      })();
    })(), _el$2);
    insert(_el$2, createComponent(For, {
      get each() {
        return Array.from(Array((props7.block.options?.length ?? defaultRatingInputOptions.length) + ((props7.block.options?.buttonType ?? defaultRatingInputOptions.buttonType) === "Numbers" ? -((props7.block.options?.startsAt ?? defaultRatingInputOptions.startsAt) - 1) : 0)));
      },
      children: (_, idx) => createComponent(RatingButton, mergeProps(() => props7.block.options, {
        get rating() {
          return rating();
        },
        get idx() {
          return idx() + ((props7.block.options?.buttonType ?? defaultRatingInputOptions.buttonType) === "Numbers" ? props7.block.options?.startsAt ?? defaultRatingInputOptions.startsAt : 1);
        },
        onClick: handleClick
      }))
    }));
    insert(_el$, (() => {
      var _c$2 = createMemo(() => !!props7.block.options?.labels?.right);
      return () => _c$2() && (() => {
        var _el$5 = _tmpl$312();
        insert(_el$5, () => props7.block.options.labels.right);
        return _el$5;
      })();
    })(), _el$3);
    insert(_el$3, (() => {
      var _c$3 = createMemo(() => !!isDefined(rating()));
      return () => _c$3() && createComponent(SendButton, {
        disableIcon: true,
        get children() {
          return props7.block.options?.labels?.button ?? defaultRatingInputOptions.labels.button;
        }
      });
    })());
    return _el$;
  })();
};
var RatingButton = (props7) => {
  const handleClick = (e) => {
    e.preventDefault();
    props7.onClick(props7.idx);
  };
  return createComponent(Switch, {
    get children() {
      return [createComponent(Match, {
        get when() {
          return (props7.buttonType ?? defaultRatingInputOptions.buttonType) === "Numbers";
        },
        get children() {
          return [createComponent(Show, {
            get when() {
              return props7.isOneClickSubmitEnabled;
            },
            get children() {
              return createComponent(Button, {
                "on:click": handleClick,
                get children() {
                  return props7.idx;
                }
              });
            }
          }), createComponent(Show, {
            get when() {
              return !props7.isOneClickSubmitEnabled;
            },
            get children() {
              var _el$6 = _tmpl$48();
              addEventListener(_el$6, "click", handleClick);
              insert(_el$6, () => props7.idx);
              createRenderEffect((_p$) => {
                var _v$ = isDefined(props7.rating) && props7.idx <= props7.rating, _v$2 = "py-2 px-4 font-semibold focus:outline-none cursor-pointer select-none typebot-selectable" + (isDefined(props7.rating) && props7.idx <= props7.rating ? " selected" : "");
                _v$ !== _p$.e && setAttribute(_el$6, "aria-checked", _p$.e = _v$);
                _v$2 !== _p$.t && className(_el$6, _p$.t = _v$2);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$6;
            }
          })];
        }
      }), createComponent(Match, {
        get when() {
          return (props7.buttonType ?? defaultRatingInputOptions.buttonType) !== "Numbers";
        },
        get children() {
          var _el$7 = _tmpl$55();
          addEventListener(_el$7, "click", () => props7.onClick(props7.idx));
          createRenderEffect((_p$) => {
            var _v$3 = "flex justify-center items-center rating-icon-container cursor-pointer " + (isDefined(props7.rating) && props7.idx <= props7.rating ? "selected" : ""), _v$4 = props7.customIcon?.isEnabled && !isEmpty(props7.customIcon.svg) ? props7.customIcon.svg : defaultIcon;
            _v$3 !== _p$.e && className(_el$7, _p$.e = _v$3);
            _v$4 !== _p$.t && (_el$7.innerHTML = _p$.t = _v$4);
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$7;
        }
      })];
    }
  });
};
var defaultIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-star"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>`;

// src/components/icons/PaperClipIcon.tsx
var _tmpl$49 = /* @__PURE__ */ template(`<svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48">`);
var PaperClipIcon = (props7) => {
  return (() => {
    var _el$ = _tmpl$49();
    spread(_el$, props7, true, true);
    return _el$;
  })();
};

// src/components/icons/PictureIcon.tsx
var _tmpl$50 = /* @__PURE__ */ template(`<svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2px stroke-linecap=round stroke-linejoin=round><path d="M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z"></path><path d="M14 2v4a2 2 0 0 0 2 2h4"></path><circle cx=10 cy=12 r=2></circle><path d="m20 17-1.296-1.296a2.41 2.41 0 0 0-3.408 0L9 22">`);
var PictureIcon = (props7) => (() => {
  var _el$ = _tmpl$50();
  spread(_el$, props7, true, true);
  return _el$;
})();

// src/components/TextInputAddFileButton.tsx
var _tmpl$51 = /* @__PURE__ */ template(`<input type=file id=document-upload multiple class=hidden>`);
var _tmpl$215 = /* @__PURE__ */ template(`<input type=file id=photos-upload accept="image/avif, image/*, video/*"multiple class=hidden>`);
var _tmpl$313 = /* @__PURE__ */ template(`<label aria-label="Add attachments"for=document-upload>`);
var _tmpl$410 = /* @__PURE__ */ template(`<label> Document`);
var _tmpl$56 = /* @__PURE__ */ template(`<label> Photos & videos`);
var TextInputAddFileButton = (props7) => {
  return [(() => {
    var _el$ = _tmpl$51();
    _el$.addEventListener("change", (e) => {
      if (!e.currentTarget.files) return;
      props7.onNewFiles(e.currentTarget.files);
    });
    return _el$;
  })(), (() => {
    var _el$2 = _tmpl$215();
    _el$2.addEventListener("change", (e) => {
      if (!e.currentTarget.files) return;
      props7.onNewFiles(e.currentTarget.files);
    });
    return _el$2;
  })(), createComponent(Switch, {
    get children() {
      return [createComponent(Match, {
        get when() {
          return isMobile();
        },
        get children() {
          var _el$3 = _tmpl$313();
          insert(_el$3, createComponent(PaperClipIcon, {
            "class": "w-5"
          }));
          createRenderEffect(() => className(_el$3, cx("filter data-[state=open]:backdrop-brightness-90 hover:backdrop-brightness-95 transition rounded-md p-2 focus:outline-none", props7.class)));
          return _el$3;
        }
      }), createComponent(Match, {
        when: true,
        get children() {
          return createComponent(menu_exports.Root, {
            get children() {
              return [createComponent(menu_exports.Trigger, {
                get ["class"]() {
                  return cx("filter data-[state=open]:backdrop-brightness-90 hover:backdrop-brightness-95 transition rounded-md p-2 focus:outline-none", props7.class);
                },
                "aria-label": "Add attachments",
                get children() {
                  return createComponent(PaperClipIcon, {
                    "class": "w-5"
                  });
                }
              }), createComponent(menu_exports.Positioner, {
                get children() {
                  return createComponent(menu_exports.Content, {
                    "class": "p-3 gap-2 focus:outline-none",
                    get children() {
                      return [createComponent(menu_exports.Item, {
                        value: "document",
                        asChild: (props8) => (() => {
                          var _el$4 = _tmpl$410(), _el$5 = _el$4.firstChild;
                          spread(_el$4, mergeProps(props8, {
                            "for": "document-upload",
                            "class": "p-2 filter hover:brightness-95 flex gap-3 items-center"
                          }), false, true);
                          insert(_el$4, createComponent(FileIcon, {
                            "class": "w-4"
                          }), _el$5);
                          return _el$4;
                        })()
                      }), createComponent(menu_exports.Item, {
                        value: "photos",
                        asChild: (props8) => (() => {
                          var _el$6 = _tmpl$56(), _el$7 = _el$6.firstChild;
                          spread(_el$6, mergeProps(props8, {
                            "for": "photos-upload",
                            "class": "p-2 filter hover:brightness-95 flex gap-3 items-center"
                          }), false, true);
                          insert(_el$6, createComponent(PictureIcon, {
                            "class": "w-4"
                          }), _el$7);
                          return _el$6;
                        })()
                      })];
                    }
                  });
                }
              })];
            }
          });
        }
      })];
    }
  })];
};

// src/components/icons/MicrophoneIcon.tsx
var _tmpl$57 = /* @__PURE__ */ template(`<svg viewBox="0 0 384 512"stroke=currentColor fill=currentColor><path d="M192 0C139 0 96 43 96 96l0 160c0 53 43 96 96 96s96-43 96-96l0-160c0-53-43-96-96-96zM64 216c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40c0 89.1 66.2 162.7 152 174.4l0 33.6-48 0c-13.3 0-24 10.7-24 24s10.7 24 24 24l72 0 72 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-48 0 0-33.6c85.8-11.7 152-85.3 152-174.4l0-40c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40c0 70.7-57.3 128-128 128s-128-57.3-128-128l0-40z">`);
var MicrophoneIcon = (props7) => (() => {
  var _el$ = _tmpl$57();
  spread(_el$, props7, true, true);
  return _el$;
})();

// ../../../node_modules/solid-textarea-autosize/dist/esm/index.js
var HIDDEN_TEXTAREA_STYLE = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
};
var forceHiddenStyles = (node) => {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach((key) => {
    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], "important");
  });
};
var forceHiddenStyles$1 = forceHiddenStyles;
var hiddenTextarea = null;
var getHeight = (node, sizingData) => {
  const height = node.scrollHeight;
  if (sizingData.sizingStyle["box-sizing"] === "border-box") {
    return height + sizingData.borderSize;
  }
  return height - sizingData.paddingSize;
};
function calculateNodeHeight(sizingData, value, minRows = 1, maxRows = Infinity) {
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tabindex", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    forceHiddenStyles$1(hiddenTextarea);
  }
  if (hiddenTextarea.parentNode === null) {
    document.body.appendChild(hiddenTextarea);
  }
  const {
    paddingSize,
    borderSize,
    sizingStyle
  } = sizingData;
  const {
    "box-sizing": boxSizing
  } = sizingStyle;
  Object.keys(sizingStyle).forEach((_key) => {
    const key = _key;
    hiddenTextarea.style[key] = sizingStyle[key];
  });
  forceHiddenStyles$1(hiddenTextarea);
  hiddenTextarea.value = value;
  let height = getHeight(hiddenTextarea, sizingData);
  hiddenTextarea.value = "x";
  const rowHeight = hiddenTextarea.scrollHeight - paddingSize;
  let minHeight = rowHeight * minRows;
  if (boxSizing === "border-box") {
    minHeight = minHeight + paddingSize + borderSize;
  }
  height = Math.max(minHeight, height);
  let maxHeight = rowHeight * maxRows;
  if (boxSizing === "border-box") {
    maxHeight = maxHeight + paddingSize + borderSize;
  }
  height = Math.min(maxHeight, height);
  return [height, rowHeight];
}
var pick = (props7, obj) => props7.reduce((acc, prop) => {
  acc[prop] = obj[prop];
  return acc;
}, {});
var SIZING_STYLE = [
  "border-bottom-width",
  "border-left-width",
  "border-right-width",
  "border-top-width",
  "box-sizing",
  "font-family",
  "font-size",
  "font-style",
  "font-zeight",
  "letter-spacing",
  "line-height",
  "padding-bottom",
  "padding-left",
  "padding-right",
  "padding-top",
  // non-standard
  "tab-size",
  "text-indent",
  // non-standard
  "text-rendering",
  "text-transform",
  "width",
  "word-break"
];
var isIE = typeof document !== "undefined" ? !!document.documentElement.currentStyle : false;
var getSizingData = (node) => {
  const style2 = window.getComputedStyle(node);
  if (!style2) {
    return null;
  }
  const sizingStyle = pick(SIZING_STYLE, style2);
  const {
    "box-sizing": boxSizing
  } = sizingStyle;
  if (!boxSizing) {
    return null;
  }
  if (isIE && boxSizing === "border-box") {
    sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle["border-right-width"]) + parseFloat(sizingStyle["border-left-width"]) + parseFloat(sizingStyle["padding-right"]) + parseFloat(sizingStyle["padding-left"]) + "px";
  }
  const paddingSize = parseFloat(sizingStyle["padding-bottom"]) + parseFloat(sizingStyle["padding-top"]);
  const borderSize = parseFloat(sizingStyle["border-bottom-width"]) + parseFloat(sizingStyle["border-top-width"]);
  return {
    sizingStyle,
    paddingSize,
    borderSize
  };
};
var getSizingData$1 = getSizingData;
var useWindowResizeListener = (listener) => {
  const handler = (event) => listener(event);
  window.addEventListener("resize", handler);
  onCleanup(() => window.removeEventListener("resize", handler));
};
var _tmpl$58 = /* @__PURE__ */ template(`<textarea></textarea>`, 2);
function TextareaAutosize(props7) {
  const [textarea, setTextarea] = createSignal();
  let heightRef = 0;
  let measurementsCacheRef = void 0;
  const resizeTextarea = () => {
    const node = textarea();
    if (!node) return;
    const nodeSizingData = props7.cacheMeasurements && measurementsCacheRef ? measurementsCacheRef : getSizingData$1(node);
    if (!nodeSizingData) {
      return;
    }
    measurementsCacheRef = nodeSizingData;
    const [height, rowHeight] = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || "x", props7.minRows, props7.maxRows);
    if (heightRef !== height) {
      heightRef = height;
      node.style.setProperty("height", `${height}px`, "important");
      props7.onHeightChange?.(height, {
        rowHeight
      });
    }
  };
  const handleChange = (event) => {
    resizeTextarea();
    if (typeof props7.oninput === "function") props7.oninput(event);
    if (typeof props7.onInput === "function") props7.onInput(event);
  };
  createEffect(on(() => props7.value, resizeTextarea));
  createEffect(() => {
    if (typeof document !== "undefined" && textarea()) {
      resizeTextarea();
      useWindowResizeListener(resizeTextarea);
    }
  });
  return (() => {
    const _el$ = _tmpl$58.cloneNode(true);
    use((element) => setTextarea(element), _el$);
    spread(_el$, mergeProps(props7, {
      "oninput": handleChange,
      "onInput": handleChange
    }), false, false);
    return _el$;
  })();
}

// src/components/inputs/Textarea.tsx
var _tmpl$59 = /* @__PURE__ */ template(`<textarea class="focus:outline-none bg-transparent px-4 py-2 flex-1 w-full text-input"rows=6 data-testid=textarea required>`);
var Textarea = (props7) => {
  const [local, others] = splitProps(props7, ["ref", "onInput"]);
  return createComponent(TextareaAutosize, mergeProps({
    ref(r$) {
      var _ref$ = local.ref;
      typeof _ref$ === "function" ? _ref$(r$) : local.ref = r$;
    },
    "class": "focus:outline-none bg-transparent px-2 py-2 flex-1 w-full text-input",
    minRows: 1,
    maxRows: 5,
    "data-testid": "textarea",
    required: true,
    get autofocus() {
      return !isMobile();
    },
    onInput: (e) => local.onInput(e.currentTarget.value)
  }, others));
  return (() => {
    var _el$ = _tmpl$59();
    _el$.$$input = (e) => local.onInput(e.currentTarget.value);
    var _ref$2 = local.ref;
    typeof _ref$2 === "function" ? use(_ref$2, _el$) : local.ref = _el$;
    spread(_el$, mergeProps({
      get autofocus() {
        return !isMobile();
      }
    }, others), false, false);
    return _el$;
  })();
};
delegateEvents(["input"]);

// src/features/blocks/inputs/textInput/components/TextInput.tsx
var import_fix = __toESM(require_src2(), 1);

// ../../blocks/inputs/src/text/constants.ts
var defaultTextInputOptions = {
  isLong: false,
  labels: { button: defaultButtonLabel, placeholder: "Type your answer..." },
  audioClip: {
    isEnabled: false,
    visibility: "Auto"
  },
  attachments: {
    isEnabled: false,
    visibility: "Auto"
  }
};

// src/features/blocks/inputs/textInput/components/VolumeProcessor.ts
var volumeProcessorCode = `
const gainFactor = 3;

class VolumeProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
  }

  process(inputs) {
    const input = inputs[0];
    if (input.length > 0) {
      const channelData = input[0];
      let sum = 0;
      for (let i = 0; i < channelData.length; i++) {
        sum += channelData[i] * channelData[i];
      }
      const rms = Math.sqrt(sum / channelData.length);
      this.port.postMessage(rms * 100 * gainFactor)
    }
    return true;
  }
}

registerProcessor("volume-processor", VolumeProcessor);

`;

// src/features/blocks/inputs/textInput/components/VoiceRecorder.tsx
var _tmpl$60 = /* @__PURE__ */ template(`<div><button class="p-0.5 rounded-full"aria-label="Stop recording"></button><div class="relative flex w-full"><canvas class="w-full h-[56px]"></canvas><div class="absolute left-gradient w-2 left-0 h-[56px]"></div><div class="absolute right-gradient w-3 right-0 h-[56px]"></div></div><span class="time-container flex-none w-[35px] font-bold text-sm">`);
var barWidth = 3;
var barGap = 3;
var dx = 60;
var initBarsHeightPercent = 10;
var minDetectedVolumePercent = 5;
var maxDetectedVolumePercent = 90;
var VoiceRecorder = (props7) => {
  const [recordingTime, setRecordingTime] = createSignal(0);
  let canvasElement;
  let animationFrameId;
  let ctx;
  let audioContext;
  let volumeNode;
  let microphone;
  let stream;
  let bars = [];
  let recordTimeInterval;
  let lastFrameTime = void 0;
  let offset3 = 0;
  const fillRgb = hexToRgb(props7.buttonsTheme?.backgroundColor ?? defaultButtonsBackgroundColor[isTypebotVersionAtLeastV6(props7.context.typebot.version) ? props7.context.typebot.version : "6"]).join(", ");
  const draw = () => {
    if (!ctx || !canvasElement || !lastFrameTime) return;
    const currentTime = performance.now();
    const deltaTime = currentTime - lastFrameTime;
    lastFrameTime = currentTime;
    ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    ctx.fillStyle = `rgba(${fillRgb}, 0.2)`;
    for (let i = 0; i < (canvasElement.width + barGap) / (barWidth + barGap); i++) {
      const x = i * (barWidth + barGap) - offset3;
      const barHeight = canvasElement.height * (initBarsHeightPercent / 100);
      const y = (canvasElement.height - barHeight) / 2;
      ctx.beginPath();
      ctx.roundRect(x, y, barWidth, barHeight, 5);
      ctx.fill();
    }
    ctx.fillStyle = `rgba(${fillRgb}, 1)`;
    for (let i = 0; i < bars.length; i++) {
      const x = canvasElement.width + (i + 1) * (barWidth + barGap) - offset3;
      const barHeight = canvasElement.height * ((bars[i] ?? 0) / 100);
      const y = (canvasElement.height - barHeight) / 2;
      ctx.beginPath();
      ctx.roundRect(x, y, barWidth, barHeight, 5);
      ctx.fill();
    }
    offset3 += dx * (deltaTime / 1e3);
    animationFrameId = requestAnimationFrame(draw);
  };
  const startRecording = async () => {
    if (!canvasElement) return;
    stream = await navigator.mediaDevices.getUserMedia({
      audio: true
    });
    props7.onRecordingConfirmed(stream);
    if (!ctx) ctx = canvasElement.getContext("2d") ?? void 0;
    recordTimeInterval = setInterval(() => {
      setRecordingTime((prev) => prev += 1);
    }, 1e3);
    audioContext = new AudioContext();
    volumeNode = await loadVolumeProcessorWorklet(audioContext);
    microphone = audioContext.createMediaStreamSource(stream);
    microphone.connect(volumeNode);
    volumeNode.connect(audioContext.destination);
    volumeNode.port.onmessage = (event) => {
      const initBars = (canvasElement.width + barGap) / (barWidth + barGap);
      const shouldAddNewBar = (initBars + bars.length) * (barWidth + barGap) < canvasElement.width + offset3;
      if (shouldAddNewBar) bars.push(Math.min(Math.max(event.data, minDetectedVolumePercent), maxDetectedVolumePercent));
    };
    lastFrameTime = performance.now();
    animationFrameId = requestAnimationFrame(draw);
  };
  const stopRecording = () => {
    if (ctx && canvasElement) ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    offset3 = 0;
    volumeNode?.disconnect();
    volumeNode = void 0;
    microphone?.disconnect();
    microphone = void 0;
    audioContext?.close();
    audioContext = void 0;
    stream?.getTracks().forEach((track) => track.stop());
    stream = void 0;
    bars = [];
    clearTimeout(recordTimeInterval);
    setRecordingTime(0);
    cancelAnimationFrame(animationFrameId);
    props7.onAbortRecording();
  };
  createEffect(() => {
    if (props7.recordingStatus === "asking") {
      startRecording();
    } else if (props7.recordingStatus === "stopped") {
      stopRecording();
    }
  });
  onCleanup(() => {
    stopRecording();
  });
  return (() => {
    var _el$ = _tmpl$60(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling, _el$4 = _el$3.firstChild, _el$5 = _el$3.nextSibling;
    addEventListener(_el$2, "click", stopRecording);
    insert(_el$2, createComponent(CloseIcon, {
      "class": "w-4"
    }));
    var _ref$ = canvasElement;
    typeof _ref$ === "function" ? use(_ref$, _el$4) : canvasElement = _el$4;
    insert(_el$5, () => formatTimeLabel(recordingTime()));
    createRenderEffect(() => className(_el$, cx("w-full gap-2 items-center transition-opacity px-2 typebot-recorder", props7.recordingStatus === "started" ? "opacity-1 flex" : "opacity-0 hidden")));
    return _el$;
  })();
};
var loadVolumeProcessorWorklet = async (audioContext) => {
  const blob = new Blob([volumeProcessorCode], {
    type: "application/javascript"
  });
  const volumeProcessorCodeUrl = URL.createObjectURL(blob);
  await audioContext.audioWorklet.addModule(volumeProcessorCodeUrl);
  return new AudioWorkletNode(audioContext, "volume-processor");
};
var formatTimeLabel = (seconds) => {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  const formattedSeconds = remainingSeconds.toString().padStart(2, "0");
  return `${minutes}:${formattedSeconds}`;
};

// src/features/blocks/inputs/textInput/components/TextInput.tsx
var _tmpl$61 = /* @__PURE__ */ template(`<div class="p-2 flex gap-2 border-gray-100 overflow-auto">`);
var _tmpl$216 = /* @__PURE__ */ template(`<div>`);
var _tmpl$314 = /* @__PURE__ */ template(`<div><div>`);
var TextInput = (props7) => {
  const [inputValue, setInputValue2] = createSignal(props7.defaultValue ?? "");
  const [selectedFiles, setSelectedFiles] = createSignal([]);
  const [uploadProgress, setUploadProgress] = createSignal(void 0);
  const [isDraggingOver, setIsDraggingOver] = createSignal(false);
  const [recordingStatus, setRecordingStatus] = createSignal("stopped");
  let inputRef;
  let mediaRecorder;
  let recordedChunks = [];
  const handleInput = (inputValue2) => setInputValue2(inputValue2);
  const checkIfInputIsValid = () => inputRef?.value !== "" && inputRef?.reportValidity();
  const submit = async () => {
    console.log("submit recording status: ", recordingStatus());
    console.log("submit mediaRecorder: ", mediaRecorder);
    if (recordingStatus() === "started" && mediaRecorder) {
      console.log("stopping recording ");
      mediaRecorder.stop();
      return;
    }
    if (checkIfInputIsValid()) {
      let attachments;
      if (selectedFiles().length > 0) {
        setUploadProgress(void 0);
        const urls = await uploadFiles2({
          apiHost: props7.context.apiHost ?? guessApiHost({
            ignoreChatApiUrl: true
          }),
          files: selectedFiles().map((file) => ({
            file,
            input: {
              blockId: props7.block.id,
              sessionId: props7.context.sessionId,
              fileName: file.name
            }
          })),
          onUploadProgress: setUploadProgress
        });
        attachments = urls?.map((urls2, index) => urls2 ? {
          ...urls2,
          blobUrl: URL.createObjectURL(selectedFiles()[index])
        } : null).filter(isDefined);
      }
      props7.onSubmit({
        type: "text",
        value: inputRef?.value ?? inputValue(),
        attachments
      });
    } else inputRef?.focus();
  };
  const submitWhenEnter = (e) => {
    if (props7.block.options?.isLong) return;
    if (e.key === "Enter") submit();
  };
  const submitIfCtrlEnter = (e) => {
    if (!props7.block.options?.isLong) return;
    if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) submit();
  };
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
    window.addEventListener("message", processIncomingEvent);
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot) {
      return;
    }
    if (data.command === "setInputValue") {
      setInputValue2(data.value);
    }
  };
  const handleDragOver = (e) => {
    e.preventDefault();
    setIsDraggingOver(true);
  };
  const handleDragLeave = () => setIsDraggingOver(false);
  const handleDropFile = (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!e.dataTransfer?.files) {
      return;
    }
    onNewFiles(e.dataTransfer.files);
  };
  const onNewFiles = (files) => {
    const newFiles = Array.from(files).map((file) => sanitizeNewFile({
      existingFiles: selectedFiles(),
      newFile: file,
      params: {
        sizeLimit: getRuntimeVariable("NEXT_PUBLIC_BOT_FILE_UPLOAD_MAX_SIZE") ? Number(getRuntimeVariable("NEXT_PUBLIC_BOT_FILE_UPLOAD_MAX_SIZE")) : void 0
      },
      context: props7.context,
      onError: ({
        description
      }) => {
        toaster.create({
          description
        });
      }
    })).filter(isDefined);
    if (newFiles.length === 0) return;
    setSelectedFiles((selectedFiles2) => [...newFiles, ...selectedFiles2]);
  };
  const removeSelectedFile = (index) => {
    setSelectedFiles((selectedFiles2) => selectedFiles2.filter((_, i) => i !== index));
  };
  const recordVoice = () => {
    setRecordingStatus("asking");
  };
  const handleRecordingConfirmed = (stream) => {
    let startTime;
    const mimeType = MediaRecorder.isTypeSupported("audio/webm") ? "audio/webm" : "video/mp4";
    mediaRecorder = new MediaRecorder(stream, {
      mimeType
    });
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size === 0) {
        return;
      }
      recordedChunks.push(event.data);
    };
    mediaRecorder.onstart = () => {
      startTime = Date.now();
    };
    mediaRecorder.onstop = async () => {
      console.log("onstop recording callback recordingStatus:  ", recordingStatus());
      console.log("onstop recording callback recordedChunks: ", recordedChunks.length);
      if (recordingStatus() !== "started" || recordedChunks.length === 0) {
        console.log("onstop recording callback aborted");
        return;
      }
      const duration = Date.now() - startTime;
      const blob = await (0, import_fix.fixWebmDuration)(new Blob(recordedChunks, {
        type: mimeType
      }), duration);
      const audioFile = new File([blob], `rec-${props7.block.id}-${Date.now()}.${mimeType === "audio/webm" ? "webm" : "mp4"}`, {
        type: mimeType
      });
      console.log("audio file created", audioFile);
      console.log("uploading record");
      setUploadProgress(void 0);
      const urls = (await uploadFiles2({
        apiHost: props7.context.apiHost ?? guessApiHost({
          ignoreChatApiUrl: true
        }),
        files: [{
          file: audioFile,
          input: {
            blockId: props7.block.id,
            sessionId: props7.context.sessionId,
            fileName: audioFile.name
          }
        }],
        onUploadProgress: setUploadProgress
      })).filter(isDefined).map((url) => url.url);
      console.log("recording submitted");
      props7.onSubmit({
        type: "recording",
        url: urls[0],
        blobUrl: URL.createObjectURL(audioFile)
      });
    };
    mediaRecorder.start();
    setRecordingStatus("started");
  };
  const handleRecordingAbort = () => {
    mediaRecorder?.stop();
    setRecordingStatus("stopped");
    mediaRecorder = void 0;
    recordedChunks = [];
  };
  return (() => {
    var _el$ = _tmpl$314(), _el$2 = _el$.firstChild;
    _el$.addEventListener("dragleave", handleDragLeave);
    _el$.addEventListener("dragover", handleDragOver);
    _el$.addEventListener("drop", handleDropFile);
    _el$.$$keydown = submitWhenEnter;
    insert(_el$2, createComponent(VoiceRecorder, {
      get recordingStatus() {
        return recordingStatus();
      },
      get buttonsTheme() {
        return props7.context.typebot.theme.chat?.buttons;
      },
      get context() {
        return props7.context;
      },
      onRecordingConfirmed: handleRecordingConfirmed,
      onAbortRecording: handleRecordingAbort
    }), null);
    insert(_el$2, createComponent(Show, {
      get when() {
        return recordingStatus() !== "started";
      },
      get children() {
        return [createComponent(Show, {
          get when() {
            return selectedFiles().length;
          },
          get children() {
            var _el$3 = _tmpl$61();
            _el$3.style.setProperty("border-bottom-width", "1px");
            insert(_el$3, createComponent(For, {
              get each() {
                return selectedFiles();
              },
              children: (file, index) => createComponent(SelectedFile, {
                file,
                get uploadProgressPercent() {
                  return createMemo(() => !!uploadProgress())() ? createMemo(() => uploadProgress()?.fileIndex === index())() ? 20 : index() < (uploadProgress()?.fileIndex ?? 0) ? 100 : 0 : void 0;
                },
                onRemoveClick: () => removeSelectedFile(index())
              })
            }));
            return _el$3;
          }
        }), (() => {
          var _el$4 = _tmpl$216();
          insert(_el$4, (() => {
            var _c$ = createMemo(() => !!props7.block.options?.isLong);
            return () => _c$() ? createComponent(Textarea, {
              ref(r$) {
                var _ref$ = inputRef;
                typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
              },
              onInput: handleInput,
              onKeyDown: submitIfCtrlEnter,
              get value() {
                return inputValue();
              },
              get placeholder() {
                return props7.block.options?.labels?.placeholder ?? defaultTextInputOptions.labels.placeholder;
              }
            }) : createComponent(ShortTextInput, {
              ref(r$) {
                var _ref$2 = inputRef;
                typeof _ref$2 === "function" ? _ref$2(r$) : inputRef = r$;
              },
              onInput: handleInput,
              get value() {
                return inputValue();
              },
              get placeholder() {
                return props7.block.options?.labels?.placeholder ?? defaultTextInputOptions.labels.placeholder;
              }
            });
          })(), null);
          insert(_el$4, createComponent(Show, {
            get when() {
              return (props7.block.options?.attachments?.isEnabled ?? defaultTextInputOptions.attachments.isEnabled) && props7.block.options?.attachments?.saveVariableId;
            },
            get children() {
              return createComponent(TextInputAddFileButton, {
                onNewFiles,
                get ["class"]() {
                  return cx(props7.block.options?.isLong ? "ml-2" : void 0);
                }
              });
            }
          }), null);
          createRenderEffect(() => className(_el$4, cx("flex justify-between", props7.block.options?.isLong ? "items-end" : "items-center")));
          return _el$4;
        })()];
      }
    }), null);
    insert(_el$, createComponent(Switch, {
      get children() {
        return [createComponent(Match, {
          get when() {
            return !inputValue() && recordingStatus() !== "started" && props7.block.options?.audioClip?.isEnabled;
          },
          get children() {
            return createComponent(Button, {
              "class": "h-[56px] flex items-center",
              "on:click": recordVoice,
              "aria-label": "Record voice",
              get children() {
                return createComponent(MicrophoneIcon, {
                  "class": "flex w-6 h-6"
                });
              }
            });
          }
        }), createComponent(Match, {
          when: true,
          get children() {
            return createComponent(SendButton, {
              type: "button",
              "on:click": submit,
              get isDisabled() {
                return Boolean(uploadProgress());
              },
              get children() {
                return props7.block.options?.labels?.button;
              }
            });
          }
        })];
      }
    }), null);
    createRenderEffect((_p$) => {
      var _v$ = cx("typebot-input-form flex w-full gap-2 items-end", props7.block.options?.isLong && recordingStatus() !== "started" ? "max-w-full" : "max-w-[350px]"), _v$2 = cx("relative typebot-input flex-col w-full", isDraggingOver() && "filter brightness-95");
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
      return _p$;
    }, {
      e: void 0,
      t: void 0
    });
    return _el$;
  })();
};
delegateEvents(["keydown"]);

// src/features/blocks/inputs/time/components/TimeForm.tsx
var _tmpl$65 = /* @__PURE__ */ template(`<div class="typebot-input-form flex w-full gap-2 items-end max-w-[350px]"><div class="flex typebot-input w-full"><input class="focus:outline-none bg-transparent px-4 py-4 flex-1 w-full text-input typebot-datetime-input "type=time data-testid=time>`);
var TimeForm = (props7) => {
  const [inputValue, setInputValue2] = createSignal(props7.defaultValue ?? "");
  let inputRef;
  const handleInput = (inputValue2) => setInputValue2(inputValue2);
  const checkIfInputIsValid = () => inputRef?.value !== "" && inputRef?.reportValidity();
  const submit = () => {
    if (checkIfInputIsValid()) props7.onSubmit({
      type: "text",
      value: inputRef?.value ?? inputValue()
    });
    else inputRef?.focus();
  };
  const submitWhenEnter = (e) => {
    if (e.key === "Enter") submit();
  };
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
    window.addEventListener("message", processIncomingEvent);
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot) return;
    if (data.command === "setInputValue") setInputValue2(data.value);
  };
  return (() => {
    var _el$ = _tmpl$65(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;
    _el$.$$keydown = submitWhenEnter;
    _el$3.$$input = (e) => {
      handleInput(e.currentTarget.value);
    };
    var _ref$ = inputRef;
    typeof _ref$ === "function" ? use(_ref$, _el$3) : inputRef = _el$3;
    _el$3.style.setProperty("font-size", "16px");
    insert(_el$, createComponent(SendButton, {
      type: "button",
      "on:click": submit,
      get children() {
        return props7.block?.labels?.button;
      }
    }), null);
    createRenderEffect(() => _el$3.value = inputValue());
    return _el$;
  })();
};
delegateEvents(["keydown", "input"]);

// ../../blocks/inputs/src/url/constants.ts
var defaultUrlInputOptions = {
  labels: {
    button: defaultButtonLabel,
    placeholder: "Type a URL..."
  },
  retryMessageContent: "This URL doesn't seem to be valid. Can you type it again?"
};

// src/features/blocks/inputs/url/components/UrlInput.tsx
var _tmpl$66 = /* @__PURE__ */ template(`<div class="typebot-input-form flex w-full gap-2 items-end max-w-[350px]"><div class="flex typebot-input w-full">`);
var UrlInput = (props7) => {
  const [inputValue, setInputValue2] = createSignal(props7.defaultValue ?? "");
  let inputRef;
  const handleInput = (inputValue2) => {
    setInputValue2(inputValue2);
  };
  const checkIfInputIsValid = () => inputRef?.value !== "" && inputRef?.reportValidity();
  const submit = () => {
    if (inputRef && !inputRef?.value.startsWith("http")) inputRef.value = `https://${inputRef.value}`;
    if (checkIfInputIsValid()) props7.onSubmit({
      type: "text",
      value: inputRef?.value ?? inputValue()
    });
    else inputRef?.focus();
  };
  const submitWhenEnter = (e) => {
    if (e.key === "Enter") submit();
  };
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
    window.addEventListener("message", processIncomingEvent);
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot) return;
    if (data.command === "setInputValue") setInputValue2(data.value);
  };
  return (() => {
    var _el$ = _tmpl$66(), _el$2 = _el$.firstChild;
    _el$.$$keydown = submitWhenEnter;
    insert(_el$2, createComponent(ShortTextInput, {
      ref(r$) {
        var _ref$ = inputRef;
        typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
      },
      get value() {
        return inputValue();
      },
      get placeholder() {
        return props7.block.options?.labels?.placeholder ?? defaultUrlInputOptions.labels.placeholder;
      },
      onInput: handleInput,
      type: "url",
      autocomplete: "url"
    }));
    insert(_el$, createComponent(SendButton, {
      type: "button",
      "on:click": submit,
      get children() {
        return props7.block.options?.labels?.button;
      }
    }), null);
    return _el$;
  })();
};
delegateEvents(["keydown"]);

// src/components/Modal.tsx
var Modal = (props7) => {
  return createComponent(dialog_exports.Root, {
    get open() {
      return props7.isOpen;
    },
    lazyMount: true,
    unmountOnExit: true,
    get onOpenChange() {
      return props7.onClose;
    },
    get children() {
      return createComponent(Portal, {
        get mount() {
          return botContainer();
        },
        get children() {
          return [createComponent(dialog_exports.Backdrop, {
            "class": "absolute inset-0 bg-[rgba(0,0,0,0.8)] h-screen z-50"
          }), createComponent(dialog_exports.Positioner, {
            "class": "absolute inset-0 z-50 flex items-center justify-center px-2",
            get children() {
              return [createComponent(dialog_exports.Content, {
                "class": "focus:outline-none",
                get children() {
                  return props7.children;
                }
              }), createComponent(dialog_exports.CloseTrigger, {
                "class": "fixed top-4 right-4 z-50 rounded-md bg-[#202020] p-2 text-white",
                get children() {
                  return createComponent(CloseIcon, {
                    "class": "w-6 h-6"
                  });
                }
              })];
            }
          })];
        }
      });
    }
  });
};

// src/components/avatars/DefaultAvatar.tsx
var _tmpl$67 = /* @__PURE__ */ template(`<svg viewBox="0 0 156 156"data-testid=default-avatar><rect width=156 height=156 rx=78></rect><path d="M104.936 49.1111C103.446 45.3515 99.7782 42.6938 95.4875 42.6938H58.0109C52.3972 42.6938 47.8457 47.2454 47.8457 52.859V102.555C47.8457 105.405 49.0182 107.98 50.9075 109.825C52.3996 113.584 56.0699 116.242 60.3606 116.242H97.8373C103.451 116.242 108 111.693 108 106.079V56.3837C108 53.5334 106.828 50.9557 104.936 49.1111ZM99.7759 102.555C99.7759 104.918 97.8514 106.843 95.4875 106.843H58.0109C57.3177 106.843 56.6621 106.678 56.0817 106.382C54.6812 105.677 53.7202 104.225 53.7202 102.555V52.859C53.7202 50.4928 55.6446 48.5683 58.0109 48.5683H95.4875C97.748 48.5683 99.6067 50.3283 99.7641 52.5535C99.7712 52.6546 99.7759 52.7556 99.7759 52.859V102.555Z"fill=white></path><path d="M74.1477 54.4219L71.2273 54.9369C70.4362 55.0764 69.908 55.8308 70.0475 56.6219L77.6623 99.8073C77.8017 100.598 78.5561 101.127 79.3472 100.987L82.2676 100.472C83.0587 100.333 83.587 99.5783 83.4475 98.7872L75.8327 55.6018C75.6932 54.8107 74.9388 54.2824 74.1477 54.4219Z"fill=white>`);
var DefaultAvatar = ({
  backgroundColor
}) => (() => {
  var _el$ = _tmpl$67(), _el$2 = _el$.firstChild;
  setAttribute(_el$2, "fill", backgroundColor);
  createRenderEffect(() => setAttribute(_el$, "class", isMobile() ? "size-6" : "size-10"));
  return _el$;
})();

// src/components/avatars/Avatar.tsx
var _tmpl$68 = /* @__PURE__ */ template(`<span class="text-4xl text-[40px]">`);
var _tmpl$217 = /* @__PURE__ */ template(`<img alt="Bot avatar"elementtiming="Bot avatar">`);
var _tmpl$315 = /* @__PURE__ */ template(`<figure><img alt="Bot avatar"class="rounded-full object-cover w-full h-full"elementtiming="Bot avatar"fetchpriority=high>`);
var Avatar = (props7) => {
  return createComponent(Show, {
    get when() {
      return isNotEmpty(props7.src);
    },
    keyed: true,
    get fallback() {
      return createComponent(DefaultAvatar, {
        get backgroundColor() {
          return props7.isChatContainerLight ? colors.gray.dark[2] : colors.gray.dark[1];
        }
      });
    },
    get children() {
      return createComponent(Switch, {
        get children() {
          return [createComponent(Match, {
            get when() {
              return isEmoji(props7.src ?? "");
            },
            get children() {
              var _el$ = _tmpl$68();
              insert(_el$, () => props7.src);
              return _el$;
            }
          }), createComponent(Match, {
            get when() {
              return isSvgSrc(props7.src);
            },
            get children() {
              var _el$2 = _tmpl$217();
              createRenderEffect((_p$) => {
                var _v$ = props7.src, _v$2 = "flex justify-center items-center relative animate-fade-in flex-shrink-0 " + (isMobile() ? "w-6 h-6 text-sm" : "w-10 h-10 text-xl");
                _v$ !== _p$.e && setAttribute(_el$2, "src", _p$.e = _v$);
                _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$2;
            }
          }), createComponent(Match, {
            when: true,
            get children() {
              var _el$3 = _tmpl$315(), _el$4 = _el$3.firstChild;
              createRenderEffect((_p$) => {
                var _v$3 = "flex justify-center items-center rounded-full text-white relative animate-fade-in flex-shrink-0 " + (isMobile() ? "w-6 h-6 text-sm" : "w-10 h-10 text-xl"), _v$4 = props7.src;
                _v$3 !== _p$.e && className(_el$3, _p$.e = _v$3);
                _v$4 !== _p$.t && setAttribute(_el$4, "src", _p$.t = _v$4);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$3;
            }
          })];
        }
      });
    }
  });
};
var isEmoji = (src) => {
  return /^\p{Emoji}$/u.test(src);
};

// src/components/bubbles/GuestBubble.tsx
var _tmpl$69 = /* @__PURE__ */ template(`<div class="flex justify-end items-end animate-fade-in gap-2 guest-container">`);
var _tmpl$218 = /* @__PURE__ */ template(`<div>`);
var _tmpl$316 = /* @__PURE__ */ template(`<span class="px-[15px] py-[7px]">`);
var _tmpl$411 = /* @__PURE__ */ template(`<img alt=Attachment class="max-h-[calc(100vh-1rem)] max-w-[calc(100%-1rem)] rounded-[6px] m-auto">`);
var _tmpl$510 = /* @__PURE__ */ template(`<div class="flex flex-col gap-1 items-end"><div class="p-[1px] whitespace-pre-wrap max-w-full typebot-guest-bubble flex flex-col"data-testid=guest-bubble>`);
var _tmpl$610 = /* @__PURE__ */ template(`<img>`);
var _tmpl$75 = /* @__PURE__ */ template(`<div class="flex flex-col gap-1 items-end"><div class="p-2 w-full whitespace-pre-wrap typebot-guest-bubble flex flex-col"data-testid=guest-bubble><audio controls>`);
var GuestBubble = (props7) => {
  return (() => {
    var _el$ = _tmpl$69();
    insert(_el$, createComponent(Switch, {
      get children() {
        return [createComponent(Match, {
          get when() {
            return props7.answer?.type === "text";
          },
          get children() {
            return createComponent(TextGuestBubble, {
              get answer() {
                return props7.answer;
              }
            });
          }
        }), createComponent(Match, {
          get when() {
            return props7.answer?.type === "recording";
          },
          get children() {
            return createComponent(AudioGuestBubble, {
              get answer() {
                return props7.answer;
              }
            });
          }
        })];
      }
    }), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return props7.theme.chat?.guestAvatar?.isEnabled ?? defaultGuestAvatarIsEnabled;
      },
      get children() {
        return createComponent(Avatar, {
          get src() {
            return props7.avatarSrc;
          },
          get isChatContainerLight() {
            return isChatContainerLight({
              chatContainer: props7.theme.chat?.container,
              generalBackground: props7.theme.general?.background
            });
          }
        });
      }
    }), null);
    createRenderEffect((_$p) => (_$p = props7.theme.chat?.hostAvatar?.isEnabled ?? defaultHostAvatarIsEnabled ? isMobile() ? "28px" : "50px" : void 0) != null ? _el$.style.setProperty("margin-left", _$p) : _el$.style.removeProperty("margin-left"));
    return _el$;
  })();
};
var TextGuestBubble = (props7) => {
  const [clickedImageSrc, setClickedImageSrc] = createSignal();
  return (() => {
    var _el$2 = _tmpl$510(), _el$5 = _el$2.firstChild;
    insert(_el$2, createComponent(Show, {
      get when() {
        return (props7.answer.attachments ?? []).length > 0;
      },
      get children() {
        return [(() => {
          var _el$3 = _tmpl$218();
          insert(_el$3, createComponent(For, {
            get each() {
              return props7.answer.attachments?.filter((attachment) => attachment.type.startsWith("image"));
            },
            children: (attachment, idx) => (() => {
              var _el$8 = _tmpl$610();
              _el$8.$$click = () => setClickedImageSrc(attachment.blobUrl ?? attachment.url);
              createRenderEffect((_p$) => {
                var _v$ = attachment.blobUrl ?? attachment.url, _v$2 = `Attached image ${idx() + 1}`, _v$3 = cx("typebot-guest-bubble-image-attachment cursor-pointer", props7.answer.attachments.filter((attachment2) => attachment2.type.startsWith("image")).length > 1 && "max-w-[90%]");
                _v$ !== _p$.e && setAttribute(_el$8, "src", _p$.e = _v$);
                _v$2 !== _p$.t && setAttribute(_el$8, "alt", _p$.t = _v$2);
                _v$3 !== _p$.a && className(_el$8, _p$.a = _v$3);
                return _p$;
              }, {
                e: void 0,
                t: void 0,
                a: void 0
              });
              return _el$8;
            })()
          }));
          createRenderEffect(() => className(_el$3, cx("flex gap-1 overflow-auto max-w-[350px]", isMobile() ? "flex-wrap justify-end" : "items-center")));
          return _el$3;
        })(), (() => {
          var _el$4 = _tmpl$218();
          insert(_el$4, createComponent(For, {
            get each() {
              return props7.answer.attachments?.filter((attachment) => !attachment.type.startsWith("image"));
            },
            children: (attachment) => createComponent(FilePreview, {
              get file() {
                return {
                  name: attachment.url.split("/").at(-1)
                };
              }
            })
          }));
          createRenderEffect(() => className(_el$4, cx("flex gap-1 overflow-auto max-w-[350px]", isMobile() ? "flex-wrap justify-end" : "items-center")));
          return _el$4;
        })()];
      }
    }), _el$5);
    insert(_el$5, createComponent(Show, {
      get when() {
        return isNotEmpty(props7.answer.label ?? props7.answer.value);
      },
      get children() {
        var _el$6 = _tmpl$316();
        insert(_el$6, () => props7.answer.label ?? props7.answer.value);
        return _el$6;
      }
    }));
    insert(_el$2, createComponent(Modal, {
      get isOpen() {
        return clickedImageSrc() !== void 0;
      },
      onClose: () => setClickedImageSrc(void 0),
      get children() {
        var _el$7 = _tmpl$411();
        createRenderEffect(() => setAttribute(_el$7, "src", clickedImageSrc()));
        return _el$7;
      }
    }), null);
    return _el$2;
  })();
};
var AudioGuestBubble = (props7) => {
  return (() => {
    var _el$9 = _tmpl$75(), _el$10 = _el$9.firstChild, _el$11 = _el$10.firstChild;
    createRenderEffect(() => setAttribute(_el$11, "src", props7.answer.blobUrl ?? props7.answer.url));
    return _el$9;
  })();
};
delegateEvents(["click"]);

// src/components/InputChatBlock.tsx
var _tmpl$70 = /* @__PURE__ */ template(`<div class="flex justify-end animate-fade-in gap-2 typebot-input-container"><div class="flex justify-end gap-2 typebot-input-container">`);
var InputChatBlock = (props7) => {
  const [answer, setAnswer] = persist(createSignal(), {
    key: `typebot-${props7.context.typebot.id}-input-${props7.chunkIndex}`,
    storage: props7.context.storage
  });
  onMount(() => {
    if (props7.isOngoingLastChunk && isDefined(answer())) {
      props7.onSubmit(answer());
    }
  });
  const handleSubmit = async (content) => {
    setAnswer(content);
    props7.onSubmit(content);
  };
  const handleSkip = (label) => {
    setAnswer({
      type: "text",
      value: label
    });
    props7.onSkip();
  };
  createEffect(() => {
    const currentAnswer = answer();
    if (currentAnswer?.type === "text" && currentAnswer.label) return;
    const formattedMessage = formattedMessages().findLast((message) => props7.chunkIndex === message.inputIndex)?.formattedMessage;
    if (formattedMessage && props7.block.type !== "file input" /* FILE */) setAnswer((answer2) => answer2?.type === "text" ? {
      ...answer2,
      label: formattedMessage
    } : answer2);
  });
  const avatarSrc = getAvatarAtIndex({
    avatarHistory: props7.avatarHistory,
    currentIndex: props7.chunkIndex,
    currentRole: "guest"
  });
  console.log(props7.context.typebot.theme.chat?.inputs?.backgroundColor);
  return createComponent(Switch, {
    get children() {
      return [createComponent(Match, {
        get when() {
          return answer() && !props7.hasError;
        },
        get children() {
          return createComponent(GuestBubble, {
            get answer() {
              return answer();
            },
            get theme() {
              return props7.theme;
            },
            avatarSrc
          });
        }
      }), createComponent(Match, {
        get when() {
          return isNotDefined(answer()) || props7.hasError;
        },
        get children() {
          var _el$ = _tmpl$70(), _el$2 = _el$.firstChild;
          var _ref$ = props7.ref;
          typeof _ref$ === "function" ? use(_ref$, _el$) : props7.ref = _el$;
          _el$.style.setProperty("border-top", "1px solid #ebebeb");
          _el$.style.setProperty("position", "absolute");
          _el$.style.setProperty("bottom", "8px");
          _el$.style.setProperty("width", "96%");
          _el$.style.setProperty("padding-top", "6px");
          _el$.style.setProperty("justify-self", "anchor-center");
          _el$2.style.setProperty("padding", "10px");
          _el$2.style.setProperty("border-radius", "20px");
          _el$2.style.setProperty("flex", "1");
          insert(_el$2, createComponent(Input, {
            get context() {
              return props7.context;
            },
            get block() {
              return props7.block;
            },
            get chunkIndex() {
              return props7.chunkIndex;
            },
            get isInputPrefillEnabled() {
              return props7.isInputPrefillEnabled;
            },
            get existingAnswer() {
              return createMemo(() => !!props7.hasError)() ? getAnswerValue(answer()) : void 0;
            },
            get onTransitionEnd() {
              return props7.onTransitionEnd;
            },
            onSubmit: handleSubmit,
            onSkip: handleSkip
          }));
          createRenderEffect((_p$) => {
            var _v$ = props7.block.id, _v$2 = props7.context.typebot.theme.chat?.inputs?.backgroundColor;
            _v$ !== _p$.e && setAttribute(_el$, "data-blockid", _p$.e = _v$);
            _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$2.style.setProperty("background", _v$2) : _el$2.style.removeProperty("background"));
            return _p$;
          }, {
            e: void 0,
            t: void 0
          });
          return _el$;
        }
      })];
    }
  });
};
var getAnswerValue = (answer) => {
  if (!answer) return;
  return answer.type === "text" ? answer.value : answer.url;
};
var Input = (props7) => {
  const getPrefilledValue = () => props7.existingAnswer ?? (props7.isInputPrefillEnabled ? props7.block.prefilledValue : void 0);
  const submitPaymentSuccess = () => props7.onSubmit({
    type: "text",
    value: props7.block.options?.labels?.success ?? defaultPaymentInputOptions.labels.success
  });
  return createComponent(Switch, {
    get children() {
      return [createComponent(Match, {
        get when() {
          return props7.block.type === "text input" /* TEXT */;
        },
        get children() {
          return createComponent(TextInput, {
            get block() {
              return props7.block;
            },
            get defaultValue() {
              return getPrefilledValue();
            },
            get context() {
              return props7.context;
            },
            get onSubmit() {
              return props7.onSubmit;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "number input" /* NUMBER */;
        },
        get children() {
          return createComponent(NumberInput, {
            get block() {
              return props7.block;
            },
            get defaultValue() {
              return getPrefilledValue();
            },
            get onSubmit() {
              return props7.onSubmit;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "email input" /* EMAIL */;
        },
        get children() {
          return createComponent(EmailInput, {
            get block() {
              return props7.block;
            },
            get defaultValue() {
              return getPrefilledValue();
            },
            get onSubmit() {
              return props7.onSubmit;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "url input" /* URL */;
        },
        get children() {
          return createComponent(UrlInput, {
            get block() {
              return props7.block;
            },
            get defaultValue() {
              return getPrefilledValue();
            },
            get onSubmit() {
              return props7.onSubmit;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "phone number input" /* PHONE */;
        },
        get children() {
          return createComponent(PhoneInput, {
            get labels() {
              return props7.block.options?.labels;
            },
            get defaultCountryCode() {
              return props7.block.options?.defaultCountryCode;
            },
            get defaultValue() {
              return getPrefilledValue();
            },
            get onSubmit() {
              return props7.onSubmit;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "date input" /* DATE */;
        },
        get children() {
          return createComponent(DateForm, {
            get options() {
              return props7.block.options;
            },
            get defaultValue() {
              return getPrefilledValue();
            },
            get onSubmit() {
              return props7.onSubmit;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "time input" /* TIME */;
        },
        get children() {
          return createComponent(TimeForm, {
            get block() {
              return props7.block;
            },
            get defaultValue() {
              return getPrefilledValue();
            },
            get onSubmit() {
              return props7.onSubmit;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return isButtonsBlock(props7.block);
        },
        keyed: true,
        children: (block2) => createComponent(Switch, {
          get children() {
            return [createComponent(Match, {
              get when() {
                return !block2.options?.isMultipleChoice;
              },
              get children() {
                return createComponent(Buttons, {
                  get chunkIndex() {
                    return props7.chunkIndex;
                  },
                  get defaultItems() {
                    return block2.items;
                  },
                  get options() {
                    return block2.options;
                  },
                  get onSubmit() {
                    return props7.onSubmit;
                  }
                });
              }
            }), createComponent(Match, {
              get when() {
                return block2.options?.isMultipleChoice;
              },
              get children() {
                return createComponent(MultipleChoicesForm, {
                  get defaultItems() {
                    return block2.items;
                  },
                  get options() {
                    return block2.options;
                  },
                  get onSubmit() {
                    return props7.onSubmit;
                  }
                });
              }
            })];
          }
        })
      }), createComponent(Match, {
        get when() {
          return isPictureChoiceBlock(props7.block);
        },
        keyed: true,
        children: (block2) => createComponent(Switch, {
          get children() {
            return [createComponent(Match, {
              get when() {
                return !block2.options?.isMultipleChoice;
              },
              get children() {
                return createComponent(SinglePictureChoice, {
                  get defaultItems() {
                    return block2.items;
                  },
                  get options() {
                    return block2.options;
                  },
                  get onSubmit() {
                    return props7.onSubmit;
                  },
                  get onTransitionEnd() {
                    return props7.onTransitionEnd;
                  }
                });
              }
            }), createComponent(Match, {
              get when() {
                return block2.options?.isMultipleChoice;
              },
              get children() {
                return createComponent(MultiplePictureChoice, {
                  get defaultItems() {
                    return block2.items;
                  },
                  get options() {
                    return block2.options;
                  },
                  get onSubmit() {
                    return props7.onSubmit;
                  },
                  get onTransitionEnd() {
                    return props7.onTransitionEnd;
                  }
                });
              }
            })];
          }
        })
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "rating input" /* RATING */;
        },
        get children() {
          return createComponent(RatingForm, {
            get block() {
              return props7.block;
            },
            get defaultValue() {
              return getPrefilledValue();
            },
            get onSubmit() {
              return props7.onSubmit;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "file input" /* FILE */;
        },
        get children() {
          return createComponent(FileUploadForm, {
            get context() {
              return props7.context;
            },
            get block() {
              return props7.block;
            },
            get onSubmit() {
              return props7.onSubmit;
            },
            get onSkip() {
              return props7.onSkip;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "payment input" /* PAYMENT */;
        },
        get children() {
          return createComponent(PaymentForm, {
            get context() {
              return props7.context;
            },
            get options() {
              return {
                ...props7.block.options,
                ...props7.block.runtimeOptions
              };
            },
            onSuccess: submitPaymentSuccess,
            get onTransitionEnd() {
              return props7.onTransitionEnd;
            }
          });
        }
      }), createComponent(Match, {
        get when() {
          return props7.block.type === "cards" /* CARDS */;
        },
        get children() {
          return createComponent(CardsCaroussel, {
            get block() {
              return props7.block;
            },
            get onSubmit() {
              return props7.onSubmit;
            },
            get onTransitionEnd() {
              return props7.onTransitionEnd;
            }
          });
        }
      })];
    }
  });
};
var isButtonsBlock = (block2) => block2?.type === "choice input" /* CHOICE */ ? block2 : void 0;
var isPictureChoiceBlock = (block2) => block2?.type === "picture choice input" /* PICTURE_CHOICE */ ? block2 : void 0;

// src/components/TypingBubble.tsx
var _tmpl$71 = /* @__PURE__ */ template(`<div class="flex items-center gap-1"><div class="w-2 h-2 rounded-full bubble1"></div><div class="w-2 h-2 rounded-full bubble2"></div><div class="w-2 h-2 rounded-full bubble3">`);
var TypingBubble = () => _tmpl$71();

// ../../blocks/bubbles/src/audio/constants.ts
var defaultAudioBubbleContent = {
  isAutoplayEnabled: true
};

// src/features/blocks/bubbles/audio/components/AudioBubble.tsx
var _tmpl$76 = /* @__PURE__ */ template(`<div><div class="flex w-full items-center"><div class="flex relative z-10 items-start typebot-host-bubble max-w-full"><div class="flex items-center absolute px-4 py-2 bubble-typing z-10 "></div><audio controls>`);
var showAnimationDuration = 400;
var typingDuration = 100;
var typingTimeout;
var AudioBubble = (props7) => {
  let isPlayed = false;
  let ref;
  let audioElement;
  const [isTyping, setIsTyping] = createSignal(props7.onTransitionEnd ? true : false);
  onMount(() => {
    typingTimeout = setTimeout(() => {
      if (isPlayed) return;
      isPlayed = true;
      setIsTyping(false);
      setTimeout(() => props7.onTransitionEnd?.(ref), showAnimationDuration);
    }, typingDuration);
  });
  onCleanup(() => {
    if (typingTimeout) clearTimeout(typingTimeout);
  });
  return (() => {
    var _el$ = _tmpl$76(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling;
    var _ref$ = ref;
    typeof _ref$ === "function" ? use(_ref$, _el$) : ref = _el$;
    insert(_el$4, (() => {
      var _c$ = createMemo(() => !!isTyping());
      return () => _c$() && createComponent(TypingBubble, {});
    })());
    var _ref$2 = audioElement;
    typeof _ref$2 === "function" ? use(_ref$2, _el$5) : audioElement = _el$5;
    createRenderEffect((_p$) => {
      var _v$ = cx("flex flex-col", props7.onTransitionEnd ? "animate-fade-in" : void 0), _v$2 = isTyping() ? "64px" : "100%", _v$3 = isTyping() ? "32px" : "100%", _v$4 = props7.content?.url, _v$5 = props7.onTransitionEnd ? props7.content?.isAutoplayEnabled ?? defaultAudioBubbleContent.isAutoplayEnabled : false, _v$6 = "z-10 text-fade-in " + (isTyping() ? "opacity-0" : "opacity-100 m-2"), _v$7 = isTyping() ? isMobile() ? "32px" : "36px" : "revert";
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$4.style.setProperty("width", _v$2) : _el$4.style.removeProperty("width"));
      _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$4.style.setProperty("height", _v$3) : _el$4.style.removeProperty("height"));
      _v$4 !== _p$.o && setAttribute(_el$5, "src", _p$.o = _v$4);
      _v$5 !== _p$.i && (_el$5.autoplay = _p$.i = _v$5);
      _v$6 !== _p$.n && className(_el$5, _p$.n = _v$6);
      _v$7 !== _p$.s && ((_p$.s = _v$7) != null ? _el$5.style.setProperty("height", _v$7) : _el$5.style.removeProperty("height"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0,
      n: void 0,
      s: void 0
    });
    return _el$;
  })();
};

// src/features/blocks/bubbles/embed/components/CustomEmbedBubble.tsx
var _tmpl$77 = /* @__PURE__ */ template(`<div><div class="flex w-full items-center"><div class="flex relative z-10 items-start typebot-host-bubble w-full max-w-full"><div class="flex items-center absolute px-4 py-2 bubble-typing z-10 "></div><div><div class="w-full overflow-y-auto">`);
var typingTimeout2;
var showAnimationDuration2 = 400;
var CustomEmbedBubble = (props7) => {
  let ref;
  const [isTyping, setIsTyping] = createSignal(props7.onTransitionEnd ? true : false);
  let containerRef;
  onMount(() => {
    executeCode({
      args: {
        ...props7.content.initFunction.args,
        typebotElement: containerRef
      },
      content: props7.content.initFunction.content
    });
    if (props7.content.waitForEventFunction) executeCode({
      args: {
        ...props7.content.waitForEventFunction.args,
        continueFlow: (text2) => props7.onCompleted(text2 ? {
          type: "text",
          value: text2
        } : void 0)
      },
      content: props7.content.waitForEventFunction.content
    });
    typingTimeout2 = setTimeout(() => {
      setIsTyping(false);
      setTimeout(() => props7.onTransitionEnd?.(ref), showAnimationDuration2);
    }, 2e3);
  });
  onCleanup(() => {
    if (typingTimeout2) clearTimeout(typingTimeout2);
  });
  return (() => {
    var _el$ = _tmpl$77(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$5.firstChild;
    var _ref$ = ref;
    typeof _ref$ === "function" ? use(_ref$, _el$) : ref = _el$;
    insert(_el$4, (() => {
      var _c$ = createMemo(() => !!isTyping());
      return () => _c$() && createComponent(TypingBubble, {});
    })());
    var _ref$2 = containerRef;
    typeof _ref$2 === "function" ? use(_ref$2, _el$6) : containerRef = _el$6;
    createRenderEffect((_p$) => {
      var _v$ = cx("flex flex-col w-full", props7.onTransitionEnd ? "animate-fade-in" : void 0), _v$2 = isTyping() ? "64px" : "100%", _v$3 = isTyping() ? "32px" : "100%", _v$4 = cx("p-2 z-20 text-fade-in w-full", isTyping() ? "opacity-0" : "opacity-100"), _v$5 = isTyping() ? isMobile() ? "32px" : "36px" : void 0, _v$6 = `calc(${botContainerHeight()} - 100px)`;
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$4.style.setProperty("width", _v$2) : _el$4.style.removeProperty("width"));
      _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$4.style.setProperty("height", _v$3) : _el$4.style.removeProperty("height"));
      _v$4 !== _p$.o && className(_el$5, _p$.o = _v$4);
      _v$5 !== _p$.i && ((_p$.i = _v$5) != null ? _el$5.style.setProperty("height", _v$5) : _el$5.style.removeProperty("height"));
      _v$6 !== _p$.n && ((_p$.n = _v$6) != null ? _el$6.style.setProperty("max-height", _v$6) : _el$6.style.removeProperty("max-height"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0,
      n: void 0
    });
    return _el$;
  })();
};

// ../../blocks/bubbles/src/embed/constants.ts
var defaultEmbedBubbleContent = {
  height: 400
};

// src/features/blocks/bubbles/embed/components/EmbedBubble.tsx
var _tmpl$78 = /* @__PURE__ */ template(`<div><div class="flex w-full items-center"><div class="flex relative z-10 items-start typebot-host-bubble w-full max-w-full"><div class="flex items-center absolute px-4 py-2 bubble-typing z-10 "></div><div><iframe id=embed-bubble-content class="w-full h-full ">`);
var typingTimeout3;
var showAnimationDuration3 = 400;
var EmbedBubble = (props7) => {
  let ref;
  const [isTyping, setIsTyping] = createSignal(props7.onTransitionEnd ? true : false);
  const handleMessage = (event) => {
    if (props7.content?.waitForEvent?.isEnabled && isNotEmpty(event.data.name) && event.data.name === props7.content?.waitForEvent.name) {
      props7.onCompleted?.(props7.content.waitForEvent.saveDataInVariableId && event.data.data ? {
        type: "text",
        value: event.data.data
      } : void 0);
      window.removeEventListener("message", handleMessage);
    }
  };
  onMount(() => {
    typingTimeout3 = setTimeout(() => {
      setIsTyping(false);
      if (props7.content?.waitForEvent?.isEnabled) {
        window.addEventListener("message", handleMessage);
      }
      setTimeout(() => {
        props7.onTransitionEnd?.(ref);
      }, showAnimationDuration3);
    }, 2e3);
  });
  onCleanup(() => {
    if (typingTimeout3) clearTimeout(typingTimeout3);
    window.removeEventListener("message", handleMessage);
  });
  return (() => {
    var _el$ = _tmpl$78(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$5.firstChild;
    var _ref$ = ref;
    typeof _ref$ === "function" ? use(_ref$, _el$) : ref = _el$;
    insert(_el$4, (() => {
      var _c$ = createMemo(() => !!isTyping());
      return () => _c$() && createComponent(TypingBubble, {});
    })());
    createRenderEffect((_p$) => {
      var _v$ = cx("flex flex-col w-full", props7.onTransitionEnd ? "animate-fade-in" : void 0), _v$2 = isTyping() ? "64px" : "100%", _v$3 = isTyping() ? "32px" : "100%", _v$4 = cx("p-4 z-20 text-fade-in w-full", isTyping() ? "opacity-0" : "opacity-100 p-4"), _v$5 = isTyping() ? isMobile() ? "32px" : "36px" : `${props7.content?.height ?? defaultEmbedBubbleContent.height}px`, _v$6 = props7.content?.url;
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$4.style.setProperty("width", _v$2) : _el$4.style.removeProperty("width"));
      _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$4.style.setProperty("height", _v$3) : _el$4.style.removeProperty("height"));
      _v$4 !== _p$.o && className(_el$5, _p$.o = _v$4);
      _v$5 !== _p$.i && ((_p$.i = _v$5) != null ? _el$5.style.setProperty("height", _v$5) : _el$5.style.removeProperty("height"));
      _v$6 !== _p$.n && setAttribute(_el$6, "src", _p$.n = _v$6);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0,
      n: void 0
    });
    return _el$;
  })();
};

// ../../blocks/bubbles/src/image/constants.ts
var defaultImageBubbleContent = {
  clickLink: {
    alt: "Bubble image"
  }
};

// src/features/blocks/bubbles/image/components/ImageBubble.tsx
var _tmpl$79 = /* @__PURE__ */ template(`<img elementtiming="Bubble image"fetchpriority=high>`);
var _tmpl$219 = /* @__PURE__ */ template(`<img class="max-h-[calc(100vh-1rem)] max-w-[calc(100%-1rem)] rounded-[6px] m-auto">`);
var _tmpl$317 = /* @__PURE__ */ template(`<div><div class="flex w-full items-center"><div class="flex relative z-10 items-start typebot-host-bubble max-w-full"><div class="flex items-center absolute px-4 py-2 bubble-typing z-10 ">`);
var _tmpl$412 = /* @__PURE__ */ template(`<a target=_blank rel=noreferrer>`);
var _tmpl$511 = /* @__PURE__ */ template(`<figure>`);
var showAnimationDuration4 = 400;
var mediaLoadingFallbackTimeout = 5e3;
var typingTimeout4;
var ImageBubble = (props7) => {
  let ref;
  let image;
  const [isExpanded, setIsExpanded] = createSignal(false);
  const [isTyping, setIsTyping] = createSignal(props7.onTransitionEnd ? true : false);
  const onTypingEnd = () => {
    if (!isTyping()) return;
    setIsTyping(false);
    setTimeout(() => {
      props7.onTransitionEnd?.(ref);
    }, showAnimationDuration4);
  };
  onMount(() => {
    if (!image) return;
    typingTimeout4 = setTimeout(onTypingEnd, mediaLoadingFallbackTimeout);
    image.onload = () => {
      clearTimeout(typingTimeout4);
      onTypingEnd();
    };
  });
  onCleanup(() => {
    if (typingTimeout4) clearTimeout(typingTimeout4);
  });
  const openModal = () => {
    setIsExpanded(true);
  };
  const closeModal = () => {
    setIsExpanded(false);
  };
  const Image = (() => {
    var _el$ = _tmpl$79();
    var _ref$ = image;
    typeof _ref$ === "function" ? use(_ref$, _el$) : image = _el$;
    createRenderEffect((_p$) => {
      var _v$ = props7.content?.url, _v$2 = props7.content?.clickLink?.alt ?? defaultImageBubbleContent.clickLink.alt, _v$3 = cx(isTyping() ? "opacity-0" : "opacity-100", props7.onTransitionEnd ? "text-fade-in" : void 0, props7.content?.url?.endsWith(".svg") ? "w-full" : void 0), _v$4 = props7.content?.url?.startsWith("data:image/svg") ? "100%" : void 0, _v$5 = props7.content?.url?.startsWith("data:image/svg") ? "120px" : "512px", _v$6 = isTyping() ? "32px" : "auto";
      _v$ !== _p$.e && setAttribute(_el$, "src", _p$.e = _v$);
      _v$2 !== _p$.t && setAttribute(_el$, "alt", _p$.t = _v$2);
      _v$3 !== _p$.a && className(_el$, _p$.a = _v$3);
      _v$4 !== _p$.o && ((_p$.o = _v$4) != null ? _el$.style.setProperty("width", _v$4) : _el$.style.removeProperty("width"));
      _v$5 !== _p$.i && ((_p$.i = _v$5) != null ? _el$.style.setProperty("max-height", _v$5) : _el$.style.removeProperty("max-height"));
      _v$6 !== _p$.n && ((_p$.n = _v$6) != null ? _el$.style.setProperty("height", _v$6) : _el$.style.removeProperty("height"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0,
      n: void 0
    });
    return _el$;
  })();
  return (() => {
    var _el$2 = _tmpl$317(), _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild;
    var _ref$2 = ref;
    typeof _ref$2 === "function" ? use(_ref$2, _el$2) : ref = _el$2;
    insert(_el$5, (() => {
      var _c$ = createMemo(() => !!isTyping());
      return () => _c$() ? createComponent(TypingBubble, {}) : null;
    })());
    insert(_el$4, (() => {
      var _c$2 = createMemo(() => !!props7.content?.clickLink);
      return () => _c$2() ? (() => {
        var _el$7 = _tmpl$412();
        insert(_el$7, Image);
        createRenderEffect((_p$) => {
          var _v$12 = props7.content.clickLink.url, _v$13 = cx("z-10", isTyping() ? "h-8" : "p-4");
          _v$12 !== _p$.e && setAttribute(_el$7, "href", _p$.e = _v$12);
          _v$13 !== _p$.t && className(_el$7, _p$.t = _v$13);
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$7;
      })() : (() => {
        var _el$8 = _tmpl$511();
        addEventListener(_el$8, "click", props7.content?.url?.startsWith("data:image/svg") ? void 0 : openModal);
        insert(_el$8, Image);
        createRenderEffect(() => className(_el$8, cx("z-10 cursor-pointer", !isTyping() && "p-4", isTyping() ? isMobile() ? "h-8" : "h-9" : "")));
        return _el$8;
      })();
    })(), null);
    insert(_el$2, createComponent(Modal, {
      get isOpen() {
        return isExpanded();
      },
      onClose: closeModal,
      get children() {
        var _el$6 = _tmpl$219();
        createRenderEffect((_p$) => {
          var _v$7 = props7.content?.url, _v$8 = props7.content?.clickLink?.alt ?? defaultImageBubbleContent.clickLink.alt;
          _v$7 !== _p$.e && setAttribute(_el$6, "src", _p$.e = _v$7);
          _v$8 !== _p$.t && setAttribute(_el$6, "alt", _p$.t = _v$8);
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$6;
      }
    }), null);
    createRenderEffect((_p$) => {
      var _v$9 = cx("flex flex-col", props7.onTransitionEnd ? "animate-fade-in" : void 0), _v$10 = isTyping() ? "64px" : "100%", _v$11 = isTyping() ? "32px" : "100%";
      _v$9 !== _p$.e && className(_el$2, _p$.e = _v$9);
      _v$10 !== _p$.t && ((_p$.t = _v$10) != null ? _el$5.style.setProperty("width", _v$10) : _el$5.style.removeProperty("width"));
      _v$11 !== _p$.a && ((_p$.a = _v$11) != null ? _el$5.style.setProperty("height", _v$11) : _el$5.style.removeProperty("height"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$2;
  })();
};

// ../../settings/src/computeTypingDuration.ts
var computeTypingDuration = ({
  bubbleContent,
  typingSettings
}) => {
  let wordCount = bubbleContent.match(/(\w+)/g)?.length ?? 0;
  if (wordCount === 0) wordCount = bubbleContent.length;
  const { enabled, speed, maxDelay } = {
    enabled: typingSettings?.enabled ?? defaultSettings.typingEmulation.enabled,
    speed: typingSettings?.speed ?? defaultSettings.typingEmulation.speed,
    maxDelay: typingSettings?.maxDelay ?? defaultSettings.typingEmulation.maxDelay
  };
  const typedWordsPerMinute = speed;
  let typingTimeout7 = enabled ? wordCount / typedWordsPerMinute * 6e4 : 0;
  if (typingTimeout7 > maxDelay * 1e3) typingTimeout7 = maxDelay * 1e3;
  return typingTimeout7;
};

// src/features/blocks/bubbles/textBubble/helpers/convertRichTextToPlainText.ts
var computePlainText = (elements2) => elements2.map(
  (element) => element.text ?? computePlainText(element.children)
).join("");

// src/features/blocks/bubbles/textBubble/components/plate/PlateText.tsx
var _tmpl$80 = /* @__PURE__ */ template(`<br>`);
var _tmpl$220 = /* @__PURE__ */ template(`<span>`);
var computeClassNames = (bold, italic, underline) => {
  let className2 = "";
  if (bold) className2 += "slate-bold";
  if (italic) className2 += " slate-italic";
  if (underline) className2 += " slate-underline";
  return className2;
};
var PlateText = (props7) => (() => {
  var _el$ = _tmpl$220();
  insert(_el$, () => props7.text, null);
  insert(_el$, createComponent(Show, {
    get when() {
      return createMemo(() => !!props7.isUniqueChild)() && isEmpty(props7.text);
    },
    get children() {
      return _tmpl$80();
    }
  }), null);
  createRenderEffect(() => className(_el$, computeClassNames(props7.bold, props7.italic, props7.underline)));
  return _el$;
})();

// src/features/blocks/bubbles/textBubble/components/plate/PlateBlock.tsx
var _tmpl$81 = /* @__PURE__ */ template(`<a target=_blank rel="noopener noreferrer">`);
var _tmpl$221 = /* @__PURE__ */ template(`<ol>`);
var _tmpl$318 = /* @__PURE__ */ template(`<ul>`);
var _tmpl$413 = /* @__PURE__ */ template(`<li>`);
var _tmpl$512 = /* @__PURE__ */ template(`<span>`);
var _tmpl$611 = /* @__PURE__ */ template(`<div>`);
var PlateElement = (props7) => createComponent(Switch, {
  get children() {
    return [createComponent(Match, {
      get when() {
        return isDefined(props7.element.text);
      },
      get children() {
        return createComponent(PlateText, mergeProps(() => props7.element, {
          get isUniqueChild() {
            return props7.isUniqueChild ?? false;
          }
        }));
      }
    }), createComponent(Match, {
      when: true,
      get children() {
        return createComponent(Switch, {
          get children() {
            return [createComponent(Match, {
              get when() {
                return props7.element.type === "a";
              },
              get children() {
                var _el$ = _tmpl$81();
                insert(_el$, createComponent(For, {
                  get each() {
                    return props7.element.children;
                  },
                  children: (child) => createComponent(PlateElement, {
                    element: child,
                    get isUniqueChild() {
                      return props7.element.children?.length === 1;
                    }
                  })
                }));
                createRenderEffect(() => setAttribute(_el$, "href", props7.element.url));
                return _el$;
              }
            }), createComponent(Match, {
              get when() {
                return props7.element.type === "ol";
              },
              get children() {
                var _el$2 = _tmpl$221();
                insert(_el$2, createComponent(For, {
                  get each() {
                    return props7.element.children;
                  },
                  children: (child) => createComponent(PlateElement, {
                    element: child,
                    get isUniqueChild() {
                      return props7.element.children?.length === 1;
                    }
                  })
                }));
                return _el$2;
              }
            }), createComponent(Match, {
              get when() {
                return props7.element.type === "ul";
              },
              get children() {
                var _el$3 = _tmpl$318();
                insert(_el$3, createComponent(For, {
                  get each() {
                    return props7.element.children;
                  },
                  children: (child) => createComponent(PlateElement, {
                    element: child,
                    get isUniqueChild() {
                      return props7.element.children?.length === 1;
                    }
                  })
                }));
                return _el$3;
              }
            }), createComponent(Match, {
              get when() {
                return props7.element.type === "li";
              },
              get children() {
                var _el$4 = _tmpl$413();
                insert(_el$4, createComponent(For, {
                  get each() {
                    return props7.element.children;
                  },
                  children: (child) => createComponent(PlateElement, {
                    element: child,
                    get isUniqueChild() {
                      return props7.element.children?.length === 1;
                    }
                  })
                }));
                return _el$4;
              }
            }), createComponent(Match, {
              when: true,
              get children() {
                return createComponent(ElementRoot, {
                  get element() {
                    return props7.element;
                  },
                  get insideInlineVariable() {
                    return props7.insideInlineVariable ?? false;
                  },
                  get children() {
                    return createComponent(For, {
                      get each() {
                        return props7.element.children;
                      },
                      children: (child) => createComponent(PlateElement, {
                        element: child,
                        get isUniqueChild() {
                          return props7.element.children?.length === 1;
                        },
                        get insideInlineVariable() {
                          return props7.element.type === "inline-variable";
                        }
                      })
                    });
                  }
                });
              }
            })];
          }
        });
      }
    })];
  }
});
var ElementRoot = (props7) => {
  return createComponent(Switch, {
    get children() {
      return [createComponent(Match, {
        get when() {
          return props7.element.type === "inline-variable" || props7.insideInlineVariable;
        },
        get children() {
          var _el$5 = _tmpl$512();
          insert(_el$5, () => props7.children);
          createRenderEffect(() => setAttribute(_el$5, "data-element-type", props7.element.type));
          return _el$5;
        }
      }), createComponent(Match, {
        when: true,
        get children() {
          var _el$6 = _tmpl$611();
          insert(_el$6, () => props7.children);
          createRenderEffect(() => setAttribute(_el$6, "data-element-type", props7.element.type));
          return _el$6;
        }
      })];
    }
  });
};

// src/features/blocks/bubbles/textBubble/components/TextBubble.tsx
var _tmpl$83 = /* @__PURE__ */ template(`<div><div class="flex w-full items-center"><div class="flex relative items-start typebot-host-bubble max-w-full"><div class="flex items-center absolute px-4 py-2 bubble-typing "data-testid=host-bubble></div><div>`);
var showAnimationDuration5 = 400;
var typingTimeout5;
var TextBubble = (props7) => {
  let ref;
  const [isTyping, setIsTyping] = createSignal(props7.onTransitionEnd ? true : false);
  const onTypingEnd = () => {
    if (!isTyping()) return;
    setIsTyping(false);
    setTimeout(() => {
      props7.onTransitionEnd?.(ref);
    }, showAnimationDuration5);
  };
  onMount(() => {
    if (!isTyping) return;
    const plainText = props7.content?.richText ? computePlainText(props7.content.richText) : "";
    const typingDuration2 = props7.typingEmulation?.enabled === false || props7.isTypingSkipped ? 0 : computeTypingDuration({
      bubbleContent: plainText,
      typingSettings: props7.typingEmulation
    });
    typingTimeout5 = setTimeout(onTypingEnd, typingDuration2);
  });
  onCleanup(() => {
    if (typingTimeout5) clearTimeout(typingTimeout5);
  });
  return (() => {
    var _el$ = _tmpl$83(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling;
    var _ref$ = ref;
    typeof _ref$ === "function" ? use(_ref$, _el$) : ref = _el$;
    insert(_el$4, (() => {
      var _c$ = createMemo(() => !!isTyping());
      return () => _c$() && createComponent(TypingBubble, {});
    })());
    insert(_el$5, createComponent(For, {
      get each() {
        return props7.content?.richText;
      },
      children: (element) => createComponent(PlateElement, {
        element
      })
    }));
    createRenderEffect((_p$) => {
      var _v$ = cx("flex flex-col", props7.onTransitionEnd ? "animate-fade-in" : void 0), _v$2 = isTyping() ? "64px" : "100%", _v$3 = isTyping() ? "32px" : "100%", _v$4 = cx("overflow-hidden text-fade-in mx-4 my-2 whitespace-pre-wrap slate-html-container relative text-ellipsis", isTyping() ? "opacity-0" : "opacity-100"), _v$5 = isTyping() ? isMobile() ? "16px" : "20px" : "100%";
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$4.style.setProperty("width", _v$2) : _el$4.style.removeProperty("width"));
      _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$4.style.setProperty("height", _v$3) : _el$4.style.removeProperty("height"));
      _v$4 !== _p$.o && className(_el$5, _p$.o = _v$4);
      _v$5 !== _p$.i && ((_p$.i = _v$5) != null ? _el$5.style.setProperty("height", _v$5) : _el$5.style.removeProperty("height"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0,
      i: void 0
    });
    return _el$;
  })();
};

// ../../blocks/bubbles/src/video/constants.ts
var embeddableVideoTypes = [
  "youtube" /* YOUTUBE */,
  "vimeo" /* VIMEO */,
  "tiktok" /* TIKTOK */,
  "gumlet" /* GUMLET */
];
var defaultVideoBubbleContent = {
  height: 400,
  aspectRatio: "16/9",
  maxWidth: "100%",
  areControlsDisplayed: true,
  isAutoplayEnabled: true
};
var youtubeBaseUrl = "https://www.youtube.com/embed";
var vimeoBaseUrl = "https://player.vimeo.com/video";
var tiktokBaseUrl = "https://www.tiktok.com/embed/v2";
var gumletBaseUrl = "https://play.gumlet.io/embed";
var embedBaseUrls = {
  ["vimeo" /* VIMEO */]: vimeoBaseUrl,
  ["youtube" /* YOUTUBE */]: youtubeBaseUrl,
  ["tiktok" /* TIKTOK */]: tiktokBaseUrl,
  ["gumlet" /* GUMLET */]: gumletBaseUrl
};

// ../../blocks/bubbles/src/video/helpers.ts
var parseQueryParams = (content) => {
  if (!(content?.isAutoplayEnabled ?? defaultVideoBubbleContent.isAutoplayEnabled))
    return "";
  if (content?.type === "youtube" /* YOUTUBE */ || content?.type === "vimeo" /* VIMEO */) {
    return "autoplay=1";
  }
  if (content?.type === "gumlet" /* GUMLET */) {
    return "autoplay=true";
  }
  return "";
};

// src/features/blocks/bubbles/video/components/VideoBubble.tsx
var _tmpl$84 = /* @__PURE__ */ template(`<video>`);
var _tmpl$222 = /* @__PURE__ */ template(`<div><iframe class="w-full h-full"allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"allowfullscreen>`);
var _tmpl$319 = /* @__PURE__ */ template(`<div><div class="flex w-full items-center"><div class="flex relative z-10 items-start typebot-host-bubble overflow-hidden w-full max-w-full"><div class="flex items-center absolute px-4 py-2 bubble-typing z-10 ">`);
var showAnimationDuration6 = 400;
var typingTimeout6;
var VideoBubble = (props7) => {
  let ref;
  const [isTyping, setIsTyping] = createSignal(props7.onTransitionEnd ? true : false);
  onMount(() => {
    const typingDuration2 = props7.content?.type && embeddableVideoTypes.includes(props7.content?.type) ? 2e3 : 100;
    typingTimeout6 = setTimeout(() => {
      if (!isTyping()) return;
      setIsTyping(false);
      setTimeout(() => {
        props7.onTransitionEnd?.(ref);
      }, showAnimationDuration6);
    }, typingDuration2);
  });
  onCleanup(() => {
    if (typingTimeout6) clearTimeout(typingTimeout6);
  });
  return (() => {
    var _el$ = _tmpl$319(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild;
    var _ref$ = ref;
    typeof _ref$ === "function" ? use(_ref$, _el$) : ref = _el$;
    insert(_el$4, (() => {
      var _c$ = createMemo(() => !!isTyping());
      return () => _c$() && createComponent(TypingBubble, {});
    })());
    insert(_el$3, createComponent(Switch, {
      get children() {
        return [createComponent(Match, {
          get when() {
            return props7.content?.type && props7.content.type === "url" /* URL */;
          },
          get children() {
            var _el$5 = _tmpl$84();
            createRenderEffect((_p$) => {
              var _v$ = props7.onTransitionEnd ? props7.content?.isAutoplayEnabled ?? defaultVideoBubbleContent.isAutoplayEnabled : false, _v$2 = props7.content?.url, _v$3 = props7.content?.areControlsDisplayed ?? defaultVideoBubbleContent.areControlsDisplayed, _v$4 = "p-4 focus:outline-none w-full z-10 text-fade-in rounded-md " + (isTyping() ? "opacity-0" : "opacity-100"), _v$5 = isTyping() ? isMobile() ? "32px" : "36px" : "auto", _v$6 = props7.content?.aspectRatio, _v$7 = props7.content?.maxWidth ?? defaultVideoBubbleContent.maxWidth;
              _v$ !== _p$.e && (_el$5.autoplay = _p$.e = _v$);
              _v$2 !== _p$.t && setAttribute(_el$5, "src", _p$.t = _v$2);
              _v$3 !== _p$.a && (_el$5.controls = _p$.a = _v$3);
              _v$4 !== _p$.o && className(_el$5, _p$.o = _v$4);
              _v$5 !== _p$.i && ((_p$.i = _v$5) != null ? _el$5.style.setProperty("height", _v$5) : _el$5.style.removeProperty("height"));
              _v$6 !== _p$.n && ((_p$.n = _v$6) != null ? _el$5.style.setProperty("aspect-ratio", _v$6) : _el$5.style.removeProperty("aspect-ratio"));
              _v$7 !== _p$.s && ((_p$.s = _v$7) != null ? _el$5.style.setProperty("max-width", _v$7) : _el$5.style.removeProperty("max-width"));
              return _p$;
            }, {
              e: void 0,
              t: void 0,
              a: void 0,
              o: void 0,
              i: void 0,
              n: void 0,
              s: void 0
            });
            return _el$5;
          }
        }), createComponent(Match, {
          get when() {
            return createMemo(() => !!props7.content?.type)() && embeddableVideoTypes.includes(props7.content.type);
          },
          get children() {
            var _el$6 = _tmpl$222(), _el$7 = _el$6.firstChild;
            createRenderEffect((_p$) => {
              var _v$8 = cx("p-4 z-10 text-fade-in w-full", isTyping() ? "opacity-0" : "opacity-100 p-4"), _v$9 = isTyping() ? isMobile() ? "32px" : "36px" : !props7.content?.aspectRatio ? `${props7.content?.height ?? defaultVideoBubbleContent.height}px` : void 0, _v$10 = props7.content?.aspectRatio, _v$11 = props7.content?.maxWidth ?? defaultVideoBubbleContent.maxWidth, _v$12 = `${embedBaseUrls[props7.content?.type]}/${props7.content?.id ?? ""}${props7.content?.queryParamsStr ?? `?${parseQueryParams(props7.content)}`}`;
              _v$8 !== _p$.e && className(_el$6, _p$.e = _v$8);
              _v$9 !== _p$.t && ((_p$.t = _v$9) != null ? _el$6.style.setProperty("height", _v$9) : _el$6.style.removeProperty("height"));
              _v$10 !== _p$.a && ((_p$.a = _v$10) != null ? _el$6.style.setProperty("aspect-ratio", _v$10) : _el$6.style.removeProperty("aspect-ratio"));
              _v$11 !== _p$.o && ((_p$.o = _v$11) != null ? _el$6.style.setProperty("max-width", _v$11) : _el$6.style.removeProperty("max-width"));
              _v$12 !== _p$.i && setAttribute(_el$7, "src", _p$.i = _v$12);
              return _p$;
            }, {
              e: void 0,
              t: void 0,
              a: void 0,
              o: void 0,
              i: void 0
            });
            return _el$6;
          }
        })];
      }
    }), null);
    createRenderEffect((_p$) => {
      var _v$13 = cx("flex flex-col w-full", props7.onTransitionEnd ? "animate-fade-in" : void 0), _v$14 = isTyping() ? "64px" : "100%", _v$15 = isTyping() ? "32px" : "100%", _v$16 = props7.content?.maxWidth ?? defaultVideoBubbleContent.maxWidth;
      _v$13 !== _p$.e && className(_el$, _p$.e = _v$13);
      _v$14 !== _p$.t && ((_p$.t = _v$14) != null ? _el$4.style.setProperty("width", _v$14) : _el$4.style.removeProperty("width"));
      _v$15 !== _p$.a && ((_p$.a = _v$15) != null ? _el$4.style.setProperty("height", _v$15) : _el$4.style.removeProperty("height"));
      _v$16 !== _p$.o && ((_p$.o = _v$16) != null ? _el$4.style.setProperty("max-width", _v$16) : _el$4.style.removeProperty("max-width"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0
    });
    return _el$;
  })();
};

// src/components/bubbles/HostBubble.tsx
var HostBubble = (props7) => createComponent(Switch, {
  get children() {
    return [createComponent(Match, {
      get when() {
        return props7.message.type === "text" /* TEXT */;
      },
      get children() {
        return createComponent(TextBubble, {
          get content() {
            return props7.message.content;
          },
          get isTypingSkipped() {
            return props7.isTypingSkipped;
          },
          get typingEmulation() {
            return props7.typingEmulation;
          },
          get onTransitionEnd() {
            return props7.onTransitionEnd;
          }
        });
      }
    }), createComponent(Match, {
      get when() {
        return props7.message.type === "image" /* IMAGE */;
      },
      get children() {
        return createComponent(ImageBubble, {
          get content() {
            return props7.message.content;
          },
          get onTransitionEnd() {
            return props7.onTransitionEnd;
          }
        });
      }
    }), createComponent(Match, {
      get when() {
        return props7.message.type === "video" /* VIDEO */;
      },
      get children() {
        return createComponent(VideoBubble, {
          get content() {
            return props7.message.content;
          },
          get onTransitionEnd() {
            return props7.onTransitionEnd;
          }
        });
      }
    }), createComponent(Match, {
      get when() {
        return props7.message.type === "embed" /* EMBED */;
      },
      get children() {
        return createComponent(EmbedBubble, {
          get content() {
            return props7.message.content;
          },
          get onTransitionEnd() {
            return props7.onTransitionEnd;
          },
          get onCompleted() {
            return props7.onCompleted;
          }
        });
      }
    }), createComponent(Match, {
      get when() {
        return props7.message.type === "custom-embed";
      },
      get children() {
        return createComponent(CustomEmbedBubble, {
          get content() {
            return props7.message.content;
          },
          get onTransitionEnd() {
            return props7.onTransitionEnd;
          },
          get onCompleted() {
            return props7.onCompleted;
          }
        });
      }
    }), createComponent(Match, {
      get when() {
        return props7.message.type === "audio" /* AUDIO */;
      },
      get children() {
        return createComponent(AudioBubble, {
          get content() {
            return props7.message.content;
          },
          get onTransitionEnd() {
            return props7.onTransitionEnd;
          }
        });
      }
    })];
  }
});

// ../../../node_modules/dompurify/dist/purify.es.mjs
var {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
var {
  freeze,
  seal,
  create
} = Object;
var {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new Func(...args);
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var arraySplice = unapply(Array.prototype.splice);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringToString = unapply(String.prototype.toString);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set2, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set2, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function cleanArray(array) {
  for (let index = 0; index < array.length; index++) {
    const isPropertyExist = objectHasOwnProperty(array, index);
    if (!isPropertyExist) {
      array[index] = null;
    }
  }
  return array;
}
function clone(object) {
  const newObject = create(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === "object" && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var DOCTYPE_NAME = seal(/^html$/i);
var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR,
  ATTR_WHITESPACE,
  CUSTOM_ELEMENT,
  DATA_ATTR,
  DOCTYPE_NAME,
  ERB_EXPR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR,
  TMPLIT_EXPR
});
var NODE_TYPE = {
  element: 1,
  attribute: 2,
  text: 3,
  cdataSection: 4,
  entityReference: 5,
  // Deprecated
  entityNode: 6,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9,
  documentType: 10,
  documentFragment: 11,
  notation: 12
  // Deprecated
};
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
var _createHooksMap = function _createHooksMap2() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.2.4";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document: document2
  } = window2;
  const originalDocument = document2;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node: Node2,
    Element: Element2,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window2;
  const ElementPrototype = Element2.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const remove2 = lookupGetter(ElementPrototype, "remove");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode4 = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template2 = document2.createElement("template");
    if (template2.content && template2.content.ownerDocument) {
      document2 = template2.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode4 === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2,
    CUSTOM_ELEMENT: CUSTOM_ELEMENT2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let SAFE_FOR_XML = true;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE2 = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE2, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc = null;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent2 = getParentNode4(element);
    if (!parent2 || !parent2.tagName) {
      parent2 = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent2.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE2) {
      if (parent2.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent2.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent2.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent2.namespaceURI === SVG_NAMESPACE2) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent2.namespaceURI === SVG_NAMESPACE2 && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent2.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      getParentNode4(node).removeChild(node);
    } catch (_) {
      remove2(node);
    }
  };
  const _removeAttribute = function _removeAttribute2(name, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name),
        from: element
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name);
    if (name === "is") {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_) {
        }
      } else {
        try {
          element.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createNodeIterator = function _createNodeIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
      null
    );
  };
  const _isClobbered = function _isClobbered2(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(value) {
    return typeof Node2 === "function" && value instanceof Node2;
  };
  function _executeHooks(hooks2, currentNode, data) {
    arrayForEach(hooks2, (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content = null;
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode4(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        content = stringReplace(content, expr, " ");
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      ) ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if (value) {
      return false;
    } else ;
    return true;
  };
  const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
    return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: void 0
    };
    let l = attributes.length;
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      let value = name === "value" ? attrValue : stringTrim(attrValue);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          value = stringReplace(value, expr, " ");
        });
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI) ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
        } else {
          arrayPop(DOMPurify.removed);
        }
      } catch (_) {
      }
    }
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      _sanitizeElements(shadowNode);
      _sanitizeAttributes(shadowNode);
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
    }
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      _sanitizeElements(currentNode);
      _sanitizeAttributes(currentNode);
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
        serializedHTML = stringReplace(serializedHTML, expr, " ");
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function() {
    let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint, hookFunction) {
    if (hookFunction !== void 0) {
      const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
      return index === -1 ? void 0 : arraySplice(hooks[entryPoint], index, 1)[0];
    }
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function(entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function() {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();

// ../../../node_modules/marked/lib/marked.esm.js
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html2, encode) {
  if (encode) {
    if (escapeTest.test(html2)) {
      return html2.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html2)) {
      return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html2;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html2) {
  return html2.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = typeof val === "object" && "source" in val ? val.source : val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
var noopTest = { exec: () => null };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match2, offset3, str) => {
    let escaped = false;
    let curr = offset3;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text: text2,
      tokens: lexer2.inlineTokens(text2)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text2)
  };
}
function indentCodeCompensation(raw, text2) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text2;
  }
  const indentToCode = matchIndentToCode[1];
  return text2.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var _Tokenizer = class {
  options;
  // TODO: Fix this rules type
  rules;
  lexer;
  constructor(options2) {
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text2, "\n") : text2
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text2 = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text: text2
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text2 = cap[2].trim();
      if (/#$/.test(text2)) {
        const trimmed = rtrim(text2, "#");
        if (this.options.pedantic) {
          text2 = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text2 = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text2 = cap[0].replace(/^ *>[ \t]?/gm, "");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text2);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text: text2
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let raw = "";
      let itemContents = "";
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        let blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimEnd();
      list.items[list.items.length - 1].text = itemContents.trimEnd();
      list.raw = list.raw.trimEnd();
      for (let i = 0; i < list.items.length; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          const spacers = list.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (let i = 0; i < list.items.length; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      if (!/[:|]/.test(cap[2])) {
        return;
      }
      const item = {
        type: "table",
        raw: cap[0],
        header: splitCells(cap[1]).map((c) => {
          return { text: c, tokens: [] };
        }),
        align: cap[2].replace(/^\||\| *$/g, "").split("|"),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          const align = item.align[i];
          if (align) {
            if (/^ *-+: *$/.test(align)) {
              item.align[i] = "right";
            } else if (/^ *:-+: *$/.test(align)) {
              item.align[i] = "center";
            } else if (/^ *:-+ *$/.test(align)) {
              item.align[i] = "left";
            } else {
              item.align[i] = null;
            }
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c, tokens: [] };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text2 = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text: text2,
        tokens: this.lexer.inline(text2)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text2 = cap[0].charAt(0);
        return {
          type: "text",
          raw: text2,
          text: text2
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match2 = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match2)
      return;
    if (match2[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match2[1] || match2[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match2[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match2[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + match2[0].length - 1);
      while ((match2 = endReg.exec(maskedSrc)) != null) {
        rDelim = match2[1] || match2[2] || match2[3] || match2[4] || match2[5] || match2[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match2[3] || match2[4]) {
          delimTotal += rLength;
          continue;
        } else if (match2[5] || match2[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const raw = [...src].slice(0, lLength + match2.index + rLength + 1).join("");
        if (Math.min(lLength, rLength) % 2) {
          const text3 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text3,
            tokens: this.lexer.inlineTokens(text3)
          };
        }
        const text2 = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text: text2,
          tokens: this.lexer.inlineTokens(text2)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text2 = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text2);
      const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text2 = text2.substring(1, text2.length - 1);
      }
      text2 = escape(text2, true);
      return {
        type: "codespan",
        raw: cap[0],
        text: text2
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(cap[1]);
        href = "mailto:" + text2;
      } else {
        text2 = escape(cap[1]);
        href = text2;
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  url(src) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text2, href;
      if (cap[2] === "@") {
        text2 = escape(cap[0]);
        href = "mailto:" + text2;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text2 = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text: text2,
        href,
        tokens: [
          {
            type: "text",
            raw: text2,
            text: text2
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text2;
      if (this.lexer.state.inRawBlock) {
        text2 = cap[0];
      } else {
        text2 = escape(cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text: text2
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.lheading = edit(block.lheading).replace(/bull/g, block.bullet).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
var inline2 = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
    //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a
    rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^((?![*_])[\spunctuation])/
};
inline2._punctuation = "\\p{P}$+<=>`^|~";
inline2.punctuation = edit(inline2.punctuation, "u").replace(/punctuation/g, inline2._punctuation).getRegex();
inline2.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
inline2.anyPunctuation = /\\[punct]/g;
inline2._escapes = /\\([punct])/g;
inline2._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline2.emStrong.lDelim = edit(inline2.emStrong.lDelim, "u").replace(/punct/g, inline2._punctuation).getRegex();
inline2.emStrong.rDelimAst = edit(inline2.emStrong.rDelimAst, "gu").replace(/punct/g, inline2._punctuation).getRegex();
inline2.emStrong.rDelimUnd = edit(inline2.emStrong.rDelimUnd, "gu").replace(/punct/g, inline2._punctuation).getRegex();
inline2.anyPunctuation = edit(inline2.anyPunctuation, "gu").replace(/punct/g, inline2._punctuation).getRegex();
inline2._escapes = edit(inline2._escapes, "gu").replace(/punct/g, inline2._punctuation).getRegex();
inline2._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline2._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline2.autolink = edit(inline2.autolink).replace("scheme", inline2._scheme).replace("email", inline2._email).getRegex();
inline2._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline2.tag = edit(inline2.tag).replace("comment", inline2._comment).replace("attribute", inline2._attribute).getRegex();
inline2._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline2._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline2._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline2.link = edit(inline2.link).replace("label", inline2._label).replace("href", inline2._href).replace("title", inline2._title).getRegex();
inline2.reflink = edit(inline2.reflink).replace("label", inline2._label).replace("ref", block._label).getRegex();
inline2.nolink = edit(inline2.nolink).replace("ref", block._label).getRegex();
inline2.reflinkSearch = edit(inline2.reflinkSearch, "g").replace("reflink", inline2.reflink).replace("nolink", inline2.nolink).getRegex();
inline2.normal = { ...inline2 };
inline2.pedantic = {
  ...inline2.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline2._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline2._label).getRegex()
};
inline2.gfm = {
  ...inline2.normal,
  escape: edit(inline2.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline2.gfm.url = edit(inline2.gfm.url, "i").replace("email", inline2.gfm._extended_email).getRegex();
inline2.breaks = {
  ...inline2.gfm,
  br: edit(inline2.br).replace("{2,}", "*").getRegex(),
  text: edit(inline2.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
var _Lexer = class __Lexer {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(options2) {
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline2.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline2.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline2.breaks;
      } else {
        rules.inline = inline2.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline: inline2
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token;
    let lastToken;
    let cutSrc;
    let lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match2;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match2 = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match2[0].slice(match2[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match2.index) + "[" + "a".repeat(match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match2 = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match2.index) + "[" + "a".repeat(match2[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match2 = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match2.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var _Renderer = class {
  options;
  constructor(options2) {
    this.options = options2 || _defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/^\S*/)?.[0];
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html2, block2) {
    return html2;
  }
  heading(text2, level, raw) {
    return `<h${level}>${text2}</h${level}>
`;
  }
  hr() {
    return "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul";
    const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text2, task, checked) {
    return `<li>${text2}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(text2) {
    return `<p>${text2}</p>
`;
  }
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong(text2) {
    return `<strong>${text2}</strong>`;
  }
  em(text2) {
    return `<em>${text2}</em>`;
  }
  codespan(text2) {
    return `<code>${text2}</code>`;
  }
  br() {
    return "<br>";
  }
  del(text2) {
    return `<del>${text2}</del>`;
  }
  link(href, title, text2) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text2;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text2 + "</a>";
    return out;
  }
  image(href, title, text2) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text2;
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text2}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += ">";
    return out;
  }
  text(text2) {
    return text2;
  }
};
var _TextRenderer = class {
  // no need for block level renderers
  strong(text2) {
    return text2;
  }
  em(text2) {
    return text2;
  }
  codespan(text2) {
    return text2;
  }
  del(text2) {
    return text2;
  }
  html(text2) {
    return text2;
  }
  text(text2) {
    return text2;
  }
  link(href, title, text2) {
    return "" + text2;
  }
  image(href, title, text2) {
    return "" + text2;
  }
  br() {
    return "";
  }
};
var _Parser = class __Parser {
  options;
  renderer;
  textRenderer;
  constructor(options2) {
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const genericToken = token;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          const headingToken = token;
          out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const codeToken = token;
          out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
          continue;
        }
        case "table": {
          const tableToken = token;
          let header = "";
          let cell = "";
          for (let j = 0; j < tableToken.header.length; j++) {
            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
          }
          header += this.renderer.tablerow(cell);
          let body = "";
          for (let j = 0; j < tableToken.rows.length; j++) {
            const row = tableToken.rows[j];
            cell = "";
            for (let k = 0; k < row.length; k++) {
              cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          const blockquoteToken = token;
          const body = this.parse(blockquoteToken.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          const listToken = token;
          const ordered = listToken.ordered;
          const start = listToken.start;
          const loose = listToken.loose;
          let body = "";
          for (let j = 0; j < listToken.items.length; j++) {
            const item = listToken.items[j];
            const checked = item.checked;
            const task = item.task;
            let itemBody = "";
            if (item.task) {
              const checkbox = this.renderer.checkbox(!!checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox + " "
                  });
                }
              } else {
                itemBody += checkbox + " ";
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, !!checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          const htmlToken = token;
          out += this.renderer.html(htmlToken.text, htmlToken.block);
          continue;
        }
        case "paragraph": {
          const paragraphToken = token;
          out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
          continue;
        }
        case "text": {
          let textToken = token;
          let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          const escapeToken = token;
          out += renderer.text(escapeToken.text);
          break;
        }
        case "html": {
          const tagToken = token;
          out += renderer.html(tagToken.text);
          break;
        }
        case "link": {
          const linkToken = token;
          out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
          break;
        }
        case "image": {
          const imageToken = token;
          out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
          break;
        }
        case "strong": {
          const strongToken = token;
          out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
          break;
        }
        case "em": {
          const emToken = token;
          out += renderer.em(this.parseInline(emToken.tokens, renderer));
          break;
        }
        case "codespan": {
          const codespanToken = token;
          out += renderer.codespan(codespanToken.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          const delToken = token;
          out += renderer.del(this.parseInline(delToken.tokens, renderer));
          break;
        }
        case "text": {
          const textToken = token;
          out += renderer.text(textToken.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var _Hooks = class {
  options;
  constructor(options2) {
    this.options = options2 || _defaults;
  }
  static passThroughHooks = /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess"
  ]);
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html2) {
    return html2;
  }
};
var Marked = class {
  defaults = _getDefaults();
  options = this.setOptions;
  parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);
  parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);
  Parser = _Parser;
  parser = _Parser.parse;
  Renderer = _Renderer;
  TextRenderer = _TextRenderer;
  Lexer = _Lexer;
  lexer = _Lexer.lex;
  Tokenizer = _Tokenizer;
  Hooks = _Hooks;
  constructor(...args) {
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback) {
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback));
          break;
        }
        default: {
          const genericToken = token;
          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              values = values.concat(this.walkTokens(genericToken[childTokens], callback));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          const rendererFunc = pack.renderer[prop];
          const rendererKey = prop;
          const prevRenderer = renderer[rendererKey];
          renderer[rendererKey] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          const tokenizerFunc = pack.tokenizer[prop];
          const tokenizerKey = prop;
          const prevTokenizer = tokenizer[tokenizerKey];
          tokenizer[tokenizerKey] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          const hooksFunc = pack.hooks[prop];
          const hooksKey = prop;
          const prevHook = hooks[hooksKey];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksKey] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksKey] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
  #parseMarkdown(lexer2, parser2) {
    return (src, options2) => {
      const origOpt = { ...options2 };
      const opt = { ...this.defaults, ...origOpt };
      if (this.defaults.async === true && origOpt.async === false) {
        if (!opt.silent) {
          console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
        }
        opt.async = true;
      }
      const throwError = this.#onError(!!opt.silent, !!opt.async);
      if (typeof src === "undefined" || src === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
      }
      if (opt.hooks) {
        opt.hooks.options = opt;
      }
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html2) => opt.hooks ? opt.hooks.postprocess(html2) : html2).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src = opt.hooks.preprocess(src);
        }
        const tokens = lexer2(src, opt);
        if (opt.walkTokens) {
          this.walkTokens(tokens, opt.walkTokens);
        }
        let html2 = parser2(tokens, opt);
        if (opt.hooks) {
          html2 = opt.hooks.postprocess(html2);
        }
        return html2;
      } catch (e) {
        return throwError(e);
      }
    };
  }
  #onError(silent, async) {
    return (e) => {
      e.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e);
      }
      throw e;
    };
  }
};
var markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback) {
  return markedInstance.walkTokens(tokens, callback);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use2 = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// src/components/bubbles/StreamingBubble.tsx
var _tmpl$85 = /* @__PURE__ */ template(`<div class="flex flex-col animate-fade-in typebot-streaming-container"><div class="flex w-full items-center"><div class="flex relative items-start typebot-host-bubble max-w-full"><div class="flex items-center absolute px-4 py-2 bubble-typing "data-testid=host-bubble></div><div class="flex flex-col overflow-hidden text-fade-in mx-4 my-2 relative text-ellipsis h-full gap-6">`);
var _tmpl$223 = /* @__PURE__ */ template(`<span>`);
var StreamingBubble = (props7) => {
  const [content, setContent] = persist(createSignal([]), {
    key: `typebot-streaming-message-${props7.streamingMessageId}`,
    storage: props7.context.storage
  });
  marked.use({
    renderer: {
      link: (href, _title, text2) => {
        return `<a href="${href}" target="_blank" rel="noopener noreferrer">${text2}</a>`;
      }
    }
  });
  createEffect(() => {
    if (streamingMessage()?.id !== props7.streamingMessageId) return [];
    setContent(streamingMessage()?.content.split("```").flatMap((block2, index) => {
      if (index % 2 === 0) {
        return block2.split("\n\n").map((line) => purify.sanitize(marked.parse(line.replace(/【.+】/g, "").replace(/</g, "&lt;").replace(/>/g, "&gt;"), {
          breaks: true
        }), {
          ADD_ATTR: ["target"]
        }));
      } else {
        return [purify.sanitize(marked.parse("```" + block2 + "```".replace(/</g, "&lt;").replace(/>/g, "&gt;"), {
          breaks: true
        }), {
          ADD_ATTR: ["target"]
        })];
      }
    }).filter(isNotEmpty) ?? []);
  });
  return (() => {
    var _el$ = _tmpl$85(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling;
    _el$4.style.setProperty("width", "100%");
    _el$4.style.setProperty("height", "100%");
    insert(_el$5, createComponent(For, {
      get each() {
        return content();
      },
      children: (line) => (() => {
        var _el$6 = _tmpl$223();
        _el$6.innerHTML = line;
        return _el$6;
      })()
    }));
    return _el$;
  })();
};

// src/components/ConversationContainer/AvatarSideContainer.tsx
var _tmpl$86 = /* @__PURE__ */ template(`<div><div>`);
var AvatarSideContainer = (props7) => {
  let avatarContainer;
  const [top, setTop] = createSignal(0);
  const resizeObserver = new ResizeObserver((entries2) => setTop(entries2[0].target.clientHeight - (isMobile() ? 24 : 40)));
  onMount(() => {
    if (avatarContainer) {
      resizeObserver.observe(avatarContainer);
    }
  });
  onCleanup(() => {
    if (avatarContainer) {
      resizeObserver.unobserve(avatarContainer);
    }
  });
  return (() => {
    var _el$ = _tmpl$86(), _el$2 = _el$.firstChild;
    var _ref$ = avatarContainer;
    typeof _ref$ === "function" ? use(_ref$, _el$) : avatarContainer = _el$;
    insert(_el$2, createComponent(Avatar, {
      get src() {
        return props7.avatarSrc;
      },
      get isChatContainerLight() {
        return isChatContainerLight({
          chatContainer: props7.theme.chat?.container,
          generalBackground: props7.theme.general?.background
        });
      }
    }));
    createRenderEffect((_p$) => {
      var _v$ = "flex flex-shrink-0 items-center relative typebot-avatar-container " + (isMobile() ? "w-6" : "w-10"), _v$2 = "absolute flex items-center top-0" + (isMobile() ? " w-6 h-6" : " w-10 h-10") + (props7.hideAvatar ? " opacity-0" : " opacity-100"), _v$3 = `${top()}px`, _v$4 = props7.isTransitionDisabled ? void 0 : "top 350ms ease-out, opacity 250ms ease-out";
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
      _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$2.style.setProperty("top", _v$3) : _el$2.style.removeProperty("top"));
      _v$4 !== _p$.o && ((_p$.o = _v$4) != null ? _el$2.style.setProperty("transition", _v$4) : _el$2.style.removeProperty("transition"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0
    });
    return _el$;
  })();
};

// src/components/ConversationContainer/ChatChunk.tsx
var _tmpl$87 = /* @__PURE__ */ template(`<div><div class="flex flex-col flex-1 gap-2">`);
var _tmpl$224 = /* @__PURE__ */ template(`<div class="flex flex-col w-full min-w-0 gap-2 typebot-chat-chunk">`);
var ChatChunk = (props7) => {
  let inputRef;
  const [displayedMessageIndex, setDisplayedMessageIndex] = createSignal(props7.isTransitionDisabled ? props7.messages.length : 0);
  const [lastBubble, setLastBubble] = createSignal();
  onMount(() => {
    if (props7.streamingMessageId) return;
    if (props7.messages.length === 0) {
      props7.onAllBubblesDisplayed();
    }
    props7.onScrollToBottom({
      lastElement: inputRef,
      offset: 50
    });
  });
  const displayNextMessage = async (bubbleRef) => {
    if ((props7.settings.typingEmulation?.delayBetweenBubbles ?? defaultSettings.typingEmulation.delayBetweenBubbles) > 0 && displayedMessageIndex() < props7.messages.length - 1) {
      await new Promise((resolve) => setTimeout(resolve, (props7.settings.typingEmulation?.delayBetweenBubbles ?? defaultSettings.typingEmulation.delayBetweenBubbles) * 1e3));
    }
    const lastBubbleBlockId = props7.messages[displayedMessageIndex()].id;
    await props7.onNewBubbleDisplayed(lastBubbleBlockId);
    setDisplayedMessageIndex(displayedMessageIndex() === props7.messages.length ? displayedMessageIndex() : displayedMessageIndex() + 1);
    props7.onScrollToBottom({
      lastElement: bubbleRef
    });
    if (displayedMessageIndex() === props7.messages.length) {
      setLastBubble(bubbleRef);
      props7.onAllBubblesDisplayed();
    }
  };
  const hostAvatarSrc = getAvatarAtIndex({
    avatarHistory: props7.avatarsHistory,
    currentIndex: props7.index,
    currentRole: "host"
  });
  return (() => {
    var _el$ = _tmpl$224();
    insert(_el$, createComponent(Show, {
      get when() {
        return props7.messages.length > 0;
      },
      get children() {
        var _el$2 = _tmpl$87(), _el$3 = _el$2.firstChild;
        insert(_el$2, createComponent(Show, {
          get when() {
            return (props7.theme.chat?.hostAvatar?.isEnabled ?? defaultHostAvatarIsEnabled) && props7.messages.length > 0;
          },
          get children() {
            return createComponent(AvatarSideContainer, {
              get hideAvatar() {
                return props7.hideAvatar;
              },
              get isTransitionDisabled() {
                return props7.isTransitionDisabled;
              },
              get theme() {
                return props7.theme;
              },
              avatarSrc: hostAvatarSrc
            });
          }
        }), _el$3);
        insert(_el$3, createComponent(For, {
          get each() {
            return props7.messages.slice(0, displayedMessageIndex() + 1);
          },
          children: (message, idx) => createComponent(HostBubble, {
            message,
            get typingEmulation() {
              return props7.settings.typingEmulation;
            },
            get isTypingSkipped() {
              return createMemo(() => !!((props7.settings.typingEmulation?.isDisabledOnFirstMessage ?? defaultSettings.typingEmulation.isDisabledOnFirstMessage) && props7.index === 0))() && idx() === 0;
            },
            get onTransitionEnd() {
              return props7.isTransitionDisabled ? void 0 : displayNextMessage;
            },
            get onCompleted() {
              return props7.onSubmit;
            }
          })
        }));
        createRenderEffect((_p$) => {
          var _v$ = "flex" + (isMobile() ? " gap-1" : " gap-2"), _v$2 = props7.theme.chat?.guestAvatar?.isEnabled ?? defaultGuestAvatarIsEnabled ? isMobile() ? "calc(100% - 60px)" : "calc(100% - 48px - 48px)" : "100%";
          _v$ !== _p$.e && className(_el$2, _p$.e = _v$);
          _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$3.style.setProperty("max-width", _v$2) : _el$3.style.removeProperty("max-width"));
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$2;
      }
    }), null);
    insert(_el$, (() => {
      var _c$ = createMemo(() => !!(props7.input && displayedMessageIndex() === props7.messages.length && !hiddenInput()[`${props7.input.id}-${props7.index}`]));
      return () => _c$() && createComponent(InputChatBlock, {
        ref(r$) {
          var _ref$ = inputRef;
          typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
        },
        get block() {
          return props7.input;
        },
        get chunkIndex() {
          return props7.index;
        },
        get theme() {
          return props7.theme;
        },
        get avatarHistory() {
          return props7.avatarsHistory;
        },
        get context() {
          return props7.context;
        },
        get isInputPrefillEnabled() {
          return props7.settings.general?.isInputPrefillEnabled ?? defaultSettings.general.isInputPrefillEnabled;
        },
        get isOngoingLastChunk() {
          return props7.isOngoingLastChunk;
        },
        get hasError() {
          return props7.hasError;
        },
        onTransitionEnd: () => props7.onScrollToBottom({
          lastElement: lastBubble()
        }),
        get onSubmit() {
          return props7.onSubmit;
        },
        get onSkip() {
          return props7.onSkip;
        }
      });
    })(), null);
    insert(_el$, createComponent(Show, {
      get when() {
        return props7.streamingMessageId;
      },
      keyed: true,
      children: (streamingMessageId) => (() => {
        var _el$4 = _tmpl$87(), _el$5 = _el$4.firstChild;
        insert(_el$4, createComponent(Show, {
          get when() {
            return props7.theme.chat?.hostAvatar?.isEnabled ?? defaultHostAvatarIsEnabled;
          },
          get children() {
            return createComponent(AvatarSideContainer, {
              get hideAvatar() {
                return props7.hideAvatar;
              },
              get theme() {
                return props7.theme;
              },
              avatarSrc: hostAvatarSrc
            });
          }
        }), _el$5);
        insert(_el$5, createComponent(StreamingBubble, {
          streamingMessageId,
          get context() {
            return props7.context;
          }
        }));
        createRenderEffect((_p$) => {
          var _v$3 = "flex" + (isMobile() ? " gap-1" : " gap-2"), _v$4 = props7.theme.chat?.guestAvatar?.isEnabled ?? defaultGuestAvatarIsEnabled ? isMobile() ? "calc(100% - 60px)" : "calc(100% - 48px - 48px)" : "100%";
          _v$3 !== _p$.e && className(_el$4, _p$.e = _v$3);
          _v$4 !== _p$.t && ((_p$.t = _v$4) != null ? _el$5.style.setProperty("max-width", _v$4) : _el$5.style.removeProperty("max-width"));
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$4;
      })()
    }), null);
    return _el$;
  })();
};

// src/components/bubbles/LoadingBubble.tsx
var _tmpl$88 = /* @__PURE__ */ template(`<div class="flex flex-col animate-fade-in"><div class="flex w-full items-center"><div class="flex relative items-start typebot-host-bubble"><div class="flex items-center absolute px-4 py-2 bubble-typing "data-testid=host-bubble></div><p class="overflow-hidden text-fade-in mx-4 my-2 whitespace-pre-wrap slate-html-container relative opacity-0 h-6 text-ellipsis">`);
var LoadingBubble = () => (() => {
  var _el$ = _tmpl$88(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild;
  _el$4.style.setProperty("width", "64px");
  _el$4.style.setProperty("height", "32px");
  insert(_el$4, createComponent(TypingBubble, {}));
  return _el$;
})();

// src/components/ConversationContainer/LoadingChunk.tsx
var _tmpl$89 = /* @__PURE__ */ template(`<div class="flex w-full typebot-loading-chunk"><div class="flex flex-col w-full min-w-0"><div class="flex gap-2">`);
var LoadingChunk = (props7) => (() => {
  var _el$ = _tmpl$89(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild;
  insert(_el$3, createComponent(Show, {
    get when() {
      return props7.theme.chat?.hostAvatar?.isEnabled ?? defaultHostAvatarIsEnabled;
    },
    get children() {
      return createComponent(AvatarSideContainer, {
        get theme() {
          return props7.theme;
        },
        get avatarSrc() {
          return props7.avatarSrc;
        }
      });
    }
  }), null);
  insert(_el$3, createComponent(LoadingBubble, {}), null);
  return _el$;
})();

// src/components/ConversationContainer/ConversationContainer.tsx
var _tmpl$90 = /* @__PURE__ */ template(`<div><div class="max-w-chat-container w-full flex flex-col gap-2">`);
var _tmpl$225 = /* @__PURE__ */ template(`<div class="w-full flex-shrink-0 typebot-bottom-spacer h-[20%]">`);
var AUTO_SCROLL_CLIENT_HEIGHT_PERCENT_TOLERANCE = 0.6;
var AUTO_SCROLL_DELAY = 50;
var ConversationContainer = (props7) => {
  let chatContainer;
  const resizeObserver = new ResizeObserver((entries2) => {
    setIsMobile((entries2[0]?.target.clientWidth ?? 0) < 432);
    setIsMediumContainer((entries2[0]?.target.clientWidth ?? 0) < 550);
  });
  const [chatChunks, setChatChunks] = persist(createSignal([{
    input: props7.initialChatReply.input,
    messages: props7.initialChatReply.messages
  }]), {
    key: `typebot-${props7.context.typebot.id}-chatChunks`,
    storage: props7.context.storage,
    onRecovered: () => {
      setTimeout(() => {
        chatContainer?.scrollTo(0, chatContainer.scrollHeight);
      }, 200);
    }
  });
  const [clientSideActions, setClientSideActions] = persist(createSignal(props7.initialChatReply.clientSideActions ?? []), {
    key: `typebot-${props7.context.typebot.id}-clientSideActions`,
    storage: props7.context.storage
  });
  const [isEnded, setIsEnded] = persist(createSignal(false), {
    key: `typebot-${props7.context.typebot.id}-isEnded`,
    storage: props7.context.storage
  });
  const [totalChunksDisplayed, setTotalChunksDisplayed] = persist(createSignal(0), {
    key: `typebot-${props7.context.typebot.id}-totalChunksDisplayed`,
    storage: props7.context.storage
  });
  const [isSending, setIsSending] = createSignal(false);
  const [isLastAutoScrollAtBottom, setIsLastAutoScrollAtBottom] = createSignal(true);
  const [hasError, setHasError] = createSignal(false);
  const [inputAnswered, setInputAnswered] = createSignal({});
  const [avatarsHistory, setAvatarsHistory] = persist(createSignal(initializeAvatarHistory({
    initialTheme: props7.initialChatReply.typebot.theme,
    dynamicTheme: props7.initialChatReply.dynamicTheme
  })), {
    key: `typebot-${props7.context.typebot.id}-avatarsHistory`,
    storage: props7.context.storage
  });
  onMount(() => {
    if (chatContainer) resizeObserver.observe(chatContainer);
    window.addEventListener("message", processIncomingEvent);
    (async () => {
      const isRecoveredFromStorage = chatChunks().length > 1;
      if (isRecoveredFromStorage) {
        cleanupRecoveredChat();
      } else {
        const actionsBeforeFirstBubble = clientSideActions()?.filter((action) => isNotDefined(action.lastBubbleBlockId));
        await processClientSideActions(actionsBeforeFirstBubble);
      }
    })();
  });
  createEffect((prevUrl) => {
    if (prevUrl === props7.initialChatReply.typebot.theme.chat?.hostAvatar?.url) return prevUrl;
    setAvatarsHistory((prev) => [...prev, {
      role: "host",
      chunkIndex: chatChunks().length - 1,
      avatarUrl: props7.initialChatReply.typebot.theme.chat?.hostAvatar?.url
    }]);
    return props7.initialChatReply.typebot.theme.chat?.hostAvatar?.url;
  }, props7.initialChatReply.typebot.theme.chat?.hostAvatar?.url);
  createEffect((prevUrl) => {
    if (prevUrl === props7.initialChatReply.typebot.theme.chat?.guestAvatar?.url) return prevUrl;
    setAvatarsHistory((prev) => [...prev, {
      role: "guest",
      chunkIndex: chatChunks().length - 1,
      avatarUrl: props7.initialChatReply.typebot.theme.chat?.guestAvatar?.url
    }]);
    return props7.initialChatReply.typebot.theme.chat?.guestAvatar?.url;
  }, props7.initialChatReply.typebot.theme.chat?.guestAvatar?.url);
  const cleanupRecoveredChat = () => {
    if ([...chatChunks()].pop()?.streamingMessageId) setChatChunks((chunks) => chunks.slice(0, -1));
    const actionsBeforeFirstBubble = getNextClientSideActionsBatch({
      clientSideActions: clientSideActions(),
      lastBubbleBlockId: void 0
    });
    setClientSideActions((actions) => actions.slice(actionsBeforeFirstBubble.length));
  };
  const streamMessage = ({
    id,
    message
  }) => {
    setIsSending(false);
    setIsLastAutoScrollAtBottom(false);
    const lastChunk = [...chatChunks()].pop();
    if (!lastChunk) return;
    if (lastChunk.streamingMessageId !== id) setChatChunks((displayedChunks) => [...displayedChunks, {
      messages: [],
      streamingMessageId: id
    }]);
    setStreamingMessage({
      id,
      content: message
    });
  };
  const saveLogs = async (clientLogs) => {
    if (!clientLogs) return;
    props7.onNewLogs?.(clientLogs);
    if (props7.context.isPreview) return;
    await saveClientLogsQuery({
      apiHost: props7.context.apiHost,
      sessionId: props7.initialChatReply.sessionId,
      clientLogs
    });
  };
  const showOfflineErrorToast = () => {
    toaster.create({
      title: props7.context.typebot.settings.general?.systemMessages?.networkErrorTitle ?? defaultSystemMessages.networkErrorTitle,
      description: props7.context.typebot.settings.general?.systemMessages?.networkErrorMessage ?? defaultSystemMessages.networkErrorMessage
    });
  };
  const sendMessage = async (answer) => {
    if (hasError() && clientSideActions().length > 0) {
      setHasError(false);
      await processClientSideActions(clientSideActions());
      return;
    }
    setHasError(false);
    const currentInputBlock = [...chatChunks()].pop()?.input;
    if (currentInputBlock?.id && answer) {
      if (props7.onAnswer) props7.onAnswer({
        message: getAnswerContent(answer),
        blockId: currentInputBlock.id
      });
      setInputAnswered((prev) => ({
        ...prev,
        [parseInputUniqueKey(currentInputBlock.id)]: true
      }));
    }
    const longRequest = setTimeout(() => {
      setIsSending(true);
    }, 1e3);
    autoScrollToBottom();
    const {
      data,
      error
    } = await continueChatQuery({
      apiHost: props7.context.apiHost,
      sessionId: props7.initialChatReply.sessionId,
      message: convertSubmitContentToMessage(answer)
    });
    clearTimeout(longRequest);
    setIsSending(false);
    await processContinueChatResponse({
      data,
      error
    });
    if (!navigator.onLine || isNetworkError(error)) {
      showOfflineErrorToast();
    }
  };
  const processContinueChatResponse = async ({
    data,
    error
  }) => {
    if (error) {
      setHasError(true);
      const errorLogs = [await parseUnknownClientError({
        err: error,
        context: "While sending message"
      })];
      await saveClientLogsQuery({
        apiHost: props7.context.apiHost,
        sessionId: props7.initialChatReply.sessionId,
        clientLogs: errorLogs
      });
      props7.onNewLogs?.(errorLogs);
      return;
    }
    if (!data) return;
    if (data.progress) props7.onProgressUpdate?.(data.progress);
    if (data.lastMessageNewFormat) {
      setFormattedMessages([...formattedMessages(), {
        inputIndex: [...chatChunks()].length - 1,
        formattedMessage: data.lastMessageNewFormat
      }]);
    }
    if (data.logs) props7.onNewLogs?.(data.logs);
    if (data.dynamicTheme) {
      setAvatarsHistory((prev) => addAvatarsToHistoryIfChanged({
        newAvatars: {
          host: data.dynamicTheme?.hostAvatarUrl,
          guest: data.dynamicTheme?.guestAvatarUrl
        },
        avatarHistory: prev,
        currentChunkIndex: chatChunks().length
      }));
      if (data.dynamicTheme?.backgroundUrl) setGeneralBackground({
        background: {
          type: "Image" /* IMAGE */,
          content: data.dynamicTheme?.backgroundUrl
        },
        documentStyle: botContainer()?.style ?? document.documentElement.style,
        typebotVersion: latestTypebotVersion
      });
    }
    if (data.input && props7.onNewInputBlock) {
      props7.onNewInputBlock(data.input);
    }
    if (data.clientSideActions) {
      setClientSideActions(data.clientSideActions);
      const actionsBeforeFirstBubble = getNextClientSideActionsBatch({
        clientSideActions: data.clientSideActions,
        lastBubbleBlockId: void 0
      });
      await processClientSideActions(actionsBeforeFirstBubble);
      if (data.clientSideActions.length === 1 && data.clientSideActions[0].type === "stream" && data.messages.length === 0 && data.input === void 0) return;
    }
    setChatChunks((displayedChunks) => [...displayedChunks, {
      input: data.input,
      messages: data.messages.filter((message) => {
        return message.type !== "text" || message.content.type !== "richText" || message.content.richText.length > 1 || message.content.richText[0].type !== "variable" || message.content.richText[0].children.length > 0;
      })
    }]);
  };
  const autoScrollToBottom = ({
    lastElement,
    offset: offset3 = 0
  } = {}) => {
    if (!chatContainer) return;
    const isBottomOfLastElementTooFarBelow = chatContainer.scrollTop + chatContainer.clientHeight < chatContainer.scrollHeight - chatContainer.clientHeight * AUTO_SCROLL_CLIENT_HEIGHT_PERCENT_TOLERANCE;
    if (isBottomOfLastElementTooFarBelow && !isLastAutoScrollAtBottom()) return;
    const onScrollEnd = (callback) => {
      let scrollTimeout;
      const scrollListener = () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = window.setTimeout(() => {
          callback();
          chatContainer.removeEventListener("scroll", scrollListener);
        }, 100);
      };
      chatContainer.addEventListener("scroll", scrollListener, {
        passive: true
      });
    };
    setTimeout(() => {
      onScrollEnd(() => {
        const isAtBottom = Math.abs(chatContainer.scrollHeight - chatContainer.scrollTop - chatContainer.clientHeight) < 2;
        setIsLastAutoScrollAtBottom(isAtBottom);
      });
      chatContainer?.scrollTo({
        top: lastElement ? lastElement.offsetTop - offset3 : chatContainer.scrollHeight,
        behavior: "smooth"
      });
    }, AUTO_SCROLL_DELAY);
  };
  const handleAllBubblesDisplayed = async () => {
    if (chatChunks().length > totalChunksDisplayed()) setTotalChunksDisplayed((prev) => prev + 1);
    const lastChunk = [...chatChunks()].pop();
    if (!lastChunk) return;
    if (isNotDefined(lastChunk.input)) {
      setIsEnded(true);
      props7.onEnd?.();
    }
  };
  const handleNewBubbleDisplayed = async (blockId) => {
    const actionsToExecute = getNextClientSideActionsBatch({
      clientSideActions: clientSideActions(),
      lastBubbleBlockId: blockId
    });
    await processClientSideActions(actionsToExecute);
  };
  const processClientSideActions = async (actions) => {
    let hasStreamError = false;
    for (const action of actions) {
      if ("streamOpenAiChatCompletion" in action || "webhookToExecute" in action || "stream" in action) setIsSending(true);
      const response = await executeClientSideAction({
        clientSideAction: action,
        context: {
          apiHost: props7.context.apiHost,
          wsHost: props7.context.wsHost,
          sessionId: props7.initialChatReply.sessionId,
          resultId: props7.initialChatReply.resultId
        },
        onMessageStream: streamMessage,
        onStreamError: async (error) => {
          setHasError(true);
          hasStreamError = true;
          await saveLogs([error]);
          props7.onNewLogs?.([error]);
        }
      });
      if ("streamOpenAiChatCompletion" in action || "stream" in action) {
        setTotalChunksDisplayed((prev) => prev + 1);
        if (response && "replyToSend" in response && !response.replyToSend) {
          setIsSending(false);
          continue;
        }
      }
      if (hasStreamError) return;
      setClientSideActions((actions2) => actions2.slice(1));
      if (response && "logs" in response) saveLogs(response.logs);
      if (response && "replyToSend" in response) {
        setIsSending(false);
        sendMessage(response.replyToSend ? {
          type: "text",
          value: response.replyToSend
        } : void 0);
        return;
      }
      if (response && "blockedPopupUrl" in response) {
        toaster.create({
          title: props7.context.typebot.settings.general?.systemMessages?.popupBlockedTitle ?? defaultSystemMessages.popupBlockedTitle,
          description: props7.context.typebot.settings.general?.systemMessages?.popupBlockedDescription ?? defaultSystemMessages.popupBlockedDescription,
          meta: {
            link: response.blockedPopupUrl
          }
        });
      }
      if (response && "scriptCallbackMessage" in response) props7.onScriptExecutionSuccess?.(response.scriptCallbackMessage);
    }
  };
  onCleanup(() => {
    if (chatContainer) resizeObserver.unobserve(chatContainer);
    setStreamingMessage(void 0);
    setFormattedMessages([]);
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = async (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot || data.id && props7.context.typebot.id !== data.id) return;
    if (data.command === "sendCommand" && !isEnded()) await sendCommandAndProcessResponse(data.text);
  };
  const sendCommandAndProcessResponse = async (command, retryCount = 0, maxRetries = 5) => {
    if (isSending()) {
      if (retryCount >= maxRetries) {
        throw new Error("Max retry attempts for command reached");
      }
      await new Promise((resolve) => setTimeout(resolve, 5e3));
      return sendCommandAndProcessResponse(command, retryCount + 1, maxRetries);
    }
    const currentInputBlock = [...chatChunks()].pop()?.input;
    if (currentInputBlock?.id && !inputAnswered()[parseInputUniqueKey(currentInputBlock.id)]) setHiddenInput((prev) => ({
      ...prev,
      [parseInputUniqueKey(currentInputBlock.id)]: true
    }));
    const longRequest = setTimeout(() => {
      setIsSending(true);
    }, 1e3);
    autoScrollToBottom();
    const {
      data,
      error
    } = await continueChatQuery({
      apiHost: props7.context.apiHost,
      sessionId: props7.initialChatReply.sessionId,
      message: {
        type: "command",
        command
      }
    });
    clearTimeout(longRequest);
    setIsSending(false);
    return processContinueChatResponse({
      data,
      error
    });
  };
  const parseInputUniqueKey = (id) => `${id}-${chatChunks().length - 1}`;
  const handleSkip = () => sendMessage(void 0);
  return (() => {
    var _el$ = _tmpl$90(), _el$2 = _el$.firstChild;
    var _ref$ = chatContainer;
    typeof _ref$ === "function" ? use(_ref$, _el$) : chatContainer = _el$;
    insert(_el$2, createComponent(For, {
      get each() {
        return chatChunks().slice(0, totalChunksDisplayed() + 1);
      },
      children: (chatChunk, index) => createComponent(ChatChunk, {
        get index() {
          return index();
        },
        get messages() {
          return chatChunk.messages;
        },
        get input() {
          return chatChunk.input;
        },
        get theme() {
          return props7.initialChatReply.typebot.theme;
        },
        get avatarsHistory() {
          return avatarsHistory();
        },
        get settings() {
          return props7.initialChatReply.typebot.settings;
        },
        get streamingMessageId() {
          return chatChunk.streamingMessageId;
        },
        get context() {
          return props7.context;
        },
        get hideAvatar() {
          return createMemo(() => !!(!chatChunk.input || hiddenInput()[`${chatChunk.input.id}-${index()}`]))() && ((chatChunks().slice(0, totalChunksDisplayed() + 1)[index() + 1]?.messages ?? []).length > 0 || chatChunks().slice(0, totalChunksDisplayed() + 1)[index() + 1]?.streamingMessageId !== void 0 || chatChunk.messages.length > 0 && isSending());
        },
        get hasError() {
          return createMemo(() => !!hasError())() && index() === chatChunks().slice(0, totalChunksDisplayed() + 1).length - 1;
        },
        get isTransitionDisabled() {
          return index() !== chatChunks().slice(0, totalChunksDisplayed() + 1).length - 1;
        },
        get isOngoingLastChunk() {
          return createMemo(() => !!!isEnded())() && index() === chatChunks().slice(0, totalChunksDisplayed() + 1).length - 1;
        },
        onNewBubbleDisplayed: handleNewBubbleDisplayed,
        onAllBubblesDisplayed: handleAllBubblesDisplayed,
        onSubmit: sendMessage,
        onScrollToBottom: autoScrollToBottom,
        onSkip: handleSkip
      })
    }), null);
    insert(_el$2, createComponent(Show, {
      get when() {
        return isSending();
      },
      get children() {
        return createComponent(LoadingChunk, {
          get theme() {
            return props7.initialChatReply.typebot.theme;
          },
          get avatarSrc() {
            return avatarsHistory().findLast((avatar) => avatar.role === "host")?.avatarUrl;
          }
        });
      }
    }), null);
    insert(_el$, createComponent(BottomSpacer, {}), null);
    createRenderEffect(() => className(_el$, cx("overflow-y-auto relative scrollable-container typebot-chat-view scroll-smooth w-full min-h-full flex flex-col items-center", (props7.initialChatReply.typebot.theme.chat?.container?.backgroundColor ?? defaultContainerBackgroundColor) !== "transparent" && "max-w-chat-container")));
    return _el$;
  })();
};
var BottomSpacer = () => _tmpl$225();
var convertSubmitContentToMessage = (answer) => {
  if (!answer) return;
  if (answer.type === "text") return {
    type: "text",
    text: answer.value,
    attachedFileUrls: answer.attachments?.map((attachment) => attachment.url)
  };
  if (answer.type === "recording") return {
    type: "audio",
    url: answer.url
  };
};
var getNextClientSideActionsBatch = ({
  clientSideActions,
  lastBubbleBlockId
}) => {
  const actionsBatch = [];
  let currentLastBubbleBlockId = lastBubbleBlockId;
  for (const action of clientSideActions) {
    if (currentLastBubbleBlockId !== action.lastBubbleBlockId) break;
    currentLastBubbleBlockId = action.lastBubbleBlockId;
    if (lastBubbleBlockId === action.lastBubbleBlockId) actionsBatch.push(action);
  }
  return actionsBatch;
};

// src/components/ErrorMessage.tsx
var _tmpl$91 = /* @__PURE__ */ template(`<div class="h-full flex justify-center items-center flex-col"><p class="text-2xl text-center"></p><pre>`);
var ErrorMessage = (props7) => {
  return (() => {
    var _el$ = _tmpl$91(), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;
    insert(_el$2, () => props7.error.message);
    insert(_el$3, () => JSON.stringify(props7.error.cause, null, 2));
    return _el$;
  })();
};

// src/components/icons/TypebotLogo.tsx
var _tmpl$92 = /* @__PURE__ */ template(`<svg viewBox="0 0 40 48"width=13 fill=none><path d="M37.9625 4.18811C36.9719 1.73444 34.5328 0 31.6797 0H6.75937C3.02656 0 0 2.97048 0 6.63412V39.0671C0 40.9273 0.779687 42.6081 2.03594 43.8119C3.02813 46.2656 5.46875 48 8.32187 48H33.2422C36.975 48 40 45.0311 40 41.3674V8.93444C40 7.07425 39.2203 5.39195 37.9625 4.18811ZM34.5312 39.0671C34.5312 40.6098 33.2516 41.8658 31.6797 41.8658H6.75937C6.29844 41.8658 5.8625 41.7585 5.47656 41.5652C4.54531 41.1052 3.90625 40.1574 3.90625 39.0671V6.63412C3.90625 5.08984 5.18594 3.83387 6.75937 3.83387H31.6797C33.1828 3.83387 34.4188 4.98249 34.5234 6.43476C34.5281 6.5007 34.5312 6.56665 34.5312 6.63412V39.0671Z"fill=currentColor></path><path d="M17.7516 7.26994L15.8321 7.6084C15.3121 7.70009 14.965 8.19594 15.0566 8.71591L20.0616 37.1007C20.1533 37.6207 20.6492 37.9679 21.1691 37.8762L23.0886 37.5377C23.6086 37.446 23.9558 36.9502 23.8641 36.4302L18.8591 8.04543C18.7674 7.52545 18.2716 7.17826 17.7516 7.26994Z"fill=currentColor>`);
var TypebotLogo = () => {
  return _tmpl$92();
};

// src/components/LiteBadge.tsx
var _tmpl$93 = /* @__PURE__ */ template(`<a href="https://www.typebot.io/?utm_source=litebadge"target=_blank rel="noopener noreferrer"class=lite-badge id=lite-badge><span>Made with Typebot`);
var LiteBadge = (props7) => {
  let liteBadge;
  let elementObserver;
  let attributeObserver;
  const defaultStyles = {
    display: "flex",
    opacity: "1",
    visibility: "visible",
    "pointer-events": "auto",
    transform: "none",
    "clip-path": "none",
    width: "auto",
    height: "auto",
    position: "absolute",
    padding: "4px 8px",
    "background-color": "white",
    "z-index": "50",
    "border-radius": "4px",
    color: "rgb(17 24 39)",
    gap: "8px",
    "font-size": "14px",
    "line-height": "20px",
    "font-weight": "600",
    "border-width": "1px",
    "border-color": "#cecece",
    top: "auto",
    right: "auto",
    left: "auto",
    bottom: "20px",
    transition: "background-color 0.2s ease-in-out",
    "text-decoration": "none"
  };
  onMount(() => {
    if (!document || !props7.botContainer || !liteBadge) return;
    elementObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.removedNodes.forEach((removedNode) => {
          if ("id" in removedNode && liteBadge && removedNode.id === "lite-badge") {
            console.log("Sorry, you can't remove the brand \u{1F605}");
            props7.botContainer?.append(liteBadge);
          }
        });
      });
    });
    elementObserver.observe(props7.botContainer, {
      subtree: false,
      childList: true
    });
    attributeObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "attributes" && liteBadge) {
          if (mutation.attributeName === "style") {
            Object.assign(liteBadge.style, defaultStyles);
          }
          if (mutation.attributeName === "class") {
            liteBadge.className = "lite-badge";
          }
          if (mutation.attributeName === "href") {
            liteBadge.href = "https://www.typebot.io/?utm_source=litebadge";
          }
          if (mutation.attributeName === "id") {
            liteBadge.id = "lite-badge";
          }
        }
      });
    });
    attributeObserver.observe(liteBadge, {
      attributes: true,
      attributeFilter: ["style", "class", "href", "id"]
    });
  });
  onCleanup(() => {
    if (elementObserver) elementObserver.disconnect();
    if (attributeObserver) attributeObserver.disconnect();
  });
  return (() => {
    var _el$ = _tmpl$93(), _el$2 = _el$.firstChild;
    var _ref$ = liteBadge;
    typeof _ref$ === "function" ? use(_ref$, _el$) : liteBadge = _el$;
    style(_el$, defaultStyles);
    insert(_el$, createComponent(TypebotLogo, {}), _el$2);
    return _el$;
  })();
};

// src/components/ProgressBar.tsx
var _tmpl$94 = /* @__PURE__ */ template(`<div class=typebot-progress-bar-container><div class=typebot-progress-bar>`);
var ProgressBar = (props7) => (() => {
  var _el$ = _tmpl$94(), _el$2 = _el$.firstChild;
  createRenderEffect((_$p) => (_$p = `${props7.value}%`) != null ? _el$2.style.setProperty("width", _$p) : _el$2.style.removeProperty("width"));
  return _el$;
})();

// src/components/Bot.tsx
var _tmpl$95 = /* @__PURE__ */ template(`<style>`);
var _tmpl$226 = /* @__PURE__ */ template(`<div><div></div><div>Um produto <span><img src=https://leadfy.me/wp-content/uploads/2025/02/logoLeadFy.svg alt="Site Logo">`);
var _tmpl$320 = /* @__PURE__ */ template(`<a target=_blank rel=noreferrer>`);
var Bot = (props7) => {
  const [initialChatReply, setInitialChatReply] = createSignal();
  const [customCss, setCustomCss] = createSignal("");
  const [isInitialized, setIsInitialized] = createSignal(false);
  const [error, setError] = createSignal();
  const initializeBot = async () => {
    if (props7.font) injectFont(props7.font);
    setIsInitialized(true);
    const urlParams = new URLSearchParams(location.search);
    props7.onInit?.();
    const prefilledVariables = {};
    urlParams.forEach((value, key) => {
      prefilledVariables[key] = value;
    });
    const typebotIdFromProps = typeof props7.typebot === "string" ? props7.typebot : void 0;
    const isPreview = typeof props7.typebot !== "string" || (props7.isPreview ?? false);
    const resultIdInStorage = getExistingResultIdFromStorage(typebotIdFromProps);
    const {
      data,
      error: error2
    } = await startChatQuery({
      stripeRedirectStatus: urlParams.get("redirect_status") ?? void 0,
      typebot: props7.typebot,
      apiHost: props7.apiHost,
      isPreview,
      resultId: isNotEmpty(props7.resultId) ? props7.resultId : resultIdInStorage,
      prefilledVariables: {
        ...prefilledVariables,
        ...props7.prefilledVariables
      },
      startFrom: props7.startFrom,
      sessionId: props7.sessionId
    });
    if (error2 instanceof HTTPError) {
      if (isPreview) {
        return setError(new Error(`An error occurred while loading the bot.`, {
          cause: {
            status: error2.response.status,
            body: await error2.response.json()
          }
        }));
      }
      if (error2.response.status === 400 || error2.response.status === 403) return setError(new Error((await error2.response.json()).message));
      if (error2.response.status === 404) return setError(new Error("The bot you're looking for doesn't exist."));
      return setError(new Error(`Error! Couldn't initiate the chat. (${error2.response.statusText})`));
    }
    if (error2 instanceof CorsError) {
      return setError(new Error(error2.message));
    }
    if (!data) {
      if (error2) {
        console.error(error2);
        if (isPreview) {
          return setError(new Error(`Error! Could not reach server. Check your connection.`, {
            cause: error2
          }));
        }
      }
      return setError(new Error("Error! Could not reach server. Check your connection."));
    }
    if (data.resultId && typebotIdFromProps && (data.typebot.settings.general?.rememberUser?.isEnabled ?? defaultSettings.general.rememberUser.isEnabled)) {
      if (resultIdInStorage && resultIdInStorage !== data.resultId) wipeExistingChatStateInStorage(data.typebot.id);
      const storage = data.typebot.settings.general?.rememberUser?.storage ?? defaultSettings.general.rememberUser.storage;
      setResultInStorage(storage)(typebotIdFromProps, data.resultId);
      const initialChatInStorage = getInitialChatReplyFromStorage(data.typebot.id);
      if (initialChatInStorage && initialChatInStorage.typebot.publishedAt && data.typebot.publishedAt) {
        if (new Date(initialChatInStorage.typebot.publishedAt).getTime() === new Date(data.typebot.publishedAt).getTime()) {
          setInitialChatReply(initialChatInStorage);
        } else {
          wipeExistingChatStateInStorage(data.typebot.id);
          setInitialChatReply(data);
          setInitialChatReplyInStorage(data, {
            typebotId: data.typebot.id,
            storage
          });
        }
      } else {
        setInitialChatReply(data);
        setInitialChatReplyInStorage(data, {
          typebotId: data.typebot.id,
          storage
        });
      }
      props7.onChatStatePersisted?.(true);
    } else {
      wipeExistingChatStateInStorage(data.typebot.id);
      setInitialChatReply(data);
      if (data.input?.id && props7.onNewInputBlock) props7.onNewInputBlock(data.input);
      if (data.logs) props7.onNewLogs?.(data.logs);
      props7.onChatStatePersisted?.(false);
    }
    setCustomCss(data.typebot.theme.customCss ?? "");
  };
  createEffect(() => {
    if (isNotDefined(props7.typebot) || isInitialized()) return;
    initializeBot().then();
  });
  createEffect(() => {
    if (isNotDefined(props7.typebot) || typeof props7.typebot === "string") return;
    setCustomCss(props7.typebot.theme.customCss ?? "");
    if (props7.typebot.theme.general?.progressBar?.isEnabled && initialChatReply() && !initialChatReply()?.typebot.theme.general?.progressBar?.isEnabled) {
      setIsInitialized(false);
      initializeBot().then();
    }
  });
  onCleanup(() => {
    setIsInitialized(false);
  });
  return [(() => {
    var _el$ = _tmpl$95();
    insert(_el$, colors_default);
    return _el$;
  })(), (() => {
    var _el$2 = _tmpl$95();
    insert(_el$2, customCss);
    return _el$2;
  })(), createComponent(Show, {
    get when() {
      return error();
    },
    keyed: true,
    children: (error2) => createComponent(ErrorMessage, {
      error: error2
    })
  }), createComponent(Show, {
    get when() {
      return initialChatReply();
    },
    keyed: true,
    children: (initialChatReply2) => createComponent(BotContent, {
      get ["class"]() {
        return props7.class;
      },
      get initialChatReply() {
        return {
          ...initialChatReply2,
          typebot: {
            ...initialChatReply2.typebot,
            settings: typeof props7.typebot === "string" ? initialChatReply2.typebot?.settings : props7.typebot?.settings,
            theme: typeof props7.typebot === "string" ? initialChatReply2.typebot?.theme : props7.typebot?.theme
          }
        };
      },
      get context() {
        return {
          apiHost: props7.apiHost,
          wsHost: props7.wsHost,
          isPreview: typeof props7.typebot !== "string" || (props7.isPreview ?? false),
          resultId: initialChatReply2.resultId,
          sessionId: initialChatReply2.sessionId,
          typebot: initialChatReply2.typebot,
          storage: initialChatReply2.typebot.settings.general?.rememberUser?.isEnabled && !(typeof props7.typebot !== "string" || (props7.isPreview ?? false)) ? initialChatReply2.typebot.settings.general?.rememberUser?.storage ?? defaultSettings.general.rememberUser.storage : void 0
        };
      },
      get progressBarRef() {
        return props7.progressBarRef;
      },
      get onNewInputBlock() {
        return props7.onNewInputBlock;
      },
      get onNewLogs() {
        return props7.onNewLogs;
      },
      get onAnswer() {
        return props7.onAnswer;
      },
      get onEnd() {
        return props7.onEnd;
      },
      get onScriptExecutionSuccess() {
        return props7.onScriptExecutionSuccess;
      }
    })
  })];
};
var BotContent = (props7) => {
  const [progressValue, setProgressValue] = persist(createSignal(props7.initialChatReply.progress), {
    storage: props7.context.storage,
    key: `typebot-${props7.context.typebot.id}-progressValue`
  });
  let botContainerElement;
  onMount(() => {
    if (!botContainerElement) return;
    setBotContainer(botContainerElement);
    setBotContainerHeight(`${botContainerElement.clientHeight}px`);
  });
  createEffect(() => {
    injectFont(props7.initialChatReply.typebot.theme.general?.font ?? {
      type: defaultFontType,
      family: defaultFontFamily
    });
    if (!botContainerElement) return;
    setCssVariablesValue({
      theme: mergeThemes(props7.initialChatReply.typebot.theme, props7.initialChatReply.dynamicTheme),
      container: botContainerElement,
      isPreview: props7.context.isPreview,
      typebotVersion: isTypebotVersionAtLeastV6(props7.initialChatReply.typebot.version) ? props7.initialChatReply.typebot.version : "6"
    });
  });
  return (() => {
    var _el$3 = _tmpl$226(), _el$4 = _el$3.firstChild, _el$5 = _el$4.nextSibling, _el$6 = _el$5.firstChild, _el$8 = _el$6.nextSibling, _el$9 = _el$8.firstChild;
    var _ref$ = botContainerElement;
    typeof _ref$ === "function" ? use(_ref$, _el$3) : botContainerElement = _el$3;
    _el$3.style.setProperty("border-radius", "20px");
    _el$3.style.setProperty("padding", "10px");
    insert(_el$3, createComponent(Show, {
      get when() {
        return isDefined(progressValue()) && props7.initialChatReply.typebot.theme.general?.progressBar?.isEnabled;
      },
      get children() {
        return createComponent(Show, {
          get when() {
            return props7.progressBarRef && (props7.initialChatReply.typebot.theme.general?.progressBar?.position ?? defaultProgressBarPosition) === "fixed";
          },
          get fallback() {
            return createComponent(ProgressBar, {
              get value() {
                return progressValue();
              }
            });
          },
          get children() {
            return createComponent(Portal, {
              get mount() {
                return props7.progressBarRef;
              },
              get children() {
                return createComponent(ProgressBar, {
                  get value() {
                    return progressValue();
                  }
                });
              }
            });
          }
        });
      }
    }), _el$4);
    var _ref$2 = botContainerElement;
    typeof _ref$2 === "function" ? use(_ref$2, _el$4) : botContainerElement = _el$4;
    _el$4.style.setProperty("border-radius", "20px");
    _el$4.style.setProperty("background", "#FFFFFF");
    insert(_el$4, createComponent(ConversationContainer, {
      get context() {
        return props7.context;
      },
      get initialChatReply() {
        return props7.initialChatReply;
      },
      get onNewInputBlock() {
        return props7.onNewInputBlock;
      },
      get onAnswer() {
        return props7.onAnswer;
      },
      get onEnd() {
        return props7.onEnd;
      },
      get onNewLogs() {
        return props7.onNewLogs;
      },
      onProgressUpdate: setProgressValue,
      get onScriptExecutionSuccess() {
        return props7.onScriptExecutionSuccess;
      }
    }));
    insert(_el$3, createComponent(Show, {
      get when() {
        return props7.initialChatReply.typebot.settings.general?.isBrandingEnabled;
      },
      get children() {
        return createComponent(LiteBadge, {
          botContainer: botContainerElement
        });
      }
    }), _el$5);
    insert(_el$3, createComponent(Toaster, {
      toaster,
      "class": "w-full",
      children: (toast) => createComponent(toast_exports.Root, {
        "class": "flex flex-col pl-4 py-4 pr-8 gap-2 max-w-[350px] rounded-chat text-input-text border-input border-input-border bg-input-bg shadow-input data-[state=open]:animate-fade-in-from-bottom data-[state=closed]:animate-fade-out-from-bottom",
        get children() {
          return [createComponent(toast_exports.Title, {
            "class": "font-semibold",
            get children() {
              return toast().title;
            }
          }), createComponent(toast_exports.Description, {
            "class": "text-sm",
            get children() {
              return toast().description;
            }
          }), createComponent(toast_exports.CloseTrigger, {
            get ["class"]() {
              return cn("absolute right-2 top-2", buttonVariants({
                variant: "secondary",
                size: "icon"
              }));
            },
            get children() {
              return createComponent(CloseIcon, {
                "class": "w-4 h-4"
              });
            }
          }), createComponent(Show, {
            get when() {
              return toast().meta?.link;
            },
            children: (link) => (() => {
              var _el$10 = _tmpl$320();
              insert(_el$10, () => props7.initialChatReply.typebot.settings.general?.systemMessages?.popupBlockedButtonLabel ?? defaultSystemMessages.popupBlockedButtonLabel);
              createRenderEffect((_p$) => {
                var _v$4 = link(), _v$5 = cn(buttonVariants({
                  variant: "primary",
                  size: "sm"
                }), "no-underline");
                _v$4 !== _p$.e && setAttribute(_el$10, "href", _p$.e = _v$4);
                _v$5 !== _p$.t && className(_el$10, _p$.t = _v$5);
                return _p$;
              }, {
                e: void 0,
                t: void 0
              });
              return _el$10;
            })()
          })];
        }
      })
    }), _el$5);
    _el$5.style.setProperty("display", "flex");
    _el$5.style.setProperty("align-self", "center");
    _el$5.style.setProperty("align-items", "center");
    _el$5.style.setProperty("gap", "10px");
    _el$5.style.setProperty("color", "#777777");
    _el$5.style.setProperty("font-size", "10px");
    _el$5.style.setProperty("padding-top", "10px");
    _el$9.style.setProperty("width", "50px");
    createRenderEffect((_p$) => {
      var _v$ = props7.context.typebot.theme.chat?.container?.backgroundColor, _v$2 = cx("relative flex w-full h-full text-base overflow-hidden flex-col justify-center items-center typebot-container", props7.class), _v$3 = cx("relative flex w-full h-full text-base flex-col justify-center items-center typebot-container", props7.class);
      _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$3.style.setProperty("background", _v$) : _el$3.style.removeProperty("background"));
      _v$2 !== _p$.t && className(_el$3, _p$.t = _v$2);
      _v$3 !== _p$.a && className(_el$4, _p$.a = _v$3);
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$3;
  })();
};

// src/components/inputs/EmailInput.tsx
var _tmpl$96 = /* @__PURE__ */ template(`<div class="typebot-input-form flex w-full gap-2 items-end max-w-[350px]"><div class="flex typebot-input w-full">`);
var EmailInput2 = (props7) => {
  const [inputValue, setInputValue2] = createSignal(props7.defaultValue ?? "");
  let inputRef;
  const handleInput = (inputValue2) => setInputValue2(inputValue2);
  const checkIfInputIsValid = () => inputRef?.value !== "" && inputRef?.reportValidity();
  const submit = () => {
    if (checkIfInputIsValid()) props7.onSubmit({
      type: "text",
      value: inputRef?.value ?? inputValue()
    });
    else inputRef?.focus();
  };
  const submitWhenEnter = (e) => {
    if (e.key === "Enter") submit();
  };
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
    window.addEventListener("message", processIncomingEvent);
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot) return;
    if (data.command === "setInputValue") setInputValue2(data.value);
  };
  return (() => {
    var _el$ = _tmpl$96(), _el$2 = _el$.firstChild;
    _el$.$$keydown = submitWhenEnter;
    insert(_el$2, createComponent(ShortTextInput, {
      ref(r$) {
        var _ref$ = inputRef;
        typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
      },
      get name() {
        return props7.name;
      },
      get value() {
        return inputValue();
      },
      onInput: handleInput,
      type: "email",
      autocomplete: "email"
    }));
    createRenderEffect((_$p) => (_$p = props7.error ? " #FF4949" : "") != null ? _el$2.style.setProperty("border-color", _$p) : _el$2.style.removeProperty("border-color"));
    return _el$;
  })();
};
delegateEvents(["keydown"]);

// src/components/inputs/PhoneInput.tsx
var _tmpl$97 = /* @__PURE__ */ template(`<div class="typebot-input-form flex w-full gap-2 items-end max-w-[350px]"><div class="flex typebot-input w-full"><div class="relative typebot-country-select flex justify-center items-center"><div class="pl-2 pr-1 flex items-center gap-2"><span></span></div><select class="absolute top-0 left-0 w-full h-full cursor-pointer opacity-0">`);
var _tmpl$227 = /* @__PURE__ */ template(`<option> `);
var PhoneInput2 = (props7) => {
  const [selectedCountryCode, setSelectedCountryCode] = createSignal(isEmpty(props7.defaultCountryCode) ? "INT" : props7.defaultCountryCode);
  console.log(props7.defaultCountryCode);
  console.log(selectedCountryCode());
  const [inputValue, setInputValue2] = createSignal(props7.defaultValue ?? "");
  let inputRef;
  const handleInput = (inputValue2) => {
    setInputValue2(inputValue2);
    if (inputValue2?.startsWith("+") && inputValue2.length > 2) {
      const matchedCountry = phoneCountries.reduce((matchedCountry2, country) => {
        if (!country?.dial_code || matchedCountry2 !== null && !matchedCountry2.dial_code) {
          return matchedCountry2;
        }
        if (inputValue2?.startsWith(country.dial_code) && country.dial_code.length > (matchedCountry2?.dial_code.length ?? 0)) {
          return country;
        }
        return matchedCountry2;
      }, null);
      if (matchedCountry) setSelectedCountryCode(matchedCountry.code);
    }
  };
  const checkIfInputIsValid = () => inputRef?.value !== "" && inputRef?.reportValidity();
  const submit = () => {
    const selectedCountryDialCode = phoneCountries.find((country) => country.code === selectedCountryCode())?.dial_code;
    if (checkIfInputIsValid()) {
      const val = inputRef?.value ?? inputValue();
      props7.onSubmit({
        type: "text",
        value: val.startsWith("+") ? val : `${selectedCountryDialCode ?? ""}${val}`
      });
    } else inputRef?.focus();
  };
  const submitWhenEnter = (e) => {
    if (e.key === "Enter") submit();
  };
  const selectNewCountryCode = (event) => {
    const selectedCountry = phoneCountries.find((country) => country.code === event.currentTarget.value);
    if (!selectedCountry) return;
    const currentCountry = phoneCountries.find((country) => country.code === selectedCountryCode());
    if (inputValue() === "" || currentCountry && inputValue() === currentCountry.dial_code) setInputValue2(selectedCountry.dial_code);
    setSelectedCountryCode(selectedCountry.code);
    inputRef?.focus();
  };
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
    window.addEventListener("message", processIncomingEvent);
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot) return;
    if (data.command === "setInputValue") setInputValue2(data.value);
  };
  return (() => {
    var _el$ = _tmpl$97(), _el$2 = _el$.firstChild, _el$3 = _el$2.firstChild, _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild, _el$6 = _el$4.nextSibling;
    _el$.$$keydown = submitWhenEnter;
    insert(_el$5, () => phoneCountries.find((country) => selectedCountryCode() === country.code)?.flag);
    insert(_el$4, createComponent(ChevronDownIcon, {
      "class": "w-3"
    }), null);
    _el$6.addEventListener("change", selectNewCountryCode);
    insert(_el$6, createComponent(For, {
      each: phoneCountries,
      children: (country) => (() => {
        var _el$7 = _tmpl$227(), _el$8 = _el$7.firstChild;
        insert(_el$7, () => country.name, _el$8);
        insert(_el$7, () => country.dial_code ? `(${country.dial_code})` : "", null);
        createRenderEffect(() => _el$7.selected = country.code === selectedCountryCode());
        createRenderEffect(() => _el$7.value = country.code);
        return _el$7;
      })()
    }));
    insert(_el$2, createComponent(ShortTextInput, {
      type: "tel",
      get name() {
        return props7.name;
      },
      ref(r$) {
        var _ref$ = inputRef;
        typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
      },
      get value() {
        return inputValue();
      },
      onInput: handleInput,
      get autofocus() {
        return !isMobile();
      }
    }), null);
    createRenderEffect((_$p) => (_$p = props7.error ? " #FF4949" : "") != null ? _el$2.style.setProperty("border-color", _$p) : _el$2.style.removeProperty("border-color"));
    return _el$;
  })();
};
delegateEvents(["keydown"]);

// src/components/inputs/TextInput.tsx
var _tmpl$98 = /* @__PURE__ */ template(`<div class="p-2 flex gap-2 border-gray-100 overflow-auto">`);
var _tmpl$228 = /* @__PURE__ */ template(`<div>`);
var _tmpl$321 = /* @__PURE__ */ template(`<div><div>`);
var TextInput2 = (props7) => {
  const [inputValue, setInputValue2] = createSignal(props7.defaultValue ?? "");
  const [selectedFiles, setSelectedFiles] = createSignal([]);
  const [uploadProgress, setUploadProgress] = createSignal(void 0);
  const [isDraggingOver, setIsDraggingOver] = createSignal(false);
  const [recordingStatus, setRecordingStatus] = createSignal("stopped");
  let inputRef;
  let mediaRecorder;
  const recordedChunks = [];
  const handleInput = (inputValue2) => setInputValue2(inputValue2);
  const checkIfInputIsValid = () => inputRef?.value !== "" && inputRef?.reportValidity();
  const submit = async () => {
    console.log("submit recording status: ", recordingStatus());
    console.log("submit mediaRecorder: ", mediaRecorder);
    if (recordingStatus() === "started" && mediaRecorder) {
      console.log("stopping recording ");
      mediaRecorder.stop();
      return;
    }
    if (checkIfInputIsValid()) {
      let attachments;
      if (selectedFiles().length > 0) {
        setUploadProgress(void 0);
        const urls = await uploadFiles({
          apiHost: props7.context.apiHost ?? guessApiHost({
            ignoreChatApiUrl: true
          }),
          files: selectedFiles().map((file) => ({
            file,
            input: {
              blockId: props7.block.id,
              sessionId: props7.context.sessionId,
              fileName: file.name
            }
          })),
          onUploadProgress: setUploadProgress
        });
        attachments = urls?.map((urls2, index) => urls2 ? {
          ...urls2,
          blobUrl: URL.createObjectURL(selectedFiles()[index])
        } : null).filter(isDefined);
      }
      props7.onSubmit({
        type: "text",
        value: inputRef?.value ?? inputValue(),
        attachments
      });
    } else inputRef?.focus();
  };
  const submitIfCtrlEnter = (e) => {
    if (!props7.block.options?.isLong) return;
    if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) submit();
  };
  onMount(() => {
    if (!isMobile() && inputRef) inputRef.focus({
      preventScroll: true
    });
    window.addEventListener("message", processIncomingEvent);
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot) {
      return;
    }
    if (data.command === "setInputValue") {
      setInputValue2(data.value);
    }
  };
  return (() => {
    var _el$ = _tmpl$321(), _el$2 = _el$.firstChild;
    insert(_el$2, createComponent(Show, {
      get when() {
        return recordingStatus() !== "started";
      },
      get children() {
        return [createComponent(Show, {
          get when() {
            return selectedFiles().length;
          },
          get children() {
            var _el$3 = _tmpl$98();
            _el$3.style.setProperty("border-bottom-width", "1px");
            return _el$3;
          }
        }), (() => {
          var _el$4 = _tmpl$228();
          insert(_el$4, (() => {
            var _c$ = createMemo(() => !!props7.isLong);
            return () => _c$() ? createComponent(Textarea, {
              get name() {
                return props7.name;
              },
              ref(r$) {
                var _ref$ = inputRef;
                typeof _ref$ === "function" ? _ref$(r$) : inputRef = r$;
              },
              onInput: handleInput,
              onKeyDown: submitIfCtrlEnter,
              get value() {
                return inputValue();
              }
            }) : createComponent(ShortTextInput, {
              get name() {
                return props7.name;
              },
              ref(r$) {
                var _ref$2 = inputRef;
                typeof _ref$2 === "function" ? _ref$2(r$) : inputRef = r$;
              },
              onInput: handleInput,
              get value() {
                return inputValue();
              }
            });
          })());
          createRenderEffect(() => className(_el$4, cx("flex justify-between", "items-end")));
          return _el$4;
        })()];
      }
    }));
    createRenderEffect((_p$) => {
      var _v$ = cx("typebot-input-form flex w-full gap-2 items-end", "max-w-full"), _v$2 = cx("relative typebot-input flex-col w-full", isDraggingOver() && "filter brightness-95"), _v$3 = props7.error ? " #FF4949" : "";
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$2, _p$.t = _v$2);
      _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$2.style.setProperty("border-color", _v$3) : _el$2.style.removeProperty("border-color"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$;
  })();
};

// src/components/BotPreForm.tsx
var _tmpl$99 = /* @__PURE__ */ template(`<style>`);
var _tmpl$229 = /* @__PURE__ */ template(`<div><div><div class=typebot-chat-view><div class="relative px-2 text-center"></div></div><div class="overflow-y-auto relative scrollable-container typebot-chat-view scroll-smooth w-full flex flex-col items-center"><div class="max-w-chat-container w-full flex flex-col gap-2"></div></div></div><div>Um produto <span><img src=https://leadfy.me/wp-content/uploads/2025/02/logoLeadFy.svg alt="Site Logo">`);
var _tmpl$322 = /* @__PURE__ */ template(`<h1 class="text-3xl font-extrabold text-gray-900">Ol\xE1! <span class=inline-block>\u{1F44B}</span> Vamos conversar?`);
var _tmpl$414 = /* @__PURE__ */ template(`<p class="text-sm text-gray-700 mt-2">Que bom te ver, estou pronto para te ajudar!<br>Vamos juntos encontrar o que voc\xEA precisa?`);
var _tmpl$513 = /* @__PURE__ */ template(`<div class="flex items-center bg-gray-100 text-sm font-semibold text-gray-800 rounded-full px-4 py-2 -mt-4 mx-6 shadow w-fit"><span class="w-6 h-6 rounded-full bg-lime-300 flex items-center justify-center text-lg mr-2">\u{1F4AC}</span>Preencha os campos abaixo para iniciar`);
var _tmpl$612 = /* @__PURE__ */ template(`<form class="px-6 space-y-4"><div><label for=name class="block text-sm font-semibold text-gray-800 mb-1">Seu nome <span class="text-sm font-normal text-gray-500">(ou como gosta de ser chamado \u{1F609})</span></label></div><div><label for=email class="block text-sm font-semibold text-gray-800 mb-1">Seu e-mail <span class="text-sm font-normal text-gray-500">(aquele que voc\xEA sempre usa)</span></label></div><div><label for=phone class="block text-sm font-semibold text-gray-800 mb-1">Seu telefone <span class="text-sm font-normal text-gray-500">(com DDD)`);
var _tmpl$710 = /* @__PURE__ */ template(`<div class="flex items-center text-red-600 text-xs"><svg xmlns=http://www.w3.org/2000/svg class="h-5 w-5 mr-1"viewBox="0 0 20 20"fill=currentColor><path fill-rule=evenodd d="M8.257 3.099c.765-1.36 2.72-1.36 3.485 0l6.518 11.591c.75 1.334-.214 2.99-1.742 2.99H3.48c-1.528 0-2.492-1.656-1.742-2.99L8.257 3.1zM11 13a1 1 0 10-2 0 1 1 0 002 0zm-1-2a.75.75 0 01-.75-.75V8a.75.75 0 011.5 0v2.25c0 .414-.336.75-.75.75z"clip-rule=evenodd></path></svg><span>Ops! O seu nome n\xE3o foi informado.`);
var _tmpl$810 = /* @__PURE__ */ template(`<div class="flex items-center text-red-600 text-xs"><svg xmlns=http://www.w3.org/2000/svg class="h-5 w-5 mr-1"viewBox="0 0 20 20"fill=currentColor><path fill-rule=evenodd d="M8.257 3.099c.765-1.36 2.72-1.36 3.485 0l6.518 11.591c.75 1.334-.214 2.99-1.742 2.99H3.48c-1.528 0-2.492-1.656-1.742-2.99L8.257 3.1zM11 13a1 1 0 10-2 0 1 1 0 002 0zm-1-2a.75.75 0 01-.75-.75V8a.75.75 0 011.5 0v2.25c0 .414-.336.75-.75.75z"clip-rule=evenodd></path></svg><span>Ops! O e-mail informado parece estar incorreto.`);
var _tmpl$910 = /* @__PURE__ */ template(`<div class="flex items-center text-red-600 text-xs"><svg xmlns=http://www.w3.org/2000/svg class="h-5 w-5 mr-1"viewBox="0 0 20 20"fill=currentColor><path fill-rule=evenodd d="M8.257 3.099c.765-1.36 2.72-1.36 3.485 0l6.518 11.591c.75 1.334-.214 2.99-1.742 2.99H3.48c-1.528 0-2.492-1.656-1.742-2.99L8.257 3.1zM11 13a1 1 0 10-2 0 1 1 0 002 0zm-1-2a.75.75 0 01-.75-.75V8a.75.75 0 011.5 0v2.25c0 .414-.336.75-.75.75z"clip-rule=evenodd></path></svg><span>Ops! O telefone informado parece estar incorreto.`);
var BotPreForm = (props7) => {
  const [initialChatReply, setInitialChatReply] = createSignal();
  const [customCss, setCustomCss] = createSignal("");
  const [isInitialized, setIsInitialized] = createSignal(false);
  const [error, setError] = createSignal();
  const initializeBot = async () => {
    if (props7.font) injectFont(props7.font);
    setIsInitialized(true);
    const urlParams = new URLSearchParams(location.search);
    props7.onInit?.();
    const prefilledVariables = {};
    urlParams.forEach((value, key) => {
      prefilledVariables[key] = value;
    });
    const typebotIdFromProps = typeof props7.typebot === "string" ? props7.typebot : void 0;
    const isPreview = typeof props7.typebot !== "string" || (props7.isPreview ?? false);
    const resultIdInStorage = getExistingResultIdFromStorage(typebotIdFromProps);
    const {
      data,
      error: error2
    } = await startChatQuery({
      stripeRedirectStatus: urlParams.get("redirect_status") ?? void 0,
      typebot: props7.typebot,
      apiHost: props7.apiHost,
      isPreview,
      resultId: isNotEmpty(props7.resultId) ? props7.resultId : resultIdInStorage,
      prefilledVariables: {
        ...prefilledVariables,
        ...props7.prefilledVariables
      },
      startFrom: props7.startFrom,
      sessionId: props7.sessionId
    });
    if (error2 instanceof HTTPError) {
      if (isPreview) {
        return setError(new Error(`An error occurred while loading the bot.`, {
          cause: {
            status: error2.response.status,
            body: await error2.response.json()
          }
        }));
      }
      if (error2.response.status === 400 || error2.response.status === 403) return setError(new Error((await error2.response.json()).message));
      if (error2.response.status === 404) return setError(new Error("The bot you're looking for doesn't exist."));
      return setError(new Error(`Error! Couldn't initiate the chat. (${error2.response.statusText})`));
    }
    if (error2 instanceof CorsError) {
      return setError(new Error(error2.message));
    }
    if (!data) {
      if (error2) {
        console.error(error2);
        if (isPreview) {
          return setError(new Error(`Error! Could not reach server. Check your connection.`, {
            cause: error2
          }));
        }
      }
      return setError(new Error("Error! Could not reach server. Check your connection."));
    }
    if (data.resultId && typebotIdFromProps && (data.typebot.settings.general?.rememberUser?.isEnabled ?? defaultSettings.general.rememberUser.isEnabled)) {
      if (resultIdInStorage && resultIdInStorage !== data.resultId) wipeExistingChatStateInStorage(data.typebot.id);
      const storage = data.typebot.settings.general?.rememberUser?.storage ?? defaultSettings.general.rememberUser.storage;
      setResultInStorage(storage)(typebotIdFromProps, data.resultId);
      const initialChatInStorage = getInitialChatReplyFromStorage(data.typebot.id);
      if (initialChatInStorage && initialChatInStorage.typebot.publishedAt && data.typebot.publishedAt) {
        if (new Date(initialChatInStorage.typebot.publishedAt).getTime() === new Date(data.typebot.publishedAt).getTime()) {
          setInitialChatReply(initialChatInStorage);
        } else {
          wipeExistingChatStateInStorage(data.typebot.id);
          setInitialChatReply(data);
          setInitialChatReplyInStorage(data, {
            typebotId: data.typebot.id,
            storage
          });
        }
      } else {
        setInitialChatReply(data);
        setInitialChatReplyInStorage(data, {
          typebotId: data.typebot.id,
          storage
        });
      }
      props7.onChatStatePersisted?.(true);
    } else {
      wipeExistingChatStateInStorage(data.typebot.id);
      setInitialChatReply(data);
      if (data.input?.id && props7.onNewInputBlock) props7.onNewInputBlock(data.input);
      if (data.logs) props7.onNewLogs?.(data.logs);
      props7.onChatStatePersisted?.(false);
    }
    setCustomCss(data.typebot.theme.customCss ?? "");
  };
  createEffect(() => {
    if (isNotDefined(props7.typebot) || isInitialized()) return;
    initializeBot().then();
  });
  createEffect(() => {
    if (isNotDefined(props7.typebot) || typeof props7.typebot === "string") return;
    setCustomCss(props7.typebot.theme.customCss ?? "");
    if (props7.typebot.theme.general?.progressBar?.isEnabled && initialChatReply() && !initialChatReply()?.typebot.theme.general?.progressBar?.isEnabled) {
      setIsInitialized(false);
      initializeBot().then();
    }
  });
  onCleanup(() => {
    setIsInitialized(false);
  });
  return [(() => {
    var _el$ = _tmpl$99();
    insert(_el$, colors_default);
    return _el$;
  })(), (() => {
    var _el$2 = _tmpl$99();
    insert(_el$2, customCss);
    return _el$2;
  })(), createComponent(Show, {
    get when() {
      return error();
    },
    keyed: true,
    children: (error2) => createComponent(ErrorMessage, {
      error: error2
    })
  }), createComponent(Show, {
    get when() {
      return initialChatReply();
    },
    keyed: true,
    children: (initialChatReply2) => createComponent(BotContent2, {
      get setLead() {
        return props7.setLead;
      },
      get ["class"]() {
        return props7.class;
      },
      get initialChatReply() {
        return {
          ...initialChatReply2,
          typebot: {
            ...initialChatReply2.typebot,
            settings: typeof props7.typebot === "string" ? initialChatReply2.typebot?.settings : props7.typebot?.settings,
            theme: typeof props7.typebot === "string" ? initialChatReply2.typebot?.theme : props7.typebot?.theme
          }
        };
      },
      get context() {
        return {
          apiHost: props7.apiHost,
          wsHost: props7.wsHost,
          isPreview: typeof props7.typebot !== "string" || (props7.isPreview ?? false),
          resultId: initialChatReply2.resultId,
          sessionId: initialChatReply2.sessionId,
          typebot: initialChatReply2.typebot,
          storage: initialChatReply2.typebot.settings.general?.rememberUser?.isEnabled && !(typeof props7.typebot !== "string" || (props7.isPreview ?? false)) ? initialChatReply2.typebot.settings.general?.rememberUser?.storage ?? defaultSettings.general.rememberUser.storage : void 0
        };
      },
      get progressBarRef() {
        return props7.progressBarRef;
      },
      get onNewInputBlock() {
        return props7.onNewInputBlock;
      },
      get onNewLogs() {
        return props7.onNewLogs;
      },
      get onAnswer() {
        return props7.onAnswer;
      },
      get onEnd() {
        return props7.onEnd;
      },
      get onScriptExecutionSuccess() {
        return props7.onScriptExecutionSuccess;
      }
    })
  })];
};
var BotContent2 = (props7) => {
  const [success, setSuccess] = createSignal(false);
  const [error, setError] = createSignal({
    name: false,
    email: false,
    phone: false
  });
  let botContainerElement;
  onMount(() => {
    if (!botContainerElement) return;
    setBotContainer(botContainerElement);
    setBotContainerHeight(`${botContainerElement.clientHeight}px`);
  });
  createEffect(() => {
    injectFont(props7.initialChatReply.typebot.theme.general?.font ?? {
      type: defaultFontType,
      family: defaultFontFamily
    });
    if (!botContainerElement) return;
    setCssVariablesValue({
      theme: mergeThemes(props7.initialChatReply.typebot.theme, props7.initialChatReply.dynamicTheme),
      container: botContainerElement,
      isPreview: props7.context.isPreview,
      typebotVersion: isTypebotVersionAtLeastV6(props7.initialChatReply.typebot.version) ? props7.initialChatReply.typebot.version : "6"
    });
  });
  const onSubmit = (e) => {
    e.preventDefault();
    const formData = new FormData(e.target);
    const name = formData.get("name");
    const email = formData.get("email");
    const phone = formData.get("phone");
    if (!name || !email || !phone) {
      console.log({
        name: !name,
        email: !email,
        phone: !phone
      });
      setError({
        name: !name,
        email: !email,
        phone: !phone
      });
      return;
    }
    setError({
      name: false,
      email: false,
      phone: false
    });
    setSuccess(true);
    setTimeout(() => {
      props7.setLead({
        name,
        email,
        phone
      });
    }, 750);
  };
  return (() => {
    var _el$3 = _tmpl$229(), _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild, _el$6 = _el$5.firstChild, _el$7 = _el$5.nextSibling, _el$8 = _el$7.firstChild, _el$9 = _el$4.nextSibling, _el$10 = _el$9.firstChild, _el$12 = _el$10.nextSibling, _el$13 = _el$12.firstChild;
    var _ref$ = botContainerElement;
    typeof _ref$ === "function" ? use(_ref$, _el$3) : botContainerElement = _el$3;
    _el$3.style.setProperty("border-radius", "20px");
    _el$3.style.setProperty("background", "#f0f0f0");
    _el$3.style.setProperty("padding", "10px");
    var _ref$2 = botContainerElement;
    typeof _ref$2 === "function" ? use(_ref$2, _el$4) : botContainerElement = _el$4;
    _el$4.style.setProperty("border-radius", "20px");
    _el$4.style.setProperty("background", "#FFFFFF");
    _el$5.style.setProperty("padding", "0");
    _el$5.style.setProperty("width", "100%");
    _el$6.style.setProperty("border-radius", "16px");
    _el$6.style.setProperty("border-bottom-left-radius", "0");
    _el$6.style.setProperty("border-bottom-right-radius", "0");
    _el$6.style.setProperty("position", "relative");
    _el$6.style.setProperty("transition", "margin 0.5s ease-in-out");
    _el$6.style.setProperty("height", "auto");
    _el$6.style.setProperty("padding-top", "60px");
    _el$6.style.setProperty("padding-bottom", "65px");
    insert(_el$6, (() => {
      var _c$ = createMemo(() => !!!success());
      return () => _c$() && _tmpl$322();
    })(), null);
    insert(_el$6, (() => {
      var _c$2 = createMemo(() => !!!success());
      return () => _c$2() && _tmpl$414();
    })(), null);
    insert(_el$6, (() => {
      var _c$3 = createMemo(() => !!!success());
      return () => _c$3() && (() => {
        var _el$16 = _tmpl$513();
        _el$16.style.setProperty("z-index", "99999");
        _el$16.style.setProperty("background", "#F0F0F0");
        _el$16.style.setProperty("font-size", "12px");
        _el$16.style.setProperty("position", "absolute");
        _el$16.style.setProperty("bottom", "-20px");
        _el$16.style.setProperty("padding", "5px");
        _el$16.style.setProperty("justify-self", "anchor-center");
        return _el$16;
      })();
    })(), null);
    _el$7.style.setProperty("flex", "1");
    insert(_el$8, (() => {
      var _c$4 = createMemo(() => !!!success());
      return () => _c$4() && (() => {
        var _el$17 = _tmpl$612(), _el$18 = _el$17.firstChild, _el$19 = _el$18.firstChild, _el$20 = _el$18.nextSibling, _el$21 = _el$20.firstChild, _el$22 = _el$20.nextSibling, _el$23 = _el$22.firstChild;
        _el$17.addEventListener("submit", onSubmit);
        _el$17.style.setProperty("padding-top", "20px");
        insert(_el$18, createComponent(TextInput2, {
          name: "name",
          get error() {
            return error().name;
          },
          get context() {
            return props7.context;
          }
        }), null);
        insert(_el$18, (() => {
          var _c$5 = createMemo(() => !!error().name);
          return () => _c$5() && (() => {
            var _el$24 = _tmpl$710();
            _el$24.style.setProperty("color", "#FF4949");
            return _el$24;
          })();
        })(), null);
        insert(_el$20, createComponent(EmailInput2, {
          name: "email",
          get error() {
            return error().email;
          },
          get context() {
            return props7.context;
          }
        }), null);
        insert(_el$20, (() => {
          var _c$6 = createMemo(() => !!error().email);
          return () => _c$6() && (() => {
            var _el$25 = _tmpl$810();
            _el$25.style.setProperty("color", "#FF4949");
            return _el$25;
          })();
        })(), null);
        insert(_el$22, createComponent(PhoneInput2, {
          name: "phone",
          get error() {
            return error().phone;
          },
          get context() {
            return props7.context;
          },
          defaultCountryCode: "BR"
        }), null);
        insert(_el$22, (() => {
          var _c$7 = createMemo(() => !!error().phone);
          return () => _c$7() && (() => {
            var _el$26 = _tmpl$910();
            _el$26.style.setProperty("color", "#FF4949");
            return _el$26;
          })();
        })(), null);
        insert(_el$17, createComponent(Button, {
          type: "submit",
          fullWidth: true,
          children: "Iniciar conversa"
        }), null);
        return _el$17;
      })();
    })());
    _el$9.style.setProperty("display", "flex");
    _el$9.style.setProperty("align-self", "center");
    _el$9.style.setProperty("align-items", "center");
    _el$9.style.setProperty("gap", "10px");
    _el$9.style.setProperty("color", "#777777");
    _el$9.style.setProperty("font-size", "10px");
    _el$9.style.setProperty("padding-top", "10px");
    _el$13.style.setProperty("width", "50px");
    createRenderEffect((_p$) => {
      var _v$ = cx("relative flex w-full h-full text-base overflow-hidden flex-col justify-center items-center typebot-container", props7.class), _v$2 = cx("relative flex w-full h-full text-base flex-col justify-center items-center typebot-container", props7.class), _v$3 = props7.context.typebot.theme.chat?.container?.backgroundColor, _v$4 = success() ? "-500px" : "0";
      _v$ !== _p$.e && className(_el$3, _p$.e = _v$);
      _v$2 !== _p$.t && className(_el$4, _p$.t = _v$2);
      _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$6.style.setProperty("background", _v$3) : _el$6.style.removeProperty("background"));
      _v$4 !== _p$.o && ((_p$.o = _v$4) != null ? _el$6.style.setProperty("margin-top", _v$4) : _el$6.style.removeProperty("margin-top"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0,
      o: void 0
    });
    return _el$3;
  })();
};

// src/components/BotWrapper.tsx
var BotWrapper = (props7) => {
  const [leadName, setLeadName] = createSignal(null);
  const [leadEmail, setLeadEmail] = createSignal(null);
  const [leadPhone, setLeadPhone] = createSignal(null);
  return [createMemo(() => createMemo(() => !!(leadName() && leadEmail() && leadPhone()))() && createComponent(Bot, mergeProps(props7, {
    get prefilledVariables() {
      return {
        UserName: leadName(),
        UserEmail: leadEmail(),
        UserPhone: leadPhone()
      };
    }
  }))), createMemo(() => createMemo(() => !!(!leadName() || !leadEmail() || !leadPhone()))() && createComponent(BotPreForm, mergeProps(props7, {
    setLead: (values) => {
      console.log("Setting lead values:", values);
      setLeadName(values.name);
      setLeadEmail(values.email);
      setLeadPhone(values.phone);
    }
  })))];
};

// ../../forge/blocks/zendesk/src/constants.ts
var zendeskWebWidgetOpenedMessage = "Zendesk Web Widget Opened";

// src/assets/index.css
var assets_default = '*, ::before, ::after {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-gradient-from-position:  ;\n  --tw-gradient-via-position:  ;\n  --tw-gradient-to-position:  ;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n  --tw-contain-size:  ;\n  --tw-contain-layout:  ;\n  --tw-contain-paint:  ;\n  --tw-contain-style:  ;\n}\n\n::backdrop {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x:  ;\n  --tw-pan-y:  ;\n  --tw-pinch-zoom:  ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-gradient-from-position:  ;\n  --tw-gradient-via-position:  ;\n  --tw-gradient-to-position:  ;\n  --tw-ordinal:  ;\n  --tw-slashed-zero:  ;\n  --tw-numeric-figure:  ;\n  --tw-numeric-spacing:  ;\n  --tw-numeric-fraction:  ;\n  --tw-ring-inset:  ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur:  ;\n  --tw-brightness:  ;\n  --tw-contrast:  ;\n  --tw-grayscale:  ;\n  --tw-hue-rotate:  ;\n  --tw-invert:  ;\n  --tw-saturate:  ;\n  --tw-sepia:  ;\n  --tw-drop-shadow:  ;\n  --tw-backdrop-blur:  ;\n  --tw-backdrop-brightness:  ;\n  --tw-backdrop-contrast:  ;\n  --tw-backdrop-grayscale:  ;\n  --tw-backdrop-hue-rotate:  ;\n  --tw-backdrop-invert:  ;\n  --tw-backdrop-opacity:  ;\n  --tw-backdrop-saturate:  ;\n  --tw-backdrop-sepia:  ;\n  --tw-contain-size:  ;\n  --tw-contain-layout:  ;\n  --tw-contain-paint:  ;\n  --tw-contain-style:  ;\n}/*\n! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com\n*//*\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\n*/\n\n*,\n::before,\n::after {\n  box-sizing: border-box; /* 1 */\n  border-width: 0; /* 2 */\n  border-style: solid; /* 2 */\n  border-color: currentColor; /* 2 */\n}\n\n::before,\n::after {\n  --tw-content: \'\';\n}\n\n/*\n1. Use a consistent sensible line-height in all browsers.\n2. Prevent adjustments of font size after orientation changes in iOS.\n3. Use a more readable tab size.\n4. Use the user\'s configured `sans` font-family by default.\n5. Use the user\'s configured `sans` font-feature-settings by default.\n6. Use the user\'s configured `sans` font-variation-settings by default.\n7. Disable tap highlights on iOS\n*/\n\nhtml,\n:host {\n  line-height: 1.5; /* 1 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n  -moz-tab-size: 4; /* 3 */\n  -o-tab-size: 4;\n     tab-size: 4; /* 3 */\n  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */\n  font-feature-settings: normal; /* 5 */\n  font-variation-settings: normal; /* 6 */\n  -webkit-tap-highlight-color: transparent; /* 7 */\n}\n\n/*\n1. Remove the margin in all browsers.\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\n*/\n\nbody {\n  margin: 0; /* 1 */\n  line-height: inherit; /* 2 */\n}\n\n/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0; /* 1 */\n  color: inherit; /* 2 */\n  border-top-width: 1px; /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user\'s configured `mono` font-family by default.\n2. Use the user\'s configured `mono` font-feature-settings by default.\n3. Use the user\'s configured `mono` font-variation-settings by default.\n4. Correct the odd `em` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */\n  font-feature-settings: normal; /* 2 */\n  font-variation-settings: normal; /* 3 */\n  font-size: 1em; /* 4 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0; /* 1 */\n  border-color: inherit; /* 2 */\n  border-collapse: collapse; /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit; /* 1 */\n  font-feature-settings: inherit; /* 1 */\n  font-variation-settings: inherit; /* 1 */\n  font-size: 100%; /* 1 */\n  font-weight: inherit; /* 1 */\n  line-height: inherit; /* 1 */\n  letter-spacing: inherit; /* 1 */\n  color: inherit; /* 1 */\n  margin: 0; /* 2 */\n  padding: 0; /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\ninput:where([type=\'button\']),\ninput:where([type=\'reset\']),\ninput:where([type=\'submit\']) {\n  -webkit-appearance: button; /* 1 */\n  background-color: transparent; /* 2 */\n  background-image: none; /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type=\'search\'] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to `inherit` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nReset default styling for dialogs.\n*/\ndialog {\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user\'s configured gray 400 color.\n*/\n\ninput::-moz-placeholder, textarea::-moz-placeholder {\n  opacity: 1; /* 1 */\n  color: #9ca3af; /* 2 */\n}\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1; /* 1 */\n  color: #9ca3af; /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role="button"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don\'t get the pointer cursor.\n*/\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block; /* 1 */\n  vertical-align: middle; /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n[hidden]:where(:not([hidden="until-found"])) {\n  display: none;\n}\n.container {\n  width: 100%;\n}\n@media (min-width: 640px) {\n\n  .container {\n    max-width: 640px;\n  }\n}\n@media (min-width: 768px) {\n\n  .container {\n    max-width: 768px;\n  }\n}\n@media (min-width: 1024px) {\n\n  .container {\n    max-width: 1024px;\n  }\n}\n@media (min-width: 1280px) {\n\n  .container {\n    max-width: 1280px;\n  }\n}\n@media (min-width: 1536px) {\n\n  .container {\n    max-width: 1536px;\n  }\n}\n.pointer-events-none {\n  pointer-events: none;\n}\n.visible {\n  visibility: visible;\n}\n.static {\n  position: static;\n}\n.fixed {\n  position: fixed;\n}\n.absolute {\n  position: absolute;\n}\n.relative {\n  position: relative;\n}\n.inset-0 {\n  inset: 0px;\n}\n.-left-5 {\n  left: -20px;\n}\n.-right-2 {\n  right: -8px;\n}\n.-right-5 {\n  right: -20px;\n}\n.-top-2 {\n  top: -8px;\n}\n.bottom-5 {\n  bottom: 20px;\n}\n.bottom-\\[calc\\(100\\%\\+12px\\)\\] {\n  bottom: calc(100% + 12px);\n}\n.left-0 {\n  left: 0px;\n}\n.left-5 {\n  left: 20px;\n}\n.right-0 {\n  right: 0px;\n}\n.right-2 {\n  right: 8px;\n}\n.right-4 {\n  right: 16px;\n}\n.right-5 {\n  right: 20px;\n}\n.top-0 {\n  top: 0px;\n}\n.top-2 {\n  top: 8px;\n}\n.top-4 {\n  top: 16px;\n}\n.z-10 {\n  z-index: 10;\n}\n.z-20 {\n  z-index: 20;\n}\n.z-50 {\n  z-index: 50;\n}\n.z-\\[424242\\] {\n  z-index: 424242;\n}\n.m-2 {\n  margin: 8px;\n}\n.m-auto {\n  margin: auto;\n}\n.mx-4 {\n  margin-left: 16px;\n  margin-right: 16px;\n}\n.mx-6 {\n  margin-left: 24px;\n  margin-right: 24px;\n}\n.mx-auto {\n  margin-left: auto;\n  margin-right: auto;\n}\n.my-2 {\n  margin-top: 8px;\n  margin-bottom: 8px;\n}\n.-mr-1 {\n  margin-right: -4px;\n}\n.-mt-1 {\n  margin-top: -4px;\n}\n.-mt-4 {\n  margin-top: -16px;\n}\n.mb-1 {\n  margin-bottom: 4px;\n}\n.mb-2 {\n  margin-bottom: 8px;\n}\n.ml-2 {\n  margin-left: 8px;\n}\n.mr-1 {\n  margin-right: 4px;\n}\n.mr-2 {\n  margin-right: 8px;\n}\n.mt-1 {\n  margin-top: 4px;\n}\n.mt-2 {\n  margin-top: 8px;\n}\n.mt-4 {\n  margin-top: 16px;\n}\n.\\!block {\n  display: block !important;\n}\n.block {\n  display: block;\n}\n.inline-block {\n  display: inline-block;\n}\n.flex {\n  display: flex;\n}\n.inline-flex {\n  display: inline-flex;\n}\n.hidden {\n  display: none;\n}\n.aspect-\\[16\\/11\\] {\n  aspect-ratio: 16/11;\n}\n.size-10 {\n  width: 40px;\n  height: 40px;\n}\n.size-4 {\n  width: 16px;\n  height: 16px;\n}\n.size-6 {\n  width: 24px;\n  height: 24px;\n}\n.h-10 {\n  height: 40px;\n}\n.h-2 {\n  height: 8px;\n}\n.h-2\\.5 {\n  height: 10px;\n}\n.h-3 {\n  height: 12px;\n}\n.h-4 {\n  height: 16px;\n}\n.h-5 {\n  height: 20px;\n}\n.h-6 {\n  height: 24px;\n}\n.h-7 {\n  height: 28px;\n}\n.h-8 {\n  height: 32px;\n}\n.h-9 {\n  height: 36px;\n}\n.h-\\[20\\%\\] {\n  height: 20%;\n}\n.h-\\[56px\\] {\n  height: 56px;\n}\n.h-\\[58px\\] {\n  height: 58px;\n}\n.h-\\[80vh\\] {\n  height: 80vh;\n}\n.h-full {\n  height: 100%;\n}\n.h-screen {\n  height: 100vh;\n}\n.max-h-80 {\n  max-height: 320px;\n}\n.max-h-\\[464px\\] {\n  max-height: 464px;\n}\n.max-h-\\[calc\\(100vh-1rem\\)\\] {\n  max-height: calc(100vh - 1rem);\n}\n.min-h-full {\n  min-height: 100%;\n}\n.w-10 {\n  width: 40px;\n}\n.w-2 {\n  width: 8px;\n}\n.w-3 {\n  width: 12px;\n}\n.w-4 {\n  width: 16px;\n}\n.w-5 {\n  width: 20px;\n}\n.w-6 {\n  width: 24px;\n}\n.w-64 {\n  width: 256px;\n}\n.w-8 {\n  width: 32px;\n}\n.w-\\[35px\\] {\n  width: 35px;\n}\n.w-\\[58px\\] {\n  width: 58px;\n}\n.w-\\[60\\%\\] {\n  width: 60%;\n}\n.w-\\[min\\(calc\\(var\\(--slides-per-page\\)\\*270px\\)\\2c 100\\%\\)\\] {\n  width: min(calc(var(--slides-per-page) * 270px),100%);\n}\n.w-fit {\n  width: -moz-fit-content;\n  width: fit-content;\n}\n.w-full {\n  width: 100%;\n}\n.w-screen {\n  width: 100vw;\n}\n.min-w-0 {\n  min-width: 0px;\n}\n.min-w-\\[250px\\] {\n  min-width: 250px;\n}\n.max-w-\\[350px\\] {\n  max-width: 350px;\n}\n.max-w-\\[90\\%\\] {\n  max-width: 90%;\n}\n.max-w-\\[calc\\(100\\%-1rem\\)\\] {\n  max-width: calc(100% - 1rem);\n}\n.max-w-chat-container {\n  max-width: var(--typebot-chat-container-max-width);\n}\n.max-w-full {\n  max-width: 100%;\n}\n.max-w-lg {\n  max-width: 512px;\n}\n.max-w-md {\n  max-width: 448px;\n}\n.flex-1 {\n  flex: 1 1 0%;\n}\n.flex-none {\n  flex: none;\n}\n.flex-shrink-0 {\n  flex-shrink: 0;\n}\n.-rotate-180 {\n  --tw-rotate: -180deg;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n.rotate-0 {\n  --tw-rotate: 0deg;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n.scale-0 {\n  --tw-scale-x: 0;\n  --tw-scale-y: 0;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n.scale-100 {\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n.transform {\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n@keyframes fade-in {\n\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n.animate-fade-in {\n  animation: fade-in 0.3s ease-out;\n}\n@keyframes ping {\n\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0;\n  }\n}\n.animate-ping {\n  animation: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;\n}\n@keyframes spin {\n\n  to {\n    transform: rotate(360deg);\n  }\n}\n.animate-spin {\n  animation: spin 1s linear infinite;\n}\n.cursor-pointer {\n  cursor: pointer;\n}\n.select-none {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.flex-col {\n  flex-direction: column;\n}\n.flex-wrap {\n  flex-wrap: wrap;\n}\n.items-start {\n  align-items: flex-start;\n}\n.items-end {\n  align-items: flex-end;\n}\n.items-center {\n  align-items: center;\n}\n.justify-end {\n  justify-content: flex-end;\n}\n.justify-center {\n  justify-content: center;\n}\n.justify-between {\n  justify-content: space-between;\n}\n.gap-1 {\n  gap: 4px;\n}\n.gap-2 {\n  gap: 8px;\n}\n.gap-3 {\n  gap: 12px;\n}\n.gap-4 {\n  gap: 16px;\n}\n.gap-6 {\n  gap: 24px;\n}\n.space-y-4 > :not([hidden]) ~ :not([hidden]) {\n  --tw-space-y-reverse: 0;\n  margin-top: calc(16px * calc(1 - var(--tw-space-y-reverse)));\n  margin-bottom: calc(16px * var(--tw-space-y-reverse));\n}\n.divide-y > :not([hidden]) ~ :not([hidden]) {\n  --tw-divide-y-reverse: 0;\n  border-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));\n  border-bottom-width: calc(1px * var(--tw-divide-y-reverse));\n}\n.overflow-auto {\n  overflow: auto;\n}\n.overflow-hidden {\n  overflow: hidden;\n}\n.overflow-y-auto {\n  overflow-y: auto;\n}\n.overflow-y-scroll {\n  overflow-y: scroll;\n}\n.scroll-smooth {\n  scroll-behavior: smooth;\n}\n.text-ellipsis {\n  text-overflow: ellipsis;\n}\n.whitespace-pre-wrap {\n  white-space: pre-wrap;\n}\n.rounded-2xl {\n  border-radius: 16px;\n}\n.rounded-3xl {\n  border-radius: 24px;\n}\n.rounded-\\[6px\\] {\n  border-radius: 6px;\n}\n.rounded-button {\n  border-radius: var(--typebot-button-border-radius);\n}\n.rounded-chat {\n  border-radius: var(--typebot-chat-container-border-radius);\n}\n.rounded-full {\n  border-radius: 9999px;\n}\n.rounded-host-bubble {\n  border-radius: var(--typebot-host-bubble-border-radius);\n}\n.rounded-lg {\n  border-radius: 8px;\n}\n.rounded-md {\n  border-radius: 6px;\n}\n.rounded-none {\n  border-radius: 0px;\n}\n.rounded-b-host-bubble {\n  border-bottom-right-radius: var(--typebot-host-bubble-border-radius);\n  border-bottom-left-radius: var(--typebot-host-bubble-border-radius);\n}\n.rounded-b-none {\n  border-bottom-right-radius: 0px;\n  border-bottom-left-radius: 0px;\n}\n.rounded-r-md {\n  border-top-right-radius: 6px;\n  border-bottom-right-radius: 6px;\n}\n.rounded-t-host-bubble {\n  border-top-left-radius: var(--typebot-host-bubble-border-radius);\n  border-top-right-radius: var(--typebot-host-bubble-border-radius);\n}\n.border {\n  border-width: 1px;\n}\n.border-2 {\n  border-width: 2px;\n}\n.border-button {\n  border-width: var(--typebot-button-border-width);\n}\n.border-host-bubble {\n  border-width: var(--typebot-host-bubble-border-width);\n}\n.border-input {\n  border-width: var(--typebot-input-border-width);\n}\n.border-b {\n  border-bottom-width: 1px;\n}\n.border-b-0 {\n  border-bottom-width: 0px;\n}\n.border-l {\n  border-left-width: 1px;\n}\n.border-dashed {\n  border-style: dashed;\n}\n.border-button-border {\n  border-color: rgba(var(--typebot-button-border-rgb), var(--typebot-button-border-opacity));;\n}\n.border-host-bubble-border {\n  border-color: rgba(var(--typebot-host-bubble-border-rgb), var(--typebot-host-bubble-border-opacity));;\n}\n.border-input-border {\n  border-color: rgba(var(--typebot-input-border-rgb), var(--typebot-input-border-opacity));;\n}\n.bg-\\[\\#202020\\] {\n  --tw-bg-opacity: 1;\n  background-color: rgb(32 32 32 / var(--tw-bg-opacity, 1));\n}\n.bg-\\[rgba\\(0\\2c 0\\2c 0\\2c 0\\.8\\)\\] {\n  background-color: rgba(0,0,0,0.8);\n}\n.bg-button-bg {\n  background-color: rgba(var(--typebot-button-bg-rgb), var(--typebot-button-opacity));;\n}\n.bg-host-bubble-bg {\n  background-color: rgba(var(--typebot-host-bubble-bg-rgb), var(--typebot-host-bubble-opacity));;\n}\n.bg-input-bg {\n  background-color: rgba(var(--typebot-input-bg-rgb), var(--typebot-input-opacity));;\n}\n.bg-transparent {\n  background-color: transparent;\n}\n.bg-white {\n  --tw-bg-opacity: 1;\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1));\n}\n.bg-opacity-50 {\n  --tw-bg-opacity: 0.5;\n}\n.fill-transparent {\n  fill: transparent;\n}\n.object-cover {\n  -o-object-fit: cover;\n     object-fit: cover;\n}\n.p-0\\.5 {\n  padding: 2px;\n}\n.p-1 {\n  padding: 4px;\n}\n.p-2 {\n  padding: 8px;\n}\n.p-3 {\n  padding: 12px;\n}\n.p-4 {\n  padding: 16px;\n}\n.p-\\[1px\\] {\n  padding: 1px;\n}\n.px-2 {\n  padding-left: 8px;\n  padding-right: 8px;\n}\n.px-3 {\n  padding-left: 12px;\n  padding-right: 12px;\n}\n.px-4 {\n  padding-left: 16px;\n  padding-right: 16px;\n}\n.px-6 {\n  padding-left: 24px;\n  padding-right: 24px;\n}\n.px-8 {\n  padding-left: 32px;\n  padding-right: 32px;\n}\n.px-\\[15px\\] {\n  padding-left: 15px;\n  padding-right: 15px;\n}\n.py-2 {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.py-3 {\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n.py-4 {\n  padding-top: 16px;\n  padding-bottom: 16px;\n}\n.py-6 {\n  padding-top: 24px;\n  padding-bottom: 24px;\n}\n.py-8 {\n  padding-top: 32px;\n  padding-bottom: 32px;\n}\n.py-\\[7px\\] {\n  padding-top: 7px;\n  padding-bottom: 7px;\n}\n.pb-0 {\n  padding-bottom: 0px;\n}\n.pb-2 {\n  padding-bottom: 8px;\n}\n.pl-2 {\n  padding-left: 8px;\n}\n.pl-4 {\n  padding-left: 16px;\n}\n.pr-1 {\n  padding-right: 4px;\n}\n.pr-2 {\n  padding-right: 8px;\n}\n.pr-4 {\n  padding-right: 16px;\n}\n.pr-8 {\n  padding-right: 32px;\n}\n.pt-\\[3px\\] {\n  padding-top: 3px;\n}\n.text-left {\n  text-align: left;\n}\n.text-center {\n  text-align: center;\n}\n.text-right {\n  text-align: right;\n}\n.font-sans {\n  font-family: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";\n}\n.text-2xl {\n  font-size: 24px;\n  line-height: 32px;\n}\n.text-3xl {\n  font-size: 30px;\n  line-height: 36px;\n}\n.text-4xl {\n  font-size: 36px;\n  line-height: 40px;\n}\n.text-\\[40px\\] {\n  font-size: 40px;\n}\n.text-base {\n  font-size: 16px;\n  line-height: 24px;\n}\n.text-lg {\n  font-size: 18px;\n  line-height: 28px;\n}\n.text-sm {\n  font-size: 14px;\n  line-height: 20px;\n}\n.text-xl {\n  font-size: 20px;\n  line-height: 28px;\n}\n.text-xs {\n  font-size: 12px;\n  line-height: 16px;\n}\n.font-bold {\n  font-weight: 700;\n}\n.font-extrabold {\n  font-weight: 800;\n}\n.font-normal {\n  font-weight: 400;\n}\n.font-semibold {\n  font-weight: 600;\n}\n.italic {\n  font-style: italic;\n}\n.text-button-text {\n  color: var(--typebot-button-color);\n}\n.text-host-bubble-text {\n  color: var(--typebot-host-bubble-color);\n}\n.text-input-text {\n  color: var(--typebot-input-color);\n}\n.text-white {\n  --tw-text-opacity: 1;\n  color: rgb(255 255 255 / var(--tw-text-opacity, 1));\n}\n.underline {\n  text-decoration-line: underline;\n}\n.no-underline {\n  text-decoration-line: none;\n}\n.opacity-0 {\n  opacity: 0;\n}\n.opacity-100 {\n  opacity: 1;\n}\n.opacity-25 {\n  opacity: 0.25;\n}\n.opacity-75 {\n  opacity: 0.75;\n}\n.shadow {\n  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n.shadow-button {\n  --tw-shadow: var(--typebot-button-box-shadow);\n  --tw-shadow-colored: var(--typebot-button-box-shadow);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n.shadow-host-bubble {\n  --tw-shadow: var(--typebot-host-bubble-box-shadow);\n  --tw-shadow-colored: var(--typebot-host-bubble-box-shadow);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n.shadow-input {\n  --tw-shadow: var(--typebot-input-box-shadow);\n  --tw-shadow-colored: var(--typebot-input-box-shadow);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n.shadow-md {\n  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n.shadow-xl {\n  --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n.blur {\n  --tw-blur: blur(8px);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.blur-button {\n  --tw-blur: blur(var(--typebot-button-blur));\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.brightness-150 {\n  --tw-brightness: brightness(1.5);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.brightness-200 {\n  --tw-brightness: brightness(2);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.brightness-95 {\n  --tw-brightness: brightness(.95);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.filter {\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.transition {\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n.transition-\\[filter\\] {\n  transition-property: filter;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n.transition-all {\n  transition-property: all;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n.transition-opacity {\n  transition-property: opacity;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n.transition-transform {\n  transition-property: transform;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n}\n.duration-200 {\n  transition-duration: 200ms;\n}\n.ease-in-out {\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n}\n.ease-out {\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);\n}\n\n/* Hide scrollbar for Chrome, Safari and Opera */\n.scrollable-container::-webkit-scrollbar {\n  display: none;\n}\n\n/* Hide scrollbar for IE, Edge and Firefox */\n.scrollable-container {\n  -ms-overflow-style: none; /* IE and Edge */\n  scrollbar-width: none; /* Firefox */\n}\n\n.text-fade-in {\n  transition: opacity 400ms ease-in 200ms;\n}\n\n.bubble-typing {\n  transition: width 400ms ease-out, height 400ms ease-out;\n}\n\n.bubble1,\n.bubble2,\n.bubble3 {\n  background-color: var(--typebot-host-bubble-color);\n  opacity: 0.5;\n}\n\n.bubble1 {\n  animation: chatBubbles 1s ease-in-out infinite;\n}\n\n.bubble2 {\n  animation: chatBubbles 1s ease-in-out infinite;\n  animation-delay: 0.3s;\n}\n\n.bubble3 {\n  animation: chatBubbles 1s ease-in-out infinite;\n  animation-delay: 0.5s;\n}\n\n@keyframes chatBubbles {\n  0% {\n    transform: translateY(2.5);\n  }\n  50% {\n    transform: translateY(-2.5px);\n  }\n  100% {\n    transform: translateY(0);\n  }\n}\n\n/* button,\ninput,\ntextarea {\n  font-weight: 300;\n} */\n\na {\n  text-decoration: underline;\n}\n\nul,\nol {\n  margin-inline-start: 0px;\n  margin-inline-end: 0px;\n  padding-inline-start: 40px;\n}\n\nol {\n  list-style-type: decimal;\n}\n\nul {\n  list-style-type: disc;\n}\n\nli:not(:last-child) {\n  margin-bottom: 8px;\n}\n\npre {\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  overflow-wrap: break-word;\n  max-height: 100%;\n  max-width: 100%;\n  overflow: auto;\n}\n\n.slate-bold {\n  font-weight: bold;\n}\n\n.slate-italic {\n  font-style: oblique;\n}\n\n.slate-underline {\n  text-decoration: underline;\n}\n.text-input::-moz-placeholder {\n  color: var(--typebot-input-placeholder-color) !important;\n  opacity: 1 !important;\n}\n.text-input::placeholder {\n  color: var(--typebot-input-placeholder-color) !important;\n  opacity: 1 !important;\n}\n\n.typebot-container {\n  background-image: var(--typebot-container-bg-image);\n  background-color: var(--typebot-container-bg-color);\n  background-position: center;\n  background-size: cover;\n  font-family: var(--typebot-container-font-family), -apple-system,\n    BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif,\n    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";\n  container-type: inline-size;\n  position: relative;\n}\n\n.typebot-chat-view {\n  padding-left: 12px;\n  padding-right: 12px;\n  padding-top: 20px;\n  /* background-color: rgba(\n    var(--typebot-chat-container-bg-rgb),\n    var(--typebot-chat-container-opacity)\n  ); */\n  color: rgb(var(--typebot-chat-container-color));\n  -webkit-backdrop-filter: blur(var(--typebot-chat-container-blur));\n          backdrop-filter: blur(var(--typebot-chat-container-blur));\n  border-width: var(--typebot-chat-container-border-width);\n  border-color: rgba(\n    var(--typebot-chat-container-border-rgb),\n    var(--typebot-chat-container-border-opacity)\n  );\n  box-shadow: var(--typebot-chat-container-box-shadow);\n}\n\n/* TODO: Use @tailwindcss/container-queries*/\n@container (min-width: 432px) {\n  .typebot-chat-view {\n    padding-left: 20px;\n    padding-right: 20px;\n    padding-top: 40px;\n    min-height: var(--typebot-chat-container-max-height);\n    max-height: var(--typebot-chat-container-max-height);\n    border-radius: var(--typebot-chat-container-border-radius);\n  }\n}\n\n.typebot-selectable {\n  border-width: var(--typebot-button-border-width);\n  border-color: rgba(\n    var(--typebot-button-border-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.25)\n  );\n  border-radius: var(--typebot-button-border-radius);\n  color: rgb(var(--typebot-chat-container-color));\n  background-color: rgba(\n    var(--typebot-button-bg-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.08)\n  );\n  transition: all 0.3s ease;\n}\n\n.typebot-selectable:hover {\n  background-color: rgba(\n    var(--typebot-button-bg-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.12)\n  );\n  border-color: rgba(\n    var(--typebot-button-border-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.3)\n  );\n}\n\n.typebot-selectable.selected {\n  background-color: rgba(\n    var(--typebot-button-bg-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.18)\n  );\n  border-color: rgba(\n    var(--typebot-button-border-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.35)\n  );\n}\n\n.typebot-checkbox {\n  border: 1px solid\n    rgba(var(--typebot-button-bg-rgb), var(--typebot-button-opacity));\n  border-radius: var(--typebot-button-border-radius);\n  background-color: rgba(var(--typebot-checkbox-bg-rgb));\n  color: var(--typebot-button-color);\n  padding: 1px;\n  border-radius: 2px;\n  transition: all 0.3s ease;\n}\n\n.typebot-checkbox.checked {\n  background-color: rgb(var(--typebot-button-bg-rgb));\n}\n\n.typebot-host-bubble {\n  color: var(--typebot-host-bubble-color);\n}\n\n.typebot-host-bubble > .bubble-typing {\n  background-color: rgba(\n    var(--typebot-host-bubble-bg-rgb),\n    var(--typebot-host-bubble-opacity)\n  );\n  border-width: var(--typebot-host-bubble-border-width);\n  border-color: rgba(\n    var(--typebot-host-bubble-border-rgb),\n    var(--typebot-host-bubble-border-opacity)\n  );\n  border-radius: var(--typebot-host-bubble-border-radius);\n  box-shadow: var(--typebot-host-bubble-box-shadow);\n  -webkit-backdrop-filter: blur(var(--typebot-host-bubble-blur));\n          backdrop-filter: blur(var(--typebot-host-bubble-blur));\n}\n\n.typebot-host-bubble img,\n.typebot-host-bubble video,\n.typebot-host-bubble iframe {\n  border-radius: 6px;\n}\n\n.typebot-guest-bubble {\n  color: var(--typebot-guest-bubble-color);\n  background-color: rgba(\n    var(--typebot-guest-bubble-bg-rgb),\n    var(--typebot-guest-bubble-opacity)\n  );\n  border-width: var(--typebot-guest-bubble-border-width);\n  border-color: rgba(\n    var(--typebot-guest-bubble-border-rgb),\n    var(--typebot-guest-bubble-border-opacity)\n  );\n  border-radius: var(--typebot-guest-bubble-border-radius);\n  box-shadow: var(--typebot-guest-bubble-box-shadow);\n  -webkit-backdrop-filter: blur(var(--typebot-guest-bubble-blur));\n          backdrop-filter: blur(var(--typebot-guest-bubble-blur));\n}\n\n.typebot-guest-bubble-image-attachment {\n  border-radius: var(--typebot-guest-bubble-border-radius);\n}\n\n.typebot-input {\n  color: var(--typebot-input-color);\n  background-color: rgba(\n    var(--typebot-input-bg-rgb),\n    var(--typebot-input-opacity)\n  );\n  border-width: var(--typebot-input-border-width);\n  border-color: rgba(\n    var(--typebot-input-border-rgb),\n    var(--typebot-input-border-opacity)\n  );\n  border-radius: var(--typebot-input-border-radius);\n  box-shadow: var(--typebot-input-box-shadow);\n  -webkit-backdrop-filter: blur(var(--typebot-input-blur));\n          backdrop-filter: blur(var(--typebot-input-blur));\n  transition: filter 100ms ease;\n}\n\n.typebot-input-error-message {\n  color: var(--typebot-input-color);\n}\n\n.typebot-input-form .typebot-button {\n  box-shadow: var(--typebot-input-box-shadow);\n}\n\n.typebot-button > .send-icon {\n  fill: var(--typebot-button-color);\n}\n\n.ping span {\n  background-color: rgb(var(--typebot-button-bg-rgb));\n}\n\n.rating-icon-container svg {\n  width: 42px;\n  height: 42px;\n  stroke: rgb(var(--typebot-button-bg-rgb));\n  fill: rgba(\n    var(--typebot-host-bubble-bg-rgb),\n    var(--typebot-host-bubble-opacity)\n  );\n  transition: fill 100ms ease-out;\n}\n\n.rating-icon-container.selected svg {\n  fill: rgb(var(--typebot-button-bg-rgb));\n}\n\n.rating-icon-container:hover svg {\n  filter: brightness(0.9);\n}\n\n.rating-icon-container:active svg {\n  filter: brightness(0.75);\n}\n\n.upload-progress-bar {\n  background-color: rgb(var(--typebot-button-bg-rgb));\n  border-radius: var(--typebot-input-border-radius);\n}\n\n.total-files-indicator {\n  background-color: rgb(var(--typebot-button-bg-rgb));\n  color: var(--typebot-button-color);\n  font-size: 10px;\n}\n\n.typebot-upload-input {\n  transition: border-color 100ms ease-out;\n  border-radius: var(--typebot-input-border-radius);\n}\n\n.typebot-upload-input.dragging-over {\n  border-color: rgb(var(--typebot-button-bg-rgb));\n}\n\n.typebot-country-select {\n  color: var(--typebot-input-color);\n  background-color: var(--typebot-input-bg-color);\n  border-radius: var(--typebot-button-border-radius);\n}\n\n.typebot-datetime-input {\n  color-scheme: light;\n  color: var(--typebot-input-color);\n  background-color: var(--typebot-input-bg-color);\n  border-radius: var(--typebot-input-border-radius);\n}\n\n.typebot-picture-button {\n  color: var(--typebot-button-color);\n  background-color: rgb(var(--typebot-button-bg-rgb));\n  border-radius: var(--typebot-button-border-radius);\n  transition: all 0.3s ease;\n  width: 236px;\n}\n\n.typebot-picture-button > img,\n.typebot-selectable-picture > img {\n  border-radius: var(--typebot-button-border-radius)\n    var(--typebot-button-border-radius) 0 0;\n  min-width: 200px;\n  width: 100%;\n  max-height: 200px;\n  height: 100%;\n  -o-object-fit: cover;\n     object-fit: cover;\n}\n\n.typebot-picture-button.has-svg > img,\n.typebot-selectable-picture.has-svg > img {\n  max-height: 128px;\n  -o-object-fit: contain;\n     object-fit: contain;\n  padding: 1rem;\n}\n\n.typebot-selectable-picture {\n  border: 1px solid\n    rgba(\n      var(--typebot-button-bg-rgb),\n      calc(var(--selectable-alpha-ratio) * 0.25)\n    );\n  border-radius: var(--typebot-button-border-radius);\n  color: rgb(var(--typebot-chat-container-color));\n  background-color: rgba(\n    var(--typebot-button-bg-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.08)\n  );\n  transition: all 0.3s ease;\n  width: 236px;\n}\n\n.typebot-selectable-picture:hover {\n  background-color: rgba(\n    var(--typebot-button-bg-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.12)\n  );\n  border-color: rgba(\n    var(--typebot-button-bg-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.3)\n  );\n}\n\n.typebot-selectable-picture.selected {\n  background-color: rgba(\n    var(--typebot-button-bg-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.18)\n  );\n  border-color: rgba(\n    var(--typebot-button-bg-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.35)\n  );\n}\n\nselect option {\n  color: var(--typebot-input-color);\n  background-color: var(--typebot-input-bg-color);\n}\n\n.typebot-progress-bar-container {\n  background-color: rgba(\n    var(--typebot-progress-bar-bg-rgb),\n    calc(var(--selectable-alpha-ratio) * 0.12)\n  );\n\n  height: var(--typebot-progress-bar-height);\n  position: var(--typebot-progress-bar-position);\n  top: var(--typebot-progress-bar-top);\n  bottom: var(--typebot-progress-bar-bottom);\n  left: 0;\n  width: 100%;\n  z-index: 42424242;\n}\n\n.typebot-progress-bar-container > .typebot-progress-bar {\n  background-color: var(--typebot-progress-bar-color);\n  position: absolute;\n  height: 100%;\n  transition: width 0.25s ease;\n}\n\n.typebot-recorder .left-gradient {\n  background-image: linear-gradient(\n    to right,\n    rgba(var(--typebot-input-bg-rgb), 1),\n    rgba(var(--typebot-input-bg-rgb), 0)\n  );\n}\n\n.typebot-recorder .right-gradient {\n  background-image: linear-gradient(\n    to left,\n    rgba(var(--typebot-input-bg-rgb), 1),\n    rgba(var(--typebot-input-bg-rgb), 0)\n  );\n}\n\n.typebot-recorder button {\n  color: rgba(var(--typebot-button-bg-rgb));\n  background-color: rgba(var(--typebot-button-bg-rgb), 0.3);\n}\n\n@keyframes fadeInFromTop {\n  0% {\n    opacity: 0;\n    transform: translateY(-4px);\n  }\n  100% {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n@keyframes fadeOutFromTop {\n  0% {\n    opacity: 1;\n    transform: translateY(0);\n  }\n\n  100% {\n    opacity: 0;\n    transform: translateY(-4px);\n  }\n}\n\n@keyframes fadeInFromBottom {\n  0% {\n    opacity: 0;\n    transform: translateY(4px);\n  }\n  100% {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n@keyframes fadeOutFromBottom {\n  0% {\n    opacity: 1;\n    transform: translateY(0);\n  }\n\n  100% {\n    opacity: 0;\n    transform: translateY(4px);\n  }\n}\n\n[data-scope="menu"][data-part="content"] {\n  color: var(--typebot-input-color);\n  background-color: rgba(\n    var(--typebot-input-bg-rgb),\n    var(--typebot-input-opacity)\n  );\n  border-width: var(--typebot-input-border-width);\n  border-color: rgba(\n    var(--typebot-input-border-rgb),\n    var(--typebot-input-border-opacity)\n  );\n  border-radius: var(--typebot-input-border-radius);\n  box-shadow: var(--typebot-input-box-shadow);\n  -webkit-backdrop-filter: blur(var(--typebot-input-blur));\n          backdrop-filter: blur(var(--typebot-input-blur));\n}\n\n[data-scope="menu"][data-part="item"] {\n  cursor: pointer;\n  background-color: rgba(\n    var(--typebot-input-bg-rgb),\n    var(--typebot-input-opacity)\n  );\n  border-radius: var(--typebot-input-border-radius);\n}\n\n[data-scope="menu"][data-part="content"][data-state="open"] {\n  animation: fadeInFromTop 150ms ease-out forwards;\n}\n\n[data-scope="menu"][data-part="content"][data-state="closed"] {\n  animation: fadeOutFromTop 50ms ease-out forwards;\n}\n\n[data-scope="progress"][data-part="root"] {\n  width: 100%;\n  height: 100%;\n}\n\n[data-scope="progress"][data-part="circle"] {\n  --size: 40px;\n  --thickness: 4px;\n  --radius: calc(40px / 2 - 4px / 2);\n  --circomference: calc(2 * 3.14159 * calc(40px / 2 - 4px / 2));\n}\n\n[data-scope="progress"][data-part="circle-range"] {\n  stroke: white;\n  --transition-prop: stroke-dasharray, stroke, stroke-dashoffset;\n  transition-property: stroke-dasharray, stroke, stroke-dashoffset;\n  --transition-duration: 0.2s;\n  transition-duration: 0.2s;\n}\n\n[data-scope="progress"][data-part="circle-track"] {\n  stroke: rgba(0, 0, 0, 0.5);\n}\n\n.typebot-buttons-input > [data-slot="list"] {\n  flex-direction: var(--typebot-buttons-input-flex-direction);\n  flex-wrap: wrap;\n}\n\n.typebot-buttons-input > .typebot-input {\n  max-width: 350px;\n}\n\n.rounded-3xl {\n  border-radius: 20px;\n}\n\ntextarea {\n  resize: none;\n}\n\ninput::-moz-placeholder {\n  color: #777777;\n}\n\ninput::placeholder {\n  color: #777777;\n}\n\n/* make sure the pattern text is displayed at the exact position of the input text */\nlabel[data-mask-value] {\n  position: absolute;\n  border: 0.1rem solid transparent;\n  padding: 0.5rem 0.75rem;\n}\n\n/* Render the value in a transparent color to move the pattern to the correct position */\nlabel[data-mask-value]::before {\n  content: attr(data-mask-value);\n  color: transparent;\n}\n\n/* Render the visible pattern after the invisible value */\nlabel[data-mask-pattern]::after {\n  content: attr(data-mask-pattern);\n  opacity: 0.7;\n}\n.hover\\:scale-110:hover {\n  --tw-scale-x: 1.1;\n  --tw-scale-y: 1.1;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n.hover\\:shadow-lg:hover {\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n.hover\\:brightness-90:hover {\n  --tw-brightness: brightness(.9);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.hover\\:brightness-95:hover {\n  --tw-brightness: brightness(.95);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.hover\\:backdrop-brightness-95:hover {\n  --tw-backdrop-brightness: brightness(.95);\n  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\n  backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\n}\n.focus\\:outline-none:focus {\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n}\n.active\\:scale-95:active {\n  --tw-scale-x: .95;\n  --tw-scale-y: .95;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n}\n.active\\:brightness-75:active {\n  --tw-brightness: brightness(.75);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.active\\:brightness-90:active {\n  --tw-brightness: brightness(.9);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.disabled\\:cursor-not-allowed:disabled {\n  cursor: not-allowed;\n}\n.disabled\\:opacity-50:disabled {\n  opacity: 0.5;\n}\n.disabled\\:brightness-100:disabled {\n  --tw-brightness: brightness(1);\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\n}\n.group:hover .group-hover\\:opacity-100 {\n  opacity: 1;\n}\n@keyframes fadeOutFromBottom {\n\n  0% {\n    opacity: 1;\n    transform: translateY(0);\n  }\n\n  100% {\n    opacity: 0;\n    transform: translateY(4px);\n  }\n}\n.data-\\[state\\=closed\\]\\:animate-fade-out-from-bottom[data-state="closed"] {\n  animation: fadeOutFromBottom 50ms ease-out forwards;\n}\n@keyframes fadeInFromBottom {\n\n  0% {\n    opacity: 0;\n    transform: translateY(4px);\n  }\n\n  100% {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n.data-\\[state\\=open\\]\\:animate-fade-in-from-bottom[data-state="open"] {\n  animation: fadeInFromBottom 150ms ease-out forwards;\n}\n.data-\\[state\\=open\\]\\:backdrop-brightness-90[data-state="open"] {\n  --tw-backdrop-brightness: brightness(.9);\n  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\n  backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\n}\n@media (min-width: 640px) {\n\n  .sm\\:left-0 {\n    left: 0px;\n  }\n\n  .sm\\:right-0 {\n    right: 0px;\n  }\n\n  .sm\\:my-8 {\n    margin-top: 32px;\n    margin-bottom: 32px;\n  }\n\n  .sm\\:p-0 {\n    padding: 0px;\n  }\n\n  .sm\\:opacity-0 {\n    opacity: 0;\n  }\n}\n';

// src/features/bubble/components/BubbleButton.tsx
var _tmpl$100 = /* @__PURE__ */ template(`<button part=button aria-label="Open chatbot">`);
var _tmpl$230 = /* @__PURE__ */ template(`<svg part=button-icon viewBox="0 0 16 16"><path d="M8 15C12.418 15 16 11.866 16 8C16 4.134 12.418 1 8 1C3.582 1 0 4.134 0 8C0 9.76 0.743 11.37 1.97 12.6C1.873 13.616 1.553 14.73 1.199 15.566C1.12 15.752 1.273 15.96 1.472 15.928C3.728 15.558 5.069 14.99 5.652 14.694C6.41791 14.8983 7.20732 15.0012 8 15Z"fill=currentColor>`);
var _tmpl$323 = /* @__PURE__ */ template(`<img part=button-icon alt="Bubble button icon">`);
var _tmpl$415 = /* @__PURE__ */ template(`<span part=button-icon>`);
var _tmpl$514 = /* @__PURE__ */ template(`<svg part=button-icon viewBox="0 0 24 24"><path fill-rule=evenodd clip-rule=evenodd d="M18.601 8.39897C18.269 8.06702 17.7309 8.06702 17.3989 8.39897L12 13.7979L6.60099 8.39897C6.26904 8.06702 5.73086 8.06702 5.39891 8.39897C5.06696 8.73091 5.06696 9.2691 5.39891 9.60105L11.3989 15.601C11.7309 15.933 12.269 15.933 12.601 15.601L18.601 9.60105C18.9329 9.2691 18.9329 8.73091 18.601 8.39897Z">`);
var _tmpl$613 = /* @__PURE__ */ template(`<img part=button-icon alt="Bubble button close icon">`);
var isImageSrc = (src) => src.startsWith("http") || src.startsWith("data:image/svg+xml");
var BubbleButton = (props7) => (() => {
  var _el$ = _tmpl$100();
  _el$.$$click = () => props7.toggleBot();
  insert(_el$, createComponent(OpenIcon, props7), null);
  insert(_el$, createComponent(CloseIcon2, props7), null);
  createRenderEffect((_p$) => {
    var _v$ = cx("relative shadow-md rounded-2xl hover:scale-110 active:scale-95 transition-transform duration-200 flex justify-center items-center animate-fade-in"), _v$2 = props7.backgroundColor ?? colors.gray.dark["2"], _v$3 = props7.backgroundColor ? isLight(props7.backgroundColor) ? colors.gray.light["12"] : colors.gray.dark["12"] : colors.gray.dark["12"], _v$4 = props7.buttonSize, _v$5 = props7.buttonSize;
    _v$ !== _p$.e && className(_el$, _p$.e = _v$);
    _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$.style.setProperty("background-color", _v$2) : _el$.style.removeProperty("background-color"));
    _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$.style.setProperty("color", _v$3) : _el$.style.removeProperty("color"));
    _v$4 !== _p$.o && ((_p$.o = _v$4) != null ? _el$.style.setProperty("width", _v$4) : _el$.style.removeProperty("width"));
    _v$5 !== _p$.i && ((_p$.i = _v$5) != null ? _el$.style.setProperty("height", _v$5) : _el$.style.removeProperty("height"));
    return _p$;
  }, {
    e: void 0,
    t: void 0,
    a: void 0,
    o: void 0,
    i: void 0
  });
  return _el$;
})();
var OpenIcon = (props7) => createComponent(Switch, {
  get children() {
    return [createComponent(Match, {
      get when() {
        return isNotDefined(props7.customIconSrc);
      },
      get children() {
        var _el$2 = _tmpl$230();
        createRenderEffect(() => setAttribute(_el$2, "class", cx("fill-transparent absolute duration-200 transition size-6", props7.isBotOpened ? "scale-0 opacity-0" : "scale-100 opacity-100")));
        return _el$2;
      }
    }), createComponent(Match, {
      get when() {
        return createMemo(() => !!props7.customIconSrc)() && isImageSrc(props7.customIconSrc);
      },
      get children() {
        var _el$3 = _tmpl$323();
        createRenderEffect((_p$) => {
          var _v$6 = props7.customIconSrc, _v$7 = cx("duration-200 transition", props7.isBotOpened ? "scale-0 opacity-0" : "scale-100 opacity-100", isSvgSrc(props7.customIconSrc) ? "w-[60%]" : "w-full h-full", isSvgSrc(props7.customIconSrc) ? "" : "object-cover rounded-2xl");
          _v$6 !== _p$.e && setAttribute(_el$3, "src", _p$.e = _v$6);
          _v$7 !== _p$.t && className(_el$3, _p$.t = _v$7);
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$3;
      }
    }), createComponent(Match, {
      get when() {
        return createMemo(() => !!props7.customIconSrc)() && !isImageSrc(props7.customIconSrc);
      },
      get children() {
        var _el$4 = _tmpl$415();
        _el$4.style.setProperty("font-family", "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'");
        insert(_el$4, () => props7.customIconSrc);
        createRenderEffect(() => className(_el$4, cx("text-4xl duration-200 transition", props7.isBotOpened ? "scale-0 opacity-0" : "scale-100 opacity-100")));
        return _el$4;
      }
    })];
  }
});
var CloseIcon2 = (props7) => createComponent(Switch, {
  get children() {
    return [createComponent(Match, {
      get when() {
        return isNotDefined(props7.customCloseIconSrc);
      },
      get children() {
        var _el$5 = _tmpl$514();
        _el$5.style.setProperty("fill", "#fff");
        createRenderEffect(() => setAttribute(_el$5, "class", cx("absolute duration-200 transition w-[60%]", props7.isBotOpened ? "scale-100 rotate-0 opacity-100" : "scale-0 -rotate-180 opacity-0")));
        return _el$5;
      }
    }), createComponent(Match, {
      get when() {
        return createMemo(() => !!props7.customCloseIconSrc)() && isImageSrc(props7.customCloseIconSrc);
      },
      get children() {
        var _el$6 = _tmpl$613();
        createRenderEffect((_p$) => {
          var _v$8 = props7.customCloseIconSrc, _v$9 = cx("absolute duration-200 transition", props7.isBotOpened ? "scale-100 rotate-0 opacity-100" : "scale-0 -rotate-180 opacity-0", isSvgSrc(props7.customCloseIconSrc) ? "w-[60%]" : "w-full h-full", isSvgSrc(props7.customCloseIconSrc) ? "" : "object-cover rounded-2xl");
          _v$8 !== _p$.e && setAttribute(_el$6, "src", _p$.e = _v$8);
          _v$9 !== _p$.t && className(_el$6, _p$.t = _v$9);
          return _p$;
        }, {
          e: void 0,
          t: void 0
        });
        return _el$6;
      }
    }), createComponent(Match, {
      get when() {
        return createMemo(() => !!props7.customCloseIconSrc)() && !isImageSrc(props7.customCloseIconSrc);
      },
      get children() {
        var _el$7 = _tmpl$415();
        _el$7.style.setProperty("font-family", "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'");
        insert(_el$7, () => props7.customCloseIconSrc);
        createRenderEffect(() => className(_el$7, cx("absolute text-4xl duration-200 transition", props7.isBotOpened ? "scale-100 rotate-0 opacity-100" : "scale-0 -rotate-180 opacity-0")));
        return _el$7;
      }
    })];
  }
});
delegateEvents(["click"]);

// src/features/bubble/components/PreviewMessage.tsx
var _tmpl$101 = /* @__PURE__ */ template(`<div part=preview-message><p>`);
var _tmpl$231 = /* @__PURE__ */ template(`<img class="rounded-full w-8 h-8 object-cover"alt="Bot avatar"elementtiming="Bot avatar"fetchpriority=high>`);
var _tmpl$324 = /* @__PURE__ */ template(`<button part=preview-message-close-button aria-label=Close><svg xmlns=http://www.w3.org/2000/svg viewBox="0 0 24 24"fill=none stroke=currentColor stroke-width=2 stroke-linecap=round stroke-linejoin=round><line x1=18 y1=6 x2=6 y2=18></line><line x1=6 y1=6 x2=18 y2=18>`);
var defaultBackgroundColor2 = "#F7F8FF";
var defaultTextColor = "#303235";
var PreviewMessage = (props7) => {
  const [isPreviewMessageHovered, setIsPreviewMessageHovered] = createSignal(false);
  const [touchStartPosition, setTouchStartPosition] = createSignal({
    x: 0,
    y: 0
  });
  const handleTouchStart = (e) => {
    setTouchStartPosition({
      x: e.touches[0]?.clientX ?? 0,
      y: e.touches[0]?.clientY ?? 0
    });
  };
  const handleTouchEnd = (e) => {
    const x = e.changedTouches[0]?.clientX ?? 0;
    const y = e.changedTouches[0]?.clientY ?? 0;
    if (Math.abs(x - touchStartPosition().x) > 10 || y - touchStartPosition().y > 10) props7.onCloseClick();
    setTouchStartPosition({
      x: 0,
      y: 0
    });
  };
  return (() => {
    var _el$ = _tmpl$101(), _el$2 = _el$.firstChild;
    _el$.$$touchend = handleTouchEnd;
    _el$.$$touchstart = handleTouchStart;
    _el$.addEventListener("mouseleave", () => setIsPreviewMessageHovered(false));
    _el$.addEventListener("mouseenter", () => setIsPreviewMessageHovered(true));
    _el$.$$click = () => props7.onClick();
    insert(_el$, createComponent(CloseButton, {
      get isHovered() {
        return isPreviewMessageHovered();
      },
      get previewMessageTheme() {
        return props7.previewMessageTheme;
      },
      get onClick() {
        return props7.onCloseClick;
      }
    }), _el$2);
    insert(_el$, createComponent(Show, {
      get when() {
        return props7.avatarUrl;
      },
      keyed: true,
      children: (avatarUrl) => (() => {
        var _el$3 = _tmpl$231();
        setAttribute(_el$3, "src", avatarUrl);
        return _el$3;
      })()
    }), _el$2);
    insert(_el$2, () => props7.message);
    createRenderEffect((_p$) => {
      var _v$ = cx("absolute bottom-[calc(100%+12px)] w-64 rounded-md duration-200 flex items-center gap-4 shadow-md animate-fade-in cursor-pointer hover:shadow-lg p-4", props7.placement === "left" ? "left-0" : "right-0"), _v$2 = props7.previewMessageTheme?.backgroundColor ?? defaultBackgroundColor2, _v$3 = props7.previewMessageTheme?.textColor ?? defaultTextColor;
      _v$ !== _p$.e && className(_el$, _p$.e = _v$);
      _v$2 !== _p$.t && ((_p$.t = _v$2) != null ? _el$.style.setProperty("background-color", _v$2) : _el$.style.removeProperty("background-color"));
      _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$.style.setProperty("color", _v$3) : _el$.style.removeProperty("color"));
      return _p$;
    }, {
      e: void 0,
      t: void 0,
      a: void 0
    });
    return _el$;
  })();
};
var CloseButton = (props7) => (() => {
  var _el$4 = _tmpl$324();
  _el$4.$$click = (e) => {
    e.stopPropagation();
    return props7.onClick();
  };
  createRenderEffect((_p$) => {
    var _v$4 = `absolute -top-2 -right-2 rounded-full w-6 h-6 p-1 hover:brightness-95 active:brightness-90 transition-all border ` + (props7.isHovered ? "opacity-100" : "opacity-0"), _v$5 = props7.previewMessageTheme?.closeButtonBackgroundColor ?? defaultBackgroundColor2, _v$6 = props7.previewMessageTheme?.closeButtonIconColor ?? defaultTextColor;
    _v$4 !== _p$.e && className(_el$4, _p$.e = _v$4);
    _v$5 !== _p$.t && ((_p$.t = _v$5) != null ? _el$4.style.setProperty("background-color", _v$5) : _el$4.style.removeProperty("background-color"));
    _v$6 !== _p$.a && ((_p$.a = _v$6) != null ? _el$4.style.setProperty("color", _v$6) : _el$4.style.removeProperty("color"));
    return _p$;
  }, {
    e: void 0,
    t: void 0,
    a: void 0
  });
  return _el$4;
})();
delegateEvents(["click", "touchstart", "touchend"]);

// src/features/bubble/components/Bubble.tsx
var _tmpl$102 = /* @__PURE__ */ template(`<style>`);
var _tmpl$232 = /* @__PURE__ */ template(`<div>`);
var _tmpl$325 = /* @__PURE__ */ template(`<div><div part=bot><div>`);
var defaultBottom = "20px";
var buttonBotGap = "12px";
var Bubble = (props7) => {
  const [bubbleProps, botProps] = splitProps(props7, ["onOpen", "onClose", "previewMessage", "onPreviewMessageClick", "onPreviewMessageDismissed", "theme", "autoShowDelay", "inlineStyle"]);
  const [isInitialized, setIsInitialized] = createSignal(false);
  const [isMounted, setIsMounted] = createSignal(true);
  const [prefilledVariables, setPrefilledVariables2] = createSignal(botProps.prefilledVariables);
  const [isPreviewMessageDisplayed, setIsPreviewMessageDisplayed] = createSignal(false);
  const [previewMessage, setPreviewMessage] = createSignal({
    message: bubbleProps.previewMessage?.message ?? "",
    avatarUrl: bubbleProps.previewMessage?.avatarUrl
  });
  const [isBotOpened, setIsBotOpened] = createSignal(false);
  const [isBotStarted, setIsBotStarted] = createSignal(false);
  const [buttonSize, setButtonSize] = createSignal(parseButtonSize(bubbleProps.theme?.button?.size ?? "medium"));
  createEffect(() => {
    setButtonSize(parseButtonSize(bubbleProps.theme?.button?.size ?? "medium"));
  });
  let progressBarContainerRef;
  const initializeBubble = () => {
    window.addEventListener("message", processIncomingEvent);
    const autoShowDelay = bubbleProps.autoShowDelay;
    const previewMessageAutoShowDelay = bubbleProps.previewMessage?.autoShowDelay;
    if (getBotOpenedStateFromStorage() || getPaymentInProgressInStorage()) openBot();
    if (isDefined(autoShowDelay)) {
      setTimeout(() => {
        openBot();
      }, autoShowDelay);
    }
    if (isDefined(previewMessageAutoShowDelay)) {
      setTimeout(() => {
        showMessage({
          avatarUrl: bubbleProps.previewMessage?.avatarUrl,
          message: bubbleProps.previewMessage?.message ?? ""
        });
      }, previewMessageAutoShowDelay);
    }
  };
  onCleanup(() => {
    setIsInitialized(false);
    window.removeEventListener("message", processIncomingEvent);
  });
  createEffect(() => {
    if (isInitialized() || isNotDefined(botProps.typebot)) return;
    initializeBubble();
    setIsInitialized(true);
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot || data.id && botProps.id !== data.id) return;
    if (data.command === "open") openBot();
    if (data.command === "close") closeBot();
    if (data.command === "toggle") toggleBot();
    if (data.command === "showPreviewMessage") showMessage(data.message);
    if (data.command === "hidePreviewMessage") hideMessage();
    if (data.command === "setPrefilledVariables") setPrefilledVariables2((existingPrefilledVariables) => ({
      ...existingPrefilledVariables,
      ...data.variables
    }));
    if (data.command === "unmount") unmount2();
  };
  const openBot = () => {
    if (!isBotStarted()) setIsBotStarted(true);
    hideMessage();
    setIsBotOpened(true);
    if (isBotOpened()) bubbleProps.onOpen?.();
  };
  const closeBot = () => {
    setIsBotOpened(false);
    removeBotOpenedStateInStorage();
    if (isBotOpened()) bubbleProps.onClose?.();
  };
  const toggleBot = () => {
    isBotOpened() ? closeBot() : openBot();
  };
  const handlePreviewMessageClick = () => {
    bubbleProps.onPreviewMessageClick?.();
    openBot();
  };
  const showMessage = (previewMessage2) => {
    if (previewMessage2) setPreviewMessage(previewMessage2);
    if (isBotOpened()) return;
    setIsPreviewMessageDisplayed(true);
  };
  const hideMessage = () => {
    bubbleProps.onPreviewMessageDismissed?.();
    setIsPreviewMessageDisplayed(false);
  };
  const unmount2 = () => {
    if (isBotOpened()) {
      closeBot();
      setTimeout(() => {
        setIsMounted(false);
      }, 200);
    } else setIsMounted(false);
  };
  const handleOnChatStatePersisted = (isPersisted) => {
    botProps.onChatStatePersisted?.(isPersisted);
    if (isPersisted) setBotOpenedStateInStorage();
  };
  const handleScriptExecutionSuccessMessage = (message) => {
    if (message === zendeskWebWidgetOpenedMessage || message === chatwootWebWidgetOpenedMessage) unmount2();
    botProps.onScriptExecutionSuccess?.(message);
  };
  return createComponent(Show, {
    get when() {
      return isMounted();
    },
    get children() {
      return createComponent(EnvironmentProvider, {
        get value() {
          return document.querySelector("typebot-bubble")?.shadowRoot;
        },
        get children() {
          return [(() => {
            var _el$ = _tmpl$102();
            insert(_el$, assets_default);
            return _el$;
          })(), (() => {
            var _el$2 = _tmpl$232();
            var _ref$ = progressBarContainerRef;
            typeof _ref$ === "function" ? use(_ref$, _el$2) : progressBarContainerRef = _el$2;
            return _el$2;
          })(), (() => {
            var _el$3 = _tmpl$325(), _el$4 = _el$3.firstChild, _el$5 = _el$4.firstChild;
            insert(_el$3, createComponent(Show, {
              get when() {
                return isPreviewMessageDisplayed();
              },
              get children() {
                return createComponent(PreviewMessage, mergeProps(previewMessage, {
                  get placement() {
                    return bubbleProps.theme?.placement;
                  },
                  get previewMessageTheme() {
                    return bubbleProps.theme?.previewMessage;
                  },
                  get buttonSize() {
                    return buttonSize();
                  },
                  onClick: handlePreviewMessageClick,
                  onCloseClick: hideMessage
                }));
              }
            }), _el$4);
            insert(_el$3, createComponent(BubbleButton, mergeProps(() => bubbleProps.theme?.button, {
              get placement() {
                return bubbleProps.theme?.placement;
              },
              toggleBot,
              get isBotOpened() {
                return isBotOpened();
              },
              get buttonSize() {
                return buttonSize();
              }
            })), _el$4);
            _el$4.style.setProperty("transition", "transform 200ms cubic-bezier(0, 1.2, 1, 1), opacity 150ms ease-out");
            _el$4.style.setProperty("box-shadow", "rgb(0 0 0 / 16%) 0px 5px 40px");
            _el$4.style.setProperty("border-radius", "25px");
            _el$4.style.setProperty("display", "flex");
            _el$4.style.setProperty("flex-direction", "column");
            _el$5.style.setProperty("flex", "1");
            insert(_el$5, createComponent(Show, {
              get when() {
                return isBotStarted();
              },
              get children() {
                return createComponent(BotWrapper, mergeProps(botProps, {
                  onScriptExecutionSuccess: handleScriptExecutionSuccessMessage,
                  onChatStatePersisted: handleOnChatStatePersisted,
                  get prefilledVariables() {
                    return prefilledVariables();
                  },
                  "class": "rounded-lg",
                  progressBarRef: progressBarContainerRef
                }));
              }
            }));
            createRenderEffect((_p$) => {
              var _v$ = cx(bubbleProps.theme?.position !== "static" ? bubbleProps.theme?.placement === "left" ? "z-[424242] fixed bottom-5 left-5" : "z-[424242] fixed bottom-5 right-5" : "relative"), _v$2 = bubbleProps.inlineStyle, _v$3 = `calc(100vh - ${defaultBottom} - ${buttonSize()} - ${buttonBotGap})`, _v$4 = bubbleProps.theme?.chatWindow?.maxHeight ?? "704px", _v$5 = bubbleProps.theme?.chatWindow?.maxWidth ?? "400px", _v$6 = bubbleProps.theme?.placement === "left" ? "bottom left" : "bottom right", _v$7 = isBotOpened() ? "scale3d(1, 1, 1)" : "scale3d(0, 0, 1)", _v$8 = cx("absolute rounded-lg w-screen bottom-[calc(100%+12px)]", isBotOpened() ? "opacity-1" : "opacity-0 pointer-events-none", bubbleProps.theme?.placement === "left" ? "sm:left-0 -left-5" : "sm:right-0 -right-5");
              _v$ !== _p$.e && className(_el$3, _p$.e = _v$);
              _p$.t = style(_el$3, _v$2, _p$.t);
              _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$4.style.setProperty("max-height", _v$3) : _el$4.style.removeProperty("max-height"));
              _v$4 !== _p$.o && ((_p$.o = _v$4) != null ? _el$4.style.setProperty("height", _v$4) : _el$4.style.removeProperty("height"));
              _v$5 !== _p$.i && ((_p$.i = _v$5) != null ? _el$4.style.setProperty("max-width", _v$5) : _el$4.style.removeProperty("max-width"));
              _v$6 !== _p$.n && ((_p$.n = _v$6) != null ? _el$4.style.setProperty("transform-origin", _v$6) : _el$4.style.removeProperty("transform-origin"));
              _v$7 !== _p$.s && ((_p$.s = _v$7) != null ? _el$4.style.setProperty("transform", _v$7) : _el$4.style.removeProperty("transform"));
              _v$8 !== _p$.h && className(_el$4, _p$.h = _v$8);
              return _p$;
            }, {
              e: void 0,
              t: void 0,
              a: void 0,
              o: void 0,
              i: void 0,
              n: void 0,
              s: void 0,
              h: void 0
            });
            return _el$3;
          })()];
        }
      });
    }
  });
};
var parseButtonSize = (size3) => size3 === "medium" ? "48px" : size3 === "large" ? "64px" : size3 ? size3 : "48px";

// src/features/popup/components/Popup.tsx
var _tmpl$103 = /* @__PURE__ */ template(`<style>`);
var _tmpl$233 = /* @__PURE__ */ template(`<div class=relative aria-labelledby=modal-title role=dialog aria-modal=true><style></style><div class="fixed inset-0 bg-black bg-opacity-50 transition-opacity animate-fade-in"part=overlay></div><div class="fixed inset-0 z-10 overflow-y-auto"><div class="flex min-h-full items-center justify-center p-4 text-center sm:p-0"><div>`);
var Popup = (props7) => {
  const [popupProps, botProps] = splitProps(props7, ["onOpen", "onClose", "autoShowDelay", "theme", "isOpen", "defaultOpen"]);
  const [prefilledVariables, setPrefilledVariables2] = createSignal(botProps.prefilledVariables);
  const [isBotOpened, setIsBotOpened] = createSignal(popupProps.isOpen ?? false);
  onMount(() => {
    if (popupProps.defaultOpen || getPaymentInProgressInStorage() || getBotOpenedStateFromStorage()) openBot();
    window.addEventListener("message", processIncomingEvent);
    const autoShowDelay = popupProps.autoShowDelay;
    if (isDefined(autoShowDelay)) {
      setTimeout(() => {
        openBot();
      }, autoShowDelay);
    }
  });
  onCleanup(() => {
    window.removeEventListener("message", processIncomingEvent);
  });
  createEffect(() => {
    if (isNotDefined(props7.isOpen) || props7.isOpen === isBotOpened()) return;
    toggleBot();
  });
  createEffect(() => {
    if (!props7.prefilledVariables) return;
    setPrefilledVariables2((existingPrefilledVariables) => ({
      ...existingPrefilledVariables,
      ...props7.prefilledVariables
    }));
  });
  const stopPropagation = (event) => {
    event.stopPropagation();
  };
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot || data.id && botProps.id !== data.id) return;
    if (data.command === "open") openBot();
    if (data.command === "close") closeBot();
    if (data.command === "toggle") toggleBot();
    if (data.command === "setPrefilledVariables") setPrefilledVariables2((existingPrefilledVariables) => ({
      ...existingPrefilledVariables,
      ...data.variables
    }));
  };
  const openBot = () => {
    setIsBotOpened(true);
    popupProps.onOpen?.();
    document.body.style.setProperty("overflow", "hidden", "important");
    document.addEventListener("pointerdown", closeBot);
  };
  const closeBot = () => {
    setIsBotOpened(false);
    popupProps.onClose?.();
    document.body.style.overflow = "auto";
    document.removeEventListener("pointerdown", closeBot);
    removeBotOpenedStateInStorage();
  };
  const toggleBot = () => {
    isBotOpened() ? closeBot() : openBot();
  };
  const handleOnChatStatePersisted = (isPersisted) => {
    botProps.onChatStatePersisted?.(isPersisted);
    if (isPersisted) setBotOpenedStateInStorage();
  };
  const handleScriptExecutionSuccessMessage = (message) => {
    if (message === zendeskWebWidgetOpenedMessage || message === chatwootWebWidgetOpenedMessage) closeBot();
    props7.onScriptExecutionSuccess?.(message);
  };
  return createComponent(Show, {
    get when() {
      return isBotOpened();
    },
    get children() {
      return createComponent(EnvironmentProvider, {
        get value() {
          return document.querySelector("typebot-popup")?.shadowRoot;
        },
        get children() {
          return [(() => {
            var _el$ = _tmpl$103();
            insert(_el$, assets_default);
            return _el$;
          })(), (() => {
            var _el$2 = _tmpl$233(), _el$3 = _el$2.firstChild, _el$4 = _el$3.nextSibling, _el$5 = _el$4.nextSibling, _el$6 = _el$5.firstChild, _el$7 = _el$6.firstChild;
            insert(_el$3, assets_default);
            addEventListener(_el$7, "pointerdown", stopPropagation);
            insert(_el$7, createComponent(Bot, mergeProps(botProps, {
              onScriptExecutionSuccess: handleScriptExecutionSuccessMessage,
              get prefilledVariables() {
                return prefilledVariables();
              },
              onChatStatePersisted: handleOnChatStatePersisted
            })));
            createRenderEffect((_p$) => {
              var _v$ = props7.theme?.zIndex ?? 42424242, _v$2 = "relative h-[80vh] transform overflow-hidden rounded-lg text-left transition-all sm:my-8 w-full max-w-lg" + (props7.theme?.backgroundColor ? " shadow-xl" : ""), _v$3 = props7.theme?.backgroundColor ?? "transparent", _v$4 = props7.theme?.width ?? "512px";
              _v$ !== _p$.e && ((_p$.e = _v$) != null ? _el$2.style.setProperty("z-index", _v$) : _el$2.style.removeProperty("z-index"));
              _v$2 !== _p$.t && className(_el$7, _p$.t = _v$2);
              _v$3 !== _p$.a && ((_p$.a = _v$3) != null ? _el$7.style.setProperty("background-color", _v$3) : _el$7.style.removeProperty("background-color"));
              _v$4 !== _p$.o && ((_p$.o = _v$4) != null ? _el$7.style.setProperty("max-width", _v$4) : _el$7.style.removeProperty("max-width"));
              return _p$;
            }, {
              e: void 0,
              t: void 0,
              a: void 0,
              o: void 0
            });
            return _el$2;
          })()];
        }
      });
    }
  });
};

// src/features/standard/components/Standard.tsx
var _tmpl$104 = /* @__PURE__ */ template(`<style>
:host {
  display: block;
  width: 100%;
  height: 100%;
  overflow-y: hidden;
}
`);
var Standard = (props7, {
  element
}) => {
  const [isBotDisplayed, setIsBotDisplayed] = createSignal(false);
  const [prefilledVariables, setPrefilledVariables2] = createSignal(props7.prefilledVariables);
  const launchBot = () => {
    setIsBotDisplayed(true);
  };
  const botLauncherObserver = new IntersectionObserver((intersections) => {
    if (intersections.some((intersection) => intersection.isIntersecting)) launchBot();
  });
  onMount(() => {
    window.addEventListener("message", processIncomingEvent);
    botLauncherObserver.observe(element);
  });
  createEffect(() => {
    if (!props7.prefilledVariables) return;
    setPrefilledVariables2((existingPrefilledVariables) => ({
      ...existingPrefilledVariables,
      ...props7.prefilledVariables
    }));
  });
  const processIncomingEvent = (event) => {
    const {
      data
    } = event;
    if (!data.isFromTypebot || data.id && props7.id !== data.id) return;
    if (data.command === "setPrefilledVariables") setPrefilledVariables2((existingPrefilledVariables) => ({
      ...existingPrefilledVariables,
      ...data.variables
    }));
  };
  onCleanup(() => {
    botLauncherObserver.disconnect();
  });
  return createComponent(EnvironmentProvider, {
    get value() {
      return document.querySelector("typebot-standard")?.shadowRoot;
    },
    get children() {
      return [(() => {
        var _el$ = _tmpl$104(), _el$2 = _el$.firstChild;
        insert(_el$, assets_default, _el$2);
        return _el$;
      })(), createComponent(Show, {
        get when() {
          return isBotDisplayed();
        },
        get children() {
          return createComponent(Bot, mergeProps(props7, {
            get prefilledVariables() {
              return prefilledVariables();
            }
          }));
        }
      })];
    }
  });
};

// src/register.ts
var registerWebComponents = () => {
  if (typeof window === "undefined") return;
  customElement("typebot-standard", defaultBotProps, Standard);
  customElement("typebot-bubble", defaultBubbleProps, Bubble);
  customElement("typebot-popup", defaultPopupProps, Popup);
};

// src/features/commands/utils/close.ts
var close = ({ id } = {}) => {
  const message = {
    isFromTypebot: true,
    command: "close",
    id
  };
  window.postMessage(message);
};

// src/features/commands/utils/hidePreviewMessage.ts
var hidePreviewMessage = ({ id } = {}) => {
  const message = {
    isFromTypebot: true,
    command: "hidePreviewMessage",
    id
  };
  window.postMessage(message);
};

// src/features/commands/utils/open.ts
var open = ({ id } = {}) => {
  const message = {
    isFromTypebot: true,
    command: "open",
    id
  };
  window.postMessage(message);
};

// src/features/commands/utils/sendCommand.ts
var sendCommand = (text2, { id } = {}) => {
  const message = {
    isFromTypebot: true,
    command: "sendCommand",
    text: text2,
    id
  };
  window.postMessage(message);
};

// src/features/commands/utils/setInputValue.ts
var setInputValue = (value, { id } = {}) => {
  const message = {
    isFromTypebot: true,
    command: "setInputValue",
    value,
    id
  };
  window.postMessage(message);
};

// src/features/commands/utils/setPrefilledVariables.ts
var setPrefilledVariables = (variables, { id } = {}) => {
  const message = {
    isFromTypebot: true,
    command: "setPrefilledVariables",
    variables,
    id
  };
  window.postMessage(message);
};

// src/features/commands/utils/showPreviewMessage.ts
var showPreviewMessage = (proactiveMessage, { id } = {}) => {
  const message = {
    isFromTypebot: true,
    command: "showPreviewMessage",
    message: proactiveMessage,
    id
  };
  window.postMessage(message);
};

// src/features/commands/utils/toggle.ts
var toggle = ({ id } = {}) => {
  const message = {
    isFromTypebot: true,
    command: "toggle",
    id
  };
  window.postMessage(message);
};

// src/features/commands/utils/unmount.ts
var unmount = ({ id } = {}) => {
  const message = {
    isFromTypebot: true,
    command: "unmount",
    id
  };
  window.postMessage(message);
};

// src/window.ts
var initStandard = (props7) => {
  const standardElement = props7.id ? document.getElementById(props7.id) : document.querySelector("typebot-standard");
  if (!standardElement)
    throw new Error("<typebot-standard> element not found.");
  Object.assign(standardElement, props7);
};
var initPopup = (props7) => {
  const popupElement = document.createElement("typebot-popup");
  Object.assign(popupElement, props7);
  document.body.prepend(popupElement);
};
var initBubble = (props7) => {
  const bubbleElement = document.createElement("typebot-bubble");
  Object.assign(bubbleElement, props7);
  document.body.prepend(bubbleElement);
};
var parseTypebot = () => ({
  initStandard,
  initPopup,
  initBubble,
  close,
  hidePreviewMessage,
  open,
  setPrefilledVariables,
  showPreviewMessage,
  toggle,
  setInputValue,
  unmount,
  sendCommand
});
var injectTypebotInWindow = (typebot2) => {
  if (typeof window === "undefined") return;
  window.Typebot = { ...typebot2 };
};

// src/web.ts
registerWebComponents();
var typebot = parseTypebot();
injectTypebotInWindow(typebot);
var web_default = typebot;
export {
  web_default as default
};
/*! Bundled license information:

ky/distribution/index.js:
  (*! MIT License © Sindre Sorhus *)

partysocket/dist/chunk-4SNNYC7I.mjs:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)

dompurify/dist/purify.es.mjs:
  (*! @license DOMPurify 3.2.4 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.4/LICENSE *)
*/
